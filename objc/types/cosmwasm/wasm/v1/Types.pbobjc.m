// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// clang-format off
// source: cosmwasm/wasm/v1/types.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import <stdatomic.h>

#import "cosmwasm/wasm/v1/Types.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(AbsoluteTxPosition);
GPBObjCClassDeclaration(AccessConfig);
GPBObjCClassDeclaration(AccessTypeParam);
GPBObjCClassDeclaration(CodeInfo);
GPBObjCClassDeclaration(ContractCodeHistoryEntry);
GPBObjCClassDeclaration(ContractInfo);
GPBObjCClassDeclaration(GPBAny);
GPBObjCClassDeclaration(Model);
GPBObjCClassDeclaration(Params);

#pragma mark - TypesRoot

@implementation TypesRoot

// No extensions in the file and no imports or none of the imports (direct or
// indirect) defined extensions, so no need to generate +extensionRegistry.

@end

static GPBFileDescription TypesRoot_FileDescription = {
  .package = "cosmwasm.wasm.v1",
  .prefix = NULL,
  .syntax = GPBFileSyntaxProto3
};

#pragma mark - Enum AccessType

GPBEnumDescriptor *AccessType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "AccessTypeUnspecified\000AccessTypeNobody\000A"
        "ccessTypeEverybody\000AccessTypeAnyOfAddres"
        "ses\000";
    static const int32_t values[] = {
        AccessType_AccessTypeUnspecified,
        AccessType_AccessTypeNobody,
        AccessType_AccessTypeEverybody,
        AccessType_AccessTypeAnyOfAddresses,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AccessType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AccessType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AccessType_IsValidValue(int32_t value__) {
  switch (value__) {
    case AccessType_AccessTypeUnspecified:
    case AccessType_AccessTypeNobody:
    case AccessType_AccessTypeEverybody:
    case AccessType_AccessTypeAnyOfAddresses:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ContractCodeHistoryOperationType

GPBEnumDescriptor *ContractCodeHistoryOperationType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "ContractCodeHistoryOperationTypeUnspecif"
        "ied\000ContractCodeHistoryOperationTypeInit"
        "\000ContractCodeHistoryOperationTypeMigrate"
        "\000ContractCodeHistoryOperationTypeGenesis"
        "\000";
    static const int32_t values[] = {
        ContractCodeHistoryOperationType_ContractCodeHistoryOperationTypeUnspecified,
        ContractCodeHistoryOperationType_ContractCodeHistoryOperationTypeInit,
        ContractCodeHistoryOperationType_ContractCodeHistoryOperationTypeMigrate,
        ContractCodeHistoryOperationType_ContractCodeHistoryOperationTypeGenesis,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ContractCodeHistoryOperationType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ContractCodeHistoryOperationType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ContractCodeHistoryOperationType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ContractCodeHistoryOperationType_ContractCodeHistoryOperationTypeUnspecified:
    case ContractCodeHistoryOperationType_ContractCodeHistoryOperationTypeInit:
    case ContractCodeHistoryOperationType_ContractCodeHistoryOperationTypeMigrate:
    case ContractCodeHistoryOperationType_ContractCodeHistoryOperationTypeGenesis:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - AccessTypeParam

@implementation AccessTypeParam

@dynamic value;

typedef struct AccessTypeParam__storage_ {
  uint32_t _has_storage_[1];
  AccessType value;
} AccessTypeParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.enumDescFunc = AccessType_EnumDescriptor,
        .number = AccessTypeParam_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccessTypeParam__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(AccessTypeParam)
                                   messageName:@"AccessTypeParam"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccessTypeParam__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AccessTypeParam_Value_RawValue(AccessTypeParam *message) {
  GPBDescriptor *descriptor = [AccessTypeParam descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AccessTypeParam_FieldNumber_Value];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAccessTypeParam_Value_RawValue(AccessTypeParam *message, int32_t value) {
  GPBDescriptor *descriptor = [AccessTypeParam descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AccessTypeParam_FieldNumber_Value];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - AccessConfig

@implementation AccessConfig

@dynamic permission;
@dynamic addressesArray, addressesArray_Count;

typedef struct AccessConfig__storage_ {
  uint32_t _has_storage_[1];
  AccessType permission;
  NSMutableArray *addressesArray;
} AccessConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "permission",
        .dataTypeSpecific.enumDescFunc = AccessType_EnumDescriptor,
        .number = AccessConfig_FieldNumber_Permission,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccessConfig__storage_, permission),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "addressesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = AccessConfig_FieldNumber_AddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AccessConfig__storage_, addressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(AccessConfig)
                                   messageName:@"AccessConfig"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccessConfig__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AccessConfig_Permission_RawValue(AccessConfig *message) {
  GPBDescriptor *descriptor = [AccessConfig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AccessConfig_FieldNumber_Permission];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAccessConfig_Permission_RawValue(AccessConfig *message, int32_t value) {
  GPBDescriptor *descriptor = [AccessConfig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AccessConfig_FieldNumber_Permission];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Params

@implementation Params

@dynamic hasCodeUploadAccess, codeUploadAccess;
@dynamic instantiateDefaultPermission;

typedef struct Params__storage_ {
  uint32_t _has_storage_[1];
  AccessType instantiateDefaultPermission;
  AccessConfig *codeUploadAccess;
} Params__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "codeUploadAccess",
        .dataTypeSpecific.clazz = GPBObjCClass(AccessConfig),
        .number = Params_FieldNumber_CodeUploadAccess,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Params__storage_, codeUploadAccess),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "instantiateDefaultPermission",
        .dataTypeSpecific.enumDescFunc = AccessType_EnumDescriptor,
        .number = Params_FieldNumber_InstantiateDefaultPermission,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Params__storage_, instantiateDefaultPermission),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Params)
                                   messageName:@"Params"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Params__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Params_InstantiateDefaultPermission_RawValue(Params *message) {
  GPBDescriptor *descriptor = [Params descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Params_FieldNumber_InstantiateDefaultPermission];
  return GPBGetMessageRawEnumField(message, field);
}

void SetParams_InstantiateDefaultPermission_RawValue(Params *message, int32_t value) {
  GPBDescriptor *descriptor = [Params descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Params_FieldNumber_InstantiateDefaultPermission];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - CodeInfo

@implementation CodeInfo

@dynamic codeHash;
@dynamic creator;
@dynamic hasInstantiateConfig, instantiateConfig;

typedef struct CodeInfo__storage_ {
  uint32_t _has_storage_[1];
  NSData *codeHash;
  NSString *creator;
  AccessConfig *instantiateConfig;
} CodeInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "codeHash",
        .dataTypeSpecific.clazz = Nil,
        .number = CodeInfo_FieldNumber_CodeHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CodeInfo__storage_, codeHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "creator",
        .dataTypeSpecific.clazz = Nil,
        .number = CodeInfo_FieldNumber_Creator,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CodeInfo__storage_, creator),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "instantiateConfig",
        .dataTypeSpecific.clazz = GPBObjCClass(AccessConfig),
        .number = CodeInfo_FieldNumber_InstantiateConfig,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CodeInfo__storage_, instantiateConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CodeInfo)
                                   messageName:@"CodeInfo"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CodeInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ContractInfo

@implementation ContractInfo

@dynamic codeId;
@dynamic creator;
@dynamic admin;
@dynamic label;
@dynamic hasCreated, created;
@dynamic ibcPortId;
@dynamic ibc2PortId;
@dynamic hasExtension, extension;

typedef struct ContractInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *creator;
  NSString *admin;
  NSString *label;
  AbsoluteTxPosition *created;
  NSString *ibcPortId;
  NSString *ibc2PortId;
  GPBAny *extension;
  uint64_t codeId;
} ContractInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "codeId",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractInfo_FieldNumber_CodeId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ContractInfo__storage_, codeId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "creator",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractInfo_FieldNumber_Creator,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ContractInfo__storage_, creator),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "admin",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractInfo_FieldNumber_Admin,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ContractInfo__storage_, admin),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "label",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractInfo_FieldNumber_Label,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ContractInfo__storage_, label),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "created",
        .dataTypeSpecific.clazz = GPBObjCClass(AbsoluteTxPosition),
        .number = ContractInfo_FieldNumber_Created,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ContractInfo__storage_, created),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ibcPortId",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractInfo_FieldNumber_IbcPortId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ContractInfo__storage_, ibcPortId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ibc2PortId",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractInfo_FieldNumber_Ibc2PortId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ContractInfo__storage_, ibc2PortId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extension",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBAny),
        .number = ContractInfo_FieldNumber_Extension,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ContractInfo__storage_, extension),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ContractInfo)
                                   messageName:@"ContractInfo"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ContractInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ContractCodeHistoryEntry

@implementation ContractCodeHistoryEntry

@dynamic operation;
@dynamic codeId;
@dynamic hasUpdated, updated;
@dynamic msg;

typedef struct ContractCodeHistoryEntry__storage_ {
  uint32_t _has_storage_[1];
  ContractCodeHistoryOperationType operation;
  AbsoluteTxPosition *updated;
  NSData *msg;
  uint64_t codeId;
} ContractCodeHistoryEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "operation",
        .dataTypeSpecific.enumDescFunc = ContractCodeHistoryOperationType_EnumDescriptor,
        .number = ContractCodeHistoryEntry_FieldNumber_Operation,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ContractCodeHistoryEntry__storage_, operation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "codeId",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCodeHistoryEntry_FieldNumber_CodeId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ContractCodeHistoryEntry__storage_, codeId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "updated",
        .dataTypeSpecific.clazz = GPBObjCClass(AbsoluteTxPosition),
        .number = ContractCodeHistoryEntry_FieldNumber_Updated,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ContractCodeHistoryEntry__storage_, updated),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = Nil,
        .number = ContractCodeHistoryEntry_FieldNumber_Msg,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ContractCodeHistoryEntry__storage_, msg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ContractCodeHistoryEntry)
                                   messageName:@"ContractCodeHistoryEntry"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ContractCodeHistoryEntry__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ContractCodeHistoryEntry_Operation_RawValue(ContractCodeHistoryEntry *message) {
  GPBDescriptor *descriptor = [ContractCodeHistoryEntry descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ContractCodeHistoryEntry_FieldNumber_Operation];
  return GPBGetMessageRawEnumField(message, field);
}

void SetContractCodeHistoryEntry_Operation_RawValue(ContractCodeHistoryEntry *message, int32_t value) {
  GPBDescriptor *descriptor = [ContractCodeHistoryEntry descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ContractCodeHistoryEntry_FieldNumber_Operation];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - AbsoluteTxPosition

@implementation AbsoluteTxPosition

@dynamic blockHeight;
@dynamic txIndex;

typedef struct AbsoluteTxPosition__storage_ {
  uint32_t _has_storage_[1];
  uint64_t blockHeight;
  uint64_t txIndex;
} AbsoluteTxPosition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = AbsoluteTxPosition_FieldNumber_BlockHeight,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AbsoluteTxPosition__storage_, blockHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "txIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = AbsoluteTxPosition_FieldNumber_TxIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AbsoluteTxPosition__storage_, txIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(AbsoluteTxPosition)
                                   messageName:@"AbsoluteTxPosition"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AbsoluteTxPosition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Model

@implementation Model

@dynamic key;
@dynamic value;

typedef struct Model__storage_ {
  uint32_t _has_storage_[1];
  NSData *key;
  NSData *value;
} Model__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = Model_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Model__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = Model_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Model__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Model)
                                   messageName:@"Model"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Model__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
