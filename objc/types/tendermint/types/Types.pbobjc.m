// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// clang-format off
// source: tendermint/types/types.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import <stdatomic.h>

#import "tendermint/types/Types.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(BlockID);
GPBObjCClassDeclaration(BlockMeta);
GPBObjCClassDeclaration(Commit);
GPBObjCClassDeclaration(CommitSig);
GPBObjCClassDeclaration(Consensus);
GPBObjCClassDeclaration(Data);
GPBObjCClassDeclaration(ExtendedCommit);
GPBObjCClassDeclaration(ExtendedCommitSig);
GPBObjCClassDeclaration(GPBTimestamp);
GPBObjCClassDeclaration(Header);
GPBObjCClassDeclaration(LightBlock);
GPBObjCClassDeclaration(Part);
GPBObjCClassDeclaration(PartSetHeader);
GPBObjCClassDeclaration(Proof);
GPBObjCClassDeclaration(Proposal);
GPBObjCClassDeclaration(SignedHeader);
GPBObjCClassDeclaration(TxProof);
GPBObjCClassDeclaration(ValidatorSet);
GPBObjCClassDeclaration(Vote);

#pragma mark - TypesRoot

@implementation TypesRoot

// No extensions in the file and no imports or none of the imports (direct or
// indirect) defined extensions, so no need to generate +extensionRegistry.

@end

static GPBFileDescription TypesRoot_FileDescription = {
  .package = "tendermint.types",
  .prefix = NULL,
  .syntax = GPBFileSyntaxProto3
};

#pragma mark - Enum SignedMsgType

GPBEnumDescriptor *SignedMsgType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "SignedMsgTypeUnknown\000SignedMsgTypePrevot"
        "e\000SignedMsgTypePrecommit\000SignedMsgTypePr"
        "oposal\000";
    static const int32_t values[] = {
        SignedMsgType_SignedMsgTypeUnknown,
        SignedMsgType_SignedMsgTypePrevote,
        SignedMsgType_SignedMsgTypePrecommit,
        SignedMsgType_SignedMsgTypeProposal,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SignedMsgType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SignedMsgType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SignedMsgType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SignedMsgType_SignedMsgTypeUnknown:
    case SignedMsgType_SignedMsgTypePrevote:
    case SignedMsgType_SignedMsgTypePrecommit:
    case SignedMsgType_SignedMsgTypeProposal:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PartSetHeader

@implementation PartSetHeader

@dynamic total;
@dynamic hash_p;

typedef struct PartSetHeader__storage_ {
  uint32_t _has_storage_[1];
  uint32_t total;
  NSData *hash_p;
} PartSetHeader__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "total",
        .dataTypeSpecific.clazz = Nil,
        .number = PartSetHeader_FieldNumber_Total,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PartSetHeader__storage_, total),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = PartSetHeader_FieldNumber_Hash_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PartSetHeader__storage_, hash_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(PartSetHeader)
                                   messageName:@"PartSetHeader"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PartSetHeader__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Part

@implementation Part

@dynamic index;
@dynamic bytes;
@dynamic hasProof, proof;

typedef struct Part__storage_ {
  uint32_t _has_storage_[1];
  uint32_t index;
  NSData *bytes;
  Proof *proof;
} Part__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = Part_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Part__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bytes",
        .dataTypeSpecific.clazz = Nil,
        .number = Part_FieldNumber_Bytes,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Part__storage_, bytes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = Part_FieldNumber_Proof,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Part__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Part)
                                   messageName:@"Part"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Part__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockID

@implementation BlockID

@dynamic hash_p;
@dynamic hasPartSetHeader, partSetHeader;

typedef struct BlockID__storage_ {
  uint32_t _has_storage_[1];
  NSData *hash_p;
  PartSetHeader *partSetHeader;
} BlockID__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockID_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockID__storage_, hash_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "partSetHeader",
        .dataTypeSpecific.clazz = GPBObjCClass(PartSetHeader),
        .number = BlockID_FieldNumber_PartSetHeader,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockID__storage_, partSetHeader),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BlockID)
                                   messageName:@"BlockID"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockID__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Header

@implementation Header

@dynamic hasVersion, version;
@dynamic chainId;
@dynamic height;
@dynamic hasTime, time;
@dynamic hasLastBlockId, lastBlockId;
@dynamic lastCommitHash;
@dynamic dataHash;
@dynamic validatorsHash;
@dynamic nextValidatorsHash;
@dynamic consensusHash;
@dynamic appHash;
@dynamic lastResultsHash;
@dynamic evidenceHash;
@dynamic proposerAddress;

typedef struct Header__storage_ {
  uint32_t _has_storage_[1];
  Consensus *version;
  NSString *chainId;
  GPBTimestamp *time;
  BlockID *lastBlockId;
  NSData *lastCommitHash;
  NSData *dataHash;
  NSData *validatorsHash;
  NSData *nextValidatorsHash;
  NSData *consensusHash;
  NSData *appHash;
  NSData *lastResultsHash;
  NSData *evidenceHash;
  NSData *proposerAddress;
  int64_t height;
} Header__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.clazz = GPBObjCClass(Consensus),
        .number = Header_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Header__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chainId",
        .dataTypeSpecific.clazz = Nil,
        .number = Header_FieldNumber_ChainId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Header__storage_, chainId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = Header_FieldNumber_Height,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Header__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "time",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = Header_FieldNumber_Time,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Header__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastBlockId",
        .dataTypeSpecific.clazz = GPBObjCClass(BlockID),
        .number = Header_FieldNumber_LastBlockId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Header__storage_, lastBlockId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastCommitHash",
        .dataTypeSpecific.clazz = Nil,
        .number = Header_FieldNumber_LastCommitHash,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Header__storage_, lastCommitHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "dataHash",
        .dataTypeSpecific.clazz = Nil,
        .number = Header_FieldNumber_DataHash,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Header__storage_, dataHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "validatorsHash",
        .dataTypeSpecific.clazz = Nil,
        .number = Header_FieldNumber_ValidatorsHash,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Header__storage_, validatorsHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nextValidatorsHash",
        .dataTypeSpecific.clazz = Nil,
        .number = Header_FieldNumber_NextValidatorsHash,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Header__storage_, nextValidatorsHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "consensusHash",
        .dataTypeSpecific.clazz = Nil,
        .number = Header_FieldNumber_ConsensusHash,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Header__storage_, consensusHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "appHash",
        .dataTypeSpecific.clazz = Nil,
        .number = Header_FieldNumber_AppHash,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Header__storage_, appHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "lastResultsHash",
        .dataTypeSpecific.clazz = Nil,
        .number = Header_FieldNumber_LastResultsHash,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Header__storage_, lastResultsHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "evidenceHash",
        .dataTypeSpecific.clazz = Nil,
        .number = Header_FieldNumber_EvidenceHash,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Header__storage_, evidenceHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "proposerAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = Header_FieldNumber_ProposerAddress,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(Header__storage_, proposerAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Header)
                                   messageName:@"Header"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Header__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Data

@implementation Data

@dynamic txsArray, txsArray_Count;

typedef struct Data__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *txsArray;
} Data__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Data_FieldNumber_TxsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Data__storage_, txsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Data)
                                   messageName:@"Data"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Data__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Vote

@implementation Vote

@dynamic type;
@dynamic height;
@dynamic round;
@dynamic hasBlockId, blockId;
@dynamic hasTimestamp, timestamp;
@dynamic validatorAddress;
@dynamic validatorIndex;
@dynamic signature;
@dynamic extension;
@dynamic extensionSignature;

typedef struct Vote__storage_ {
  uint32_t _has_storage_[1];
  SignedMsgType type;
  int32_t round;
  int32_t validatorIndex;
  BlockID *blockId;
  GPBTimestamp *timestamp;
  NSData *validatorAddress;
  NSData *signature;
  NSData *extension;
  NSData *extensionSignature;
  int64_t height;
} Vote__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = SignedMsgType_EnumDescriptor,
        .number = Vote_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Vote__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = Vote_FieldNumber_Height,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Vote__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "round",
        .dataTypeSpecific.clazz = Nil,
        .number = Vote_FieldNumber_Round,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Vote__storage_, round),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "blockId",
        .dataTypeSpecific.clazz = GPBObjCClass(BlockID),
        .number = Vote_FieldNumber_BlockId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Vote__storage_, blockId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = Vote_FieldNumber_Timestamp,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Vote__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "validatorAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = Vote_FieldNumber_ValidatorAddress,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Vote__storage_, validatorAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "validatorIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = Vote_FieldNumber_ValidatorIndex,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Vote__storage_, validatorIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "signature",
        .dataTypeSpecific.clazz = Nil,
        .number = Vote_FieldNumber_Signature,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Vote__storage_, signature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "extension",
        .dataTypeSpecific.clazz = Nil,
        .number = Vote_FieldNumber_Extension,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Vote__storage_, extension),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "extensionSignature",
        .dataTypeSpecific.clazz = Nil,
        .number = Vote_FieldNumber_ExtensionSignature,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Vote__storage_, extensionSignature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Vote)
                                   messageName:@"Vote"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Vote__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Vote_Type_RawValue(Vote *message) {
  GPBDescriptor *descriptor = [Vote descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Vote_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetVote_Type_RawValue(Vote *message, int32_t value) {
  GPBDescriptor *descriptor = [Vote descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Vote_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Commit

@implementation Commit

@dynamic height;
@dynamic round;
@dynamic hasBlockId, blockId;
@dynamic signaturesArray, signaturesArray_Count;

typedef struct Commit__storage_ {
  uint32_t _has_storage_[1];
  int32_t round;
  BlockID *blockId;
  NSMutableArray *signaturesArray;
  int64_t height;
} Commit__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = Commit_FieldNumber_Height,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Commit__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "round",
        .dataTypeSpecific.clazz = Nil,
        .number = Commit_FieldNumber_Round,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Commit__storage_, round),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "blockId",
        .dataTypeSpecific.clazz = GPBObjCClass(BlockID),
        .number = Commit_FieldNumber_BlockId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Commit__storage_, blockId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signaturesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(CommitSig),
        .number = Commit_FieldNumber_SignaturesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Commit__storage_, signaturesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Commit)
                                   messageName:@"Commit"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Commit__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CommitSig

@implementation CommitSig

@dynamic blockIdFlag;
@dynamic validatorAddress;
@dynamic hasTimestamp, timestamp;
@dynamic signature;

typedef struct CommitSig__storage_ {
  uint32_t _has_storage_[1];
  BlockIDFlag blockIdFlag;
  NSData *validatorAddress;
  GPBTimestamp *timestamp;
  NSData *signature;
} CommitSig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockIdFlag",
        .dataTypeSpecific.enumDescFunc = BlockIDFlag_EnumDescriptor,
        .number = CommitSig_FieldNumber_BlockIdFlag,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CommitSig__storage_, blockIdFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "validatorAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = CommitSig_FieldNumber_ValidatorAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CommitSig__storage_, validatorAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = CommitSig_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CommitSig__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signature",
        .dataTypeSpecific.clazz = Nil,
        .number = CommitSig_FieldNumber_Signature,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CommitSig__storage_, signature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CommitSig)
                                   messageName:@"CommitSig"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CommitSig__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CommitSig_BlockIdFlag_RawValue(CommitSig *message) {
  GPBDescriptor *descriptor = [CommitSig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CommitSig_FieldNumber_BlockIdFlag];
  return GPBGetMessageRawEnumField(message, field);
}

void SetCommitSig_BlockIdFlag_RawValue(CommitSig *message, int32_t value) {
  GPBDescriptor *descriptor = [CommitSig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CommitSig_FieldNumber_BlockIdFlag];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ExtendedCommit

@implementation ExtendedCommit

@dynamic height;
@dynamic round;
@dynamic hasBlockId, blockId;
@dynamic extendedSignaturesArray, extendedSignaturesArray_Count;

typedef struct ExtendedCommit__storage_ {
  uint32_t _has_storage_[1];
  int32_t round;
  BlockID *blockId;
  NSMutableArray *extendedSignaturesArray;
  int64_t height;
} ExtendedCommit__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = ExtendedCommit_FieldNumber_Height,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExtendedCommit__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "round",
        .dataTypeSpecific.clazz = Nil,
        .number = ExtendedCommit_FieldNumber_Round,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ExtendedCommit__storage_, round),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "blockId",
        .dataTypeSpecific.clazz = GPBObjCClass(BlockID),
        .number = ExtendedCommit_FieldNumber_BlockId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ExtendedCommit__storage_, blockId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extendedSignaturesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ExtendedCommitSig),
        .number = ExtendedCommit_FieldNumber_ExtendedSignaturesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ExtendedCommit__storage_, extendedSignaturesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ExtendedCommit)
                                   messageName:@"ExtendedCommit"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExtendedCommit__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExtendedCommitSig

@implementation ExtendedCommitSig

@dynamic blockIdFlag;
@dynamic validatorAddress;
@dynamic hasTimestamp, timestamp;
@dynamic signature;
@dynamic extension;
@dynamic extensionSignature;

typedef struct ExtendedCommitSig__storage_ {
  uint32_t _has_storage_[1];
  BlockIDFlag blockIdFlag;
  NSData *validatorAddress;
  GPBTimestamp *timestamp;
  NSData *signature;
  NSData *extension;
  NSData *extensionSignature;
} ExtendedCommitSig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockIdFlag",
        .dataTypeSpecific.enumDescFunc = BlockIDFlag_EnumDescriptor,
        .number = ExtendedCommitSig_FieldNumber_BlockIdFlag,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExtendedCommitSig__storage_, blockIdFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "validatorAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = ExtendedCommitSig_FieldNumber_ValidatorAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ExtendedCommitSig__storage_, validatorAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = ExtendedCommitSig_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ExtendedCommitSig__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signature",
        .dataTypeSpecific.clazz = Nil,
        .number = ExtendedCommitSig_FieldNumber_Signature,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ExtendedCommitSig__storage_, signature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "extension",
        .dataTypeSpecific.clazz = Nil,
        .number = ExtendedCommitSig_FieldNumber_Extension,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ExtendedCommitSig__storage_, extension),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "extensionSignature",
        .dataTypeSpecific.clazz = Nil,
        .number = ExtendedCommitSig_FieldNumber_ExtensionSignature,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ExtendedCommitSig__storage_, extensionSignature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ExtendedCommitSig)
                                   messageName:@"ExtendedCommitSig"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExtendedCommitSig__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ExtendedCommitSig_BlockIdFlag_RawValue(ExtendedCommitSig *message) {
  GPBDescriptor *descriptor = [ExtendedCommitSig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ExtendedCommitSig_FieldNumber_BlockIdFlag];
  return GPBGetMessageRawEnumField(message, field);
}

void SetExtendedCommitSig_BlockIdFlag_RawValue(ExtendedCommitSig *message, int32_t value) {
  GPBDescriptor *descriptor = [ExtendedCommitSig descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ExtendedCommitSig_FieldNumber_BlockIdFlag];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Proposal

@implementation Proposal

@dynamic type;
@dynamic height;
@dynamic round;
@dynamic polRound;
@dynamic hasBlockId, blockId;
@dynamic hasTimestamp, timestamp;
@dynamic signature;

typedef struct Proposal__storage_ {
  uint32_t _has_storage_[1];
  SignedMsgType type;
  int32_t round;
  int32_t polRound;
  BlockID *blockId;
  GPBTimestamp *timestamp;
  NSData *signature;
  int64_t height;
} Proposal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = SignedMsgType_EnumDescriptor,
        .number = Proposal_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Proposal__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = Proposal_FieldNumber_Height,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Proposal__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "round",
        .dataTypeSpecific.clazz = Nil,
        .number = Proposal_FieldNumber_Round,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Proposal__storage_, round),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "polRound",
        .dataTypeSpecific.clazz = Nil,
        .number = Proposal_FieldNumber_PolRound,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Proposal__storage_, polRound),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "blockId",
        .dataTypeSpecific.clazz = GPBObjCClass(BlockID),
        .number = Proposal_FieldNumber_BlockId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Proposal__storage_, blockId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = Proposal_FieldNumber_Timestamp,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Proposal__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signature",
        .dataTypeSpecific.clazz = Nil,
        .number = Proposal_FieldNumber_Signature,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Proposal__storage_, signature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Proposal)
                                   messageName:@"Proposal"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Proposal__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Proposal_Type_RawValue(Proposal *message) {
  GPBDescriptor *descriptor = [Proposal descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Proposal_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetProposal_Type_RawValue(Proposal *message, int32_t value) {
  GPBDescriptor *descriptor = [Proposal descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Proposal_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - SignedHeader

@implementation SignedHeader

@dynamic hasHeader, header;
@dynamic hasCommit, commit;

typedef struct SignedHeader__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  Commit *commit;
} SignedHeader__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.clazz = GPBObjCClass(Header),
        .number = SignedHeader_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignedHeader__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "commit",
        .dataTypeSpecific.clazz = GPBObjCClass(Commit),
        .number = SignedHeader_FieldNumber_Commit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SignedHeader__storage_, commit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SignedHeader)
                                   messageName:@"SignedHeader"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignedHeader__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LightBlock

@implementation LightBlock

@dynamic hasSignedHeader, signedHeader;
@dynamic hasValidatorSet, validatorSet;

typedef struct LightBlock__storage_ {
  uint32_t _has_storage_[1];
  SignedHeader *signedHeader;
  ValidatorSet *validatorSet;
} LightBlock__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "signedHeader",
        .dataTypeSpecific.clazz = GPBObjCClass(SignedHeader),
        .number = LightBlock_FieldNumber_SignedHeader,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LightBlock__storage_, signedHeader),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "validatorSet",
        .dataTypeSpecific.clazz = GPBObjCClass(ValidatorSet),
        .number = LightBlock_FieldNumber_ValidatorSet,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LightBlock__storage_, validatorSet),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(LightBlock)
                                   messageName:@"LightBlock"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LightBlock__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockMeta

@implementation BlockMeta

@dynamic hasBlockId, blockId;
@dynamic blockSize;
@dynamic hasHeader, header;
@dynamic numTxs;

typedef struct BlockMeta__storage_ {
  uint32_t _has_storage_[1];
  BlockID *blockId;
  Header *header;
  int64_t blockSize;
  int64_t numTxs;
} BlockMeta__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockId",
        .dataTypeSpecific.clazz = GPBObjCClass(BlockID),
        .number = BlockMeta_FieldNumber_BlockId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockMeta__storage_, blockId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockSize",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockMeta_FieldNumber_BlockSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockMeta__storage_, blockSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "header",
        .dataTypeSpecific.clazz = GPBObjCClass(Header),
        .number = BlockMeta_FieldNumber_Header,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BlockMeta__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "numTxs",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockMeta_FieldNumber_NumTxs,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BlockMeta__storage_, numTxs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BlockMeta)
                                   messageName:@"BlockMeta"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockMeta__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TxProof

@implementation TxProof

@dynamic rootHash;
@dynamic data_p;
@dynamic hasProof, proof;

typedef struct TxProof__storage_ {
  uint32_t _has_storage_[1];
  NSData *rootHash;
  NSData *data_p;
  Proof *proof;
} TxProof__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rootHash",
        .dataTypeSpecific.clazz = Nil,
        .number = TxProof_FieldNumber_RootHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TxProof__storage_, rootHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = TxProof_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TxProof__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "proof",
        .dataTypeSpecific.clazz = GPBObjCClass(Proof),
        .number = TxProof_FieldNumber_Proof,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TxProof__storage_, proof),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TxProof)
                                   messageName:@"TxProof"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxProof__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
