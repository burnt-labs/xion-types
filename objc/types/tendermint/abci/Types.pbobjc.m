// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// clang-format off
// source: tendermint/abci/types.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import <stdatomic.h>

#import "tendermint/abci/Types.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(CommitInfo);
GPBObjCClassDeclaration(ConsensusParams);
GPBObjCClassDeclaration(Event);
GPBObjCClassDeclaration(EventAttribute);
GPBObjCClassDeclaration(ExecTxResult);
GPBObjCClassDeclaration(ExtendedCommitInfo);
GPBObjCClassDeclaration(ExtendedVoteInfo);
GPBObjCClassDeclaration(GPBTimestamp);
GPBObjCClassDeclaration(Misbehavior);
GPBObjCClassDeclaration(ProofOps);
GPBObjCClassDeclaration(PublicKey);
GPBObjCClassDeclaration(Request);
GPBObjCClassDeclaration(RequestApplySnapshotChunk);
GPBObjCClassDeclaration(RequestCheckTx);
GPBObjCClassDeclaration(RequestCommit);
GPBObjCClassDeclaration(RequestEcho);
GPBObjCClassDeclaration(RequestExtendVote);
GPBObjCClassDeclaration(RequestFinalizeBlock);
GPBObjCClassDeclaration(RequestFlush);
GPBObjCClassDeclaration(RequestInfo);
GPBObjCClassDeclaration(RequestInitChain);
GPBObjCClassDeclaration(RequestListSnapshots);
GPBObjCClassDeclaration(RequestLoadSnapshotChunk);
GPBObjCClassDeclaration(RequestOfferSnapshot);
GPBObjCClassDeclaration(RequestPrepareProposal);
GPBObjCClassDeclaration(RequestProcessProposal);
GPBObjCClassDeclaration(RequestQuery);
GPBObjCClassDeclaration(RequestVerifyVoteExtension);
GPBObjCClassDeclaration(Response);
GPBObjCClassDeclaration(ResponseApplySnapshotChunk);
GPBObjCClassDeclaration(ResponseCheckTx);
GPBObjCClassDeclaration(ResponseCommit);
GPBObjCClassDeclaration(ResponseEcho);
GPBObjCClassDeclaration(ResponseException);
GPBObjCClassDeclaration(ResponseExtendVote);
GPBObjCClassDeclaration(ResponseFinalizeBlock);
GPBObjCClassDeclaration(ResponseFlush);
GPBObjCClassDeclaration(ResponseInfo);
GPBObjCClassDeclaration(ResponseInitChain);
GPBObjCClassDeclaration(ResponseListSnapshots);
GPBObjCClassDeclaration(ResponseLoadSnapshotChunk);
GPBObjCClassDeclaration(ResponseOfferSnapshot);
GPBObjCClassDeclaration(ResponsePrepareProposal);
GPBObjCClassDeclaration(ResponseProcessProposal);
GPBObjCClassDeclaration(ResponseQuery);
GPBObjCClassDeclaration(ResponseVerifyVoteExtension);
GPBObjCClassDeclaration(Snapshot);
GPBObjCClassDeclaration(TxResult);
GPBObjCClassDeclaration(Validator);
GPBObjCClassDeclaration(ValidatorUpdate);
GPBObjCClassDeclaration(VoteInfo);

#pragma mark - TypesRoot

@implementation TypesRoot

// No extensions in the file and no imports or none of the imports (direct or
// indirect) defined extensions, so no need to generate +extensionRegistry.

@end

static GPBFileDescription TypesRoot_FileDescription = {
  .package = "tendermint.abci",
  .prefix = NULL,
  .syntax = GPBFileSyntaxProto3
};

#pragma mark - Enum CheckTxType

GPBEnumDescriptor *CheckTxType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "New\000Recheck\000";
    static const int32_t values[] = {
        CheckTxType_New,
        CheckTxType_Recheck,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CheckTxType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CheckTxType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CheckTxType_IsValidValue(int32_t value__) {
  switch (value__) {
    case CheckTxType_New:
    case CheckTxType_Recheck:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MisbehaviorType

GPBEnumDescriptor *MisbehaviorType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "Unknown\000DuplicateVote\000LightClientAttack\000";
    static const int32_t values[] = {
        MisbehaviorType_Unknown,
        MisbehaviorType_DuplicateVote,
        MisbehaviorType_LightClientAttack,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MisbehaviorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MisbehaviorType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MisbehaviorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case MisbehaviorType_Unknown:
    case MisbehaviorType_DuplicateVote:
    case MisbehaviorType_LightClientAttack:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ResponseOfferSnapshot_Result

GPBEnumDescriptor *ResponseOfferSnapshot_Result_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "Unknown\000Accept\000Abort\000Reject\000RejectFormat"
        "\000RejectSender\000";
    static const int32_t values[] = {
        ResponseOfferSnapshot_Result_Unknown,
        ResponseOfferSnapshot_Result_Accept,
        ResponseOfferSnapshot_Result_Abort,
        ResponseOfferSnapshot_Result_Reject,
        ResponseOfferSnapshot_Result_RejectFormat,
        ResponseOfferSnapshot_Result_RejectSender,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ResponseOfferSnapshot_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ResponseOfferSnapshot_Result_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ResponseOfferSnapshot_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case ResponseOfferSnapshot_Result_Unknown:
    case ResponseOfferSnapshot_Result_Accept:
    case ResponseOfferSnapshot_Result_Abort:
    case ResponseOfferSnapshot_Result_Reject:
    case ResponseOfferSnapshot_Result_RejectFormat:
    case ResponseOfferSnapshot_Result_RejectSender:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ResponseApplySnapshotChunk_Result

GPBEnumDescriptor *ResponseApplySnapshotChunk_Result_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "Unknown\000Accept\000Abort\000Retry\000RetrySnapshot"
        "\000RejectSnapshot\000";
    static const int32_t values[] = {
        ResponseApplySnapshotChunk_Result_Unknown,
        ResponseApplySnapshotChunk_Result_Accept,
        ResponseApplySnapshotChunk_Result_Abort,
        ResponseApplySnapshotChunk_Result_Retry,
        ResponseApplySnapshotChunk_Result_RetrySnapshot,
        ResponseApplySnapshotChunk_Result_RejectSnapshot,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ResponseApplySnapshotChunk_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ResponseApplySnapshotChunk_Result_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ResponseApplySnapshotChunk_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case ResponseApplySnapshotChunk_Result_Unknown:
    case ResponseApplySnapshotChunk_Result_Accept:
    case ResponseApplySnapshotChunk_Result_Abort:
    case ResponseApplySnapshotChunk_Result_Retry:
    case ResponseApplySnapshotChunk_Result_RetrySnapshot:
    case ResponseApplySnapshotChunk_Result_RejectSnapshot:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ResponseProcessProposal_ProposalStatus

GPBEnumDescriptor *ResponseProcessProposal_ProposalStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "Unknown\000Accept\000Reject\000";
    static const int32_t values[] = {
        ResponseProcessProposal_ProposalStatus_Unknown,
        ResponseProcessProposal_ProposalStatus_Accept,
        ResponseProcessProposal_ProposalStatus_Reject,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ResponseProcessProposal_ProposalStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ResponseProcessProposal_ProposalStatus_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ResponseProcessProposal_ProposalStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case ResponseProcessProposal_ProposalStatus_Unknown:
    case ResponseProcessProposal_ProposalStatus_Accept:
    case ResponseProcessProposal_ProposalStatus_Reject:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ResponseVerifyVoteExtension_VerifyStatus

GPBEnumDescriptor *ResponseVerifyVoteExtension_VerifyStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "Unknown\000Accept\000Reject\000";
    static const int32_t values[] = {
        ResponseVerifyVoteExtension_VerifyStatus_Unknown,
        ResponseVerifyVoteExtension_VerifyStatus_Accept,
        ResponseVerifyVoteExtension_VerifyStatus_Reject,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ResponseVerifyVoteExtension_VerifyStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ResponseVerifyVoteExtension_VerifyStatus_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ResponseVerifyVoteExtension_VerifyStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case ResponseVerifyVoteExtension_VerifyStatus_Unknown:
    case ResponseVerifyVoteExtension_VerifyStatus_Accept:
    case ResponseVerifyVoteExtension_VerifyStatus_Reject:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Request

@implementation Request

@dynamic valueOneOfCase;
@dynamic echo;
@dynamic flush;
@dynamic info;
@dynamic initChain;
@dynamic query;
@dynamic checkTx;
@dynamic commit;
@dynamic listSnapshots;
@dynamic offerSnapshot;
@dynamic loadSnapshotChunk;
@dynamic applySnapshotChunk;
@dynamic prepareProposal;
@dynamic processProposal;
@dynamic extendVote;
@dynamic verifyVoteExtension;
@dynamic finalizeBlock;

typedef struct Request__storage_ {
  uint32_t _has_storage_[2];
  RequestEcho *echo;
  RequestFlush *flush;
  RequestInfo *info;
  RequestInitChain *initChain;
  RequestQuery *query;
  RequestCheckTx *checkTx;
  RequestCommit *commit;
  RequestListSnapshots *listSnapshots;
  RequestOfferSnapshot *offerSnapshot;
  RequestLoadSnapshotChunk *loadSnapshotChunk;
  RequestApplySnapshotChunk *applySnapshotChunk;
  RequestPrepareProposal *prepareProposal;
  RequestProcessProposal *processProposal;
  RequestExtendVote *extendVote;
  RequestVerifyVoteExtension *verifyVoteExtension;
  RequestFinalizeBlock *finalizeBlock;
} Request__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "echo",
        .dataTypeSpecific.clazz = GPBObjCClass(RequestEcho),
        .number = Request_FieldNumber_Echo,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Request__storage_, echo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "flush",
        .dataTypeSpecific.clazz = GPBObjCClass(RequestFlush),
        .number = Request_FieldNumber_Flush,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Request__storage_, flush),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "info",
        .dataTypeSpecific.clazz = GPBObjCClass(RequestInfo),
        .number = Request_FieldNumber_Info,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Request__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "initChain",
        .dataTypeSpecific.clazz = GPBObjCClass(RequestInitChain),
        .number = Request_FieldNumber_InitChain,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Request__storage_, initChain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "query",
        .dataTypeSpecific.clazz = GPBObjCClass(RequestQuery),
        .number = Request_FieldNumber_Query,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Request__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "checkTx",
        .dataTypeSpecific.clazz = GPBObjCClass(RequestCheckTx),
        .number = Request_FieldNumber_CheckTx,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Request__storage_, checkTx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "commit",
        .dataTypeSpecific.clazz = GPBObjCClass(RequestCommit),
        .number = Request_FieldNumber_Commit,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Request__storage_, commit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "listSnapshots",
        .dataTypeSpecific.clazz = GPBObjCClass(RequestListSnapshots),
        .number = Request_FieldNumber_ListSnapshots,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Request__storage_, listSnapshots),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "offerSnapshot",
        .dataTypeSpecific.clazz = GPBObjCClass(RequestOfferSnapshot),
        .number = Request_FieldNumber_OfferSnapshot,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Request__storage_, offerSnapshot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "loadSnapshotChunk",
        .dataTypeSpecific.clazz = GPBObjCClass(RequestLoadSnapshotChunk),
        .number = Request_FieldNumber_LoadSnapshotChunk,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Request__storage_, loadSnapshotChunk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "applySnapshotChunk",
        .dataTypeSpecific.clazz = GPBObjCClass(RequestApplySnapshotChunk),
        .number = Request_FieldNumber_ApplySnapshotChunk,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Request__storage_, applySnapshotChunk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "prepareProposal",
        .dataTypeSpecific.clazz = GPBObjCClass(RequestPrepareProposal),
        .number = Request_FieldNumber_PrepareProposal,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Request__storage_, prepareProposal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "processProposal",
        .dataTypeSpecific.clazz = GPBObjCClass(RequestProcessProposal),
        .number = Request_FieldNumber_ProcessProposal,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Request__storage_, processProposal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extendVote",
        .dataTypeSpecific.clazz = GPBObjCClass(RequestExtendVote),
        .number = Request_FieldNumber_ExtendVote,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Request__storage_, extendVote),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "verifyVoteExtension",
        .dataTypeSpecific.clazz = GPBObjCClass(RequestVerifyVoteExtension),
        .number = Request_FieldNumber_VerifyVoteExtension,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Request__storage_, verifyVoteExtension),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "finalizeBlock",
        .dataTypeSpecific.clazz = GPBObjCClass(RequestFinalizeBlock),
        .number = Request_FieldNumber_FinalizeBlock,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Request__storage_, finalizeBlock),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Request)
                                   messageName:@"Request"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Request__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    static const char *oneofs[] = {
      "value",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Request_ClearValueOneOfCase(Request *message) {
  GPBDescriptor *descriptor = [Request descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - RequestEcho

@implementation RequestEcho

@dynamic message;

typedef struct RequestEcho__storage_ {
  uint32_t _has_storage_[1];
  NSString *message;
} RequestEcho__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestEcho_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestEcho__storage_, message),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RequestEcho)
                                   messageName:@"RequestEcho"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestEcho__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestFlush

@implementation RequestFlush


typedef struct RequestFlush__storage_ {
  uint32_t _has_storage_[1];
} RequestFlush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RequestFlush)
                                   messageName:@"RequestFlush"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RequestFlush__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestInfo

@implementation RequestInfo

@dynamic version;
@dynamic blockVersion;
@dynamic p2PVersion;
@dynamic abciVersion;

typedef struct RequestInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *version;
  NSString *abciVersion;
  uint64_t blockVersion;
  uint64_t p2PVersion;
} RequestInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestInfo_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestInfo__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blockVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestInfo_FieldNumber_BlockVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestInfo__storage_, blockVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "p2PVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestInfo_FieldNumber_P2PVersion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestInfo__storage_, p2PVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "abciVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestInfo_FieldNumber_AbciVersion,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RequestInfo__storage_, abciVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RequestInfo)
                                   messageName:@"RequestInfo"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\003\002!\247\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestInitChain

@implementation RequestInitChain

@dynamic hasTime, time;
@dynamic chainId;
@dynamic hasConsensusParams, consensusParams;
@dynamic validatorsArray, validatorsArray_Count;
@dynamic appStateBytes;
@dynamic initialHeight;

typedef struct RequestInitChain__storage_ {
  uint32_t _has_storage_[1];
  GPBTimestamp *time;
  NSString *chainId;
  ConsensusParams *consensusParams;
  NSMutableArray *validatorsArray;
  NSData *appStateBytes;
  int64_t initialHeight;
} RequestInitChain__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "time",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = RequestInitChain_FieldNumber_Time,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestInitChain__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chainId",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestInitChain_FieldNumber_ChainId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestInitChain__storage_, chainId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "consensusParams",
        .dataTypeSpecific.clazz = GPBObjCClass(ConsensusParams),
        .number = RequestInitChain_FieldNumber_ConsensusParams,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestInitChain__storage_, consensusParams),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "validatorsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ValidatorUpdate),
        .number = RequestInitChain_FieldNumber_ValidatorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestInitChain__storage_, validatorsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "appStateBytes",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestInitChain_FieldNumber_AppStateBytes,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RequestInitChain__storage_, appStateBytes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "initialHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestInitChain_FieldNumber_InitialHeight,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RequestInitChain__storage_, initialHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RequestInitChain)
                                   messageName:@"RequestInitChain"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestInitChain__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestQuery

@implementation RequestQuery

@dynamic data_p;
@dynamic path;
@dynamic height;
@dynamic prove;

typedef struct RequestQuery__storage_ {
  uint32_t _has_storage_[1];
  NSData *data_p;
  NSString *path;
  int64_t height;
} RequestQuery__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestQuery_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestQuery__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "path",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestQuery_FieldNumber_Path,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestQuery__storage_, path),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestQuery_FieldNumber_Height,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestQuery__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "prove",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestQuery_FieldNumber_Prove,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RequestQuery)
                                   messageName:@"RequestQuery"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestQuery__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestCheckTx

@implementation RequestCheckTx

@dynamic tx;
@dynamic type;

typedef struct RequestCheckTx__storage_ {
  uint32_t _has_storage_[1];
  CheckTxType type;
  NSData *tx;
} RequestCheckTx__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tx",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestCheckTx_FieldNumber_Tx,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestCheckTx__storage_, tx),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = CheckTxType_EnumDescriptor,
        .number = RequestCheckTx_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestCheckTx__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RequestCheckTx)
                                   messageName:@"RequestCheckTx"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestCheckTx__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RequestCheckTx_Type_RawValue(RequestCheckTx *message) {
  GPBDescriptor *descriptor = [RequestCheckTx descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RequestCheckTx_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetRequestCheckTx_Type_RawValue(RequestCheckTx *message, int32_t value) {
  GPBDescriptor *descriptor = [RequestCheckTx descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RequestCheckTx_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - RequestCommit

@implementation RequestCommit


typedef struct RequestCommit__storage_ {
  uint32_t _has_storage_[1];
} RequestCommit__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RequestCommit)
                                   messageName:@"RequestCommit"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RequestCommit__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestListSnapshots

@implementation RequestListSnapshots


typedef struct RequestListSnapshots__storage_ {
  uint32_t _has_storage_[1];
} RequestListSnapshots__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RequestListSnapshots)
                                   messageName:@"RequestListSnapshots"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RequestListSnapshots__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestOfferSnapshot

@implementation RequestOfferSnapshot

@dynamic hasSnapshot, snapshot;
@dynamic appHash;

typedef struct RequestOfferSnapshot__storage_ {
  uint32_t _has_storage_[1];
  Snapshot *snapshot;
  NSData *appHash;
} RequestOfferSnapshot__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "snapshot",
        .dataTypeSpecific.clazz = GPBObjCClass(Snapshot),
        .number = RequestOfferSnapshot_FieldNumber_Snapshot,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestOfferSnapshot__storage_, snapshot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "appHash",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestOfferSnapshot_FieldNumber_AppHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestOfferSnapshot__storage_, appHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RequestOfferSnapshot)
                                   messageName:@"RequestOfferSnapshot"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestOfferSnapshot__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestLoadSnapshotChunk

@implementation RequestLoadSnapshotChunk

@dynamic height;
@dynamic format;
@dynamic chunk;

typedef struct RequestLoadSnapshotChunk__storage_ {
  uint32_t _has_storage_[1];
  uint32_t format;
  uint32_t chunk;
  uint64_t height;
} RequestLoadSnapshotChunk__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadSnapshotChunk_FieldNumber_Height,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestLoadSnapshotChunk__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "format",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadSnapshotChunk_FieldNumber_Format,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestLoadSnapshotChunk__storage_, format),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "chunk",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadSnapshotChunk_FieldNumber_Chunk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestLoadSnapshotChunk__storage_, chunk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RequestLoadSnapshotChunk)
                                   messageName:@"RequestLoadSnapshotChunk"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestLoadSnapshotChunk__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestApplySnapshotChunk

@implementation RequestApplySnapshotChunk

@dynamic index;
@dynamic chunk;
@dynamic sender;

typedef struct RequestApplySnapshotChunk__storage_ {
  uint32_t _has_storage_[1];
  uint32_t index;
  NSData *chunk;
  NSString *sender;
} RequestApplySnapshotChunk__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestApplySnapshotChunk_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestApplySnapshotChunk__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "chunk",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestApplySnapshotChunk_FieldNumber_Chunk,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestApplySnapshotChunk__storage_, chunk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "sender",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestApplySnapshotChunk_FieldNumber_Sender,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestApplySnapshotChunk__storage_, sender),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RequestApplySnapshotChunk)
                                   messageName:@"RequestApplySnapshotChunk"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestApplySnapshotChunk__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestPrepareProposal

@implementation RequestPrepareProposal

@dynamic maxTxBytes;
@dynamic txsArray, txsArray_Count;
@dynamic hasLocalLastCommit, localLastCommit;
@dynamic misbehaviorArray, misbehaviorArray_Count;
@dynamic height;
@dynamic hasTime, time;
@dynamic nextValidatorsHash;
@dynamic proposerAddress;

typedef struct RequestPrepareProposal__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *txsArray;
  ExtendedCommitInfo *localLastCommit;
  NSMutableArray *misbehaviorArray;
  GPBTimestamp *time;
  NSData *nextValidatorsHash;
  NSData *proposerAddress;
  int64_t maxTxBytes;
  int64_t height;
} RequestPrepareProposal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "maxTxBytes",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestPrepareProposal_FieldNumber_MaxTxBytes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestPrepareProposal__storage_, maxTxBytes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "txsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestPrepareProposal_FieldNumber_TxsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestPrepareProposal__storage_, txsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "localLastCommit",
        .dataTypeSpecific.clazz = GPBObjCClass(ExtendedCommitInfo),
        .number = RequestPrepareProposal_FieldNumber_LocalLastCommit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestPrepareProposal__storage_, localLastCommit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "misbehaviorArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Misbehavior),
        .number = RequestPrepareProposal_FieldNumber_MisbehaviorArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestPrepareProposal__storage_, misbehaviorArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestPrepareProposal_FieldNumber_Height,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestPrepareProposal__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "time",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = RequestPrepareProposal_FieldNumber_Time,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RequestPrepareProposal__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextValidatorsHash",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestPrepareProposal_FieldNumber_NextValidatorsHash,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RequestPrepareProposal__storage_, nextValidatorsHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "proposerAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestPrepareProposal_FieldNumber_ProposerAddress,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RequestPrepareProposal__storage_, proposerAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RequestPrepareProposal)
                                   messageName:@"RequestPrepareProposal"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestPrepareProposal__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestProcessProposal

@implementation RequestProcessProposal

@dynamic txsArray, txsArray_Count;
@dynamic hasProposedLastCommit, proposedLastCommit;
@dynamic misbehaviorArray, misbehaviorArray_Count;
@dynamic hash_p;
@dynamic height;
@dynamic hasTime, time;
@dynamic nextValidatorsHash;
@dynamic proposerAddress;

typedef struct RequestProcessProposal__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *txsArray;
  CommitInfo *proposedLastCommit;
  NSMutableArray *misbehaviorArray;
  NSData *hash_p;
  GPBTimestamp *time;
  NSData *nextValidatorsHash;
  NSData *proposerAddress;
  int64_t height;
} RequestProcessProposal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestProcessProposal_FieldNumber_TxsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestProcessProposal__storage_, txsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "proposedLastCommit",
        .dataTypeSpecific.clazz = GPBObjCClass(CommitInfo),
        .number = RequestProcessProposal_FieldNumber_ProposedLastCommit,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestProcessProposal__storage_, proposedLastCommit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "misbehaviorArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Misbehavior),
        .number = RequestProcessProposal_FieldNumber_MisbehaviorArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestProcessProposal__storage_, misbehaviorArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestProcessProposal_FieldNumber_Hash_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestProcessProposal__storage_, hash_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestProcessProposal_FieldNumber_Height,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestProcessProposal__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "time",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = RequestProcessProposal_FieldNumber_Time,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RequestProcessProposal__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextValidatorsHash",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestProcessProposal_FieldNumber_NextValidatorsHash,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RequestProcessProposal__storage_, nextValidatorsHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "proposerAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestProcessProposal_FieldNumber_ProposerAddress,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RequestProcessProposal__storage_, proposerAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RequestProcessProposal)
                                   messageName:@"RequestProcessProposal"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestProcessProposal__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestExtendVote

@implementation RequestExtendVote

@dynamic hash_p;
@dynamic height;
@dynamic hasTime, time;
@dynamic txsArray, txsArray_Count;
@dynamic hasProposedLastCommit, proposedLastCommit;
@dynamic misbehaviorArray, misbehaviorArray_Count;
@dynamic nextValidatorsHash;
@dynamic proposerAddress;

typedef struct RequestExtendVote__storage_ {
  uint32_t _has_storage_[1];
  NSData *hash_p;
  GPBTimestamp *time;
  NSMutableArray *txsArray;
  CommitInfo *proposedLastCommit;
  NSMutableArray *misbehaviorArray;
  NSData *nextValidatorsHash;
  NSData *proposerAddress;
  int64_t height;
} RequestExtendVote__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestExtendVote_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestExtendVote__storage_, hash_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestExtendVote_FieldNumber_Height,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestExtendVote__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "time",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = RequestExtendVote_FieldNumber_Time,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestExtendVote__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "txsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestExtendVote_FieldNumber_TxsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestExtendVote__storage_, txsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "proposedLastCommit",
        .dataTypeSpecific.clazz = GPBObjCClass(CommitInfo),
        .number = RequestExtendVote_FieldNumber_ProposedLastCommit,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RequestExtendVote__storage_, proposedLastCommit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "misbehaviorArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Misbehavior),
        .number = RequestExtendVote_FieldNumber_MisbehaviorArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestExtendVote__storage_, misbehaviorArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextValidatorsHash",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestExtendVote_FieldNumber_NextValidatorsHash,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RequestExtendVote__storage_, nextValidatorsHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "proposerAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestExtendVote_FieldNumber_ProposerAddress,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RequestExtendVote__storage_, proposerAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RequestExtendVote)
                                   messageName:@"RequestExtendVote"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestExtendVote__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestVerifyVoteExtension

@implementation RequestVerifyVoteExtension

@dynamic hash_p;
@dynamic validatorAddress;
@dynamic height;
@dynamic voteExtension;

typedef struct RequestVerifyVoteExtension__storage_ {
  uint32_t _has_storage_[1];
  NSData *hash_p;
  NSData *validatorAddress;
  NSData *voteExtension;
  int64_t height;
} RequestVerifyVoteExtension__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestVerifyVoteExtension_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestVerifyVoteExtension__storage_, hash_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "validatorAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestVerifyVoteExtension_FieldNumber_ValidatorAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestVerifyVoteExtension__storage_, validatorAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestVerifyVoteExtension_FieldNumber_Height,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestVerifyVoteExtension__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "voteExtension",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestVerifyVoteExtension_FieldNumber_VoteExtension,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RequestVerifyVoteExtension__storage_, voteExtension),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RequestVerifyVoteExtension)
                                   messageName:@"RequestVerifyVoteExtension"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestVerifyVoteExtension__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestFinalizeBlock

@implementation RequestFinalizeBlock

@dynamic txsArray, txsArray_Count;
@dynamic hasDecidedLastCommit, decidedLastCommit;
@dynamic misbehaviorArray, misbehaviorArray_Count;
@dynamic hash_p;
@dynamic height;
@dynamic hasTime, time;
@dynamic nextValidatorsHash;
@dynamic proposerAddress;

typedef struct RequestFinalizeBlock__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *txsArray;
  CommitInfo *decidedLastCommit;
  NSMutableArray *misbehaviorArray;
  NSData *hash_p;
  GPBTimestamp *time;
  NSData *nextValidatorsHash;
  NSData *proposerAddress;
  int64_t height;
} RequestFinalizeBlock__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestFinalizeBlock_FieldNumber_TxsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestFinalizeBlock__storage_, txsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "decidedLastCommit",
        .dataTypeSpecific.clazz = GPBObjCClass(CommitInfo),
        .number = RequestFinalizeBlock_FieldNumber_DecidedLastCommit,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestFinalizeBlock__storage_, decidedLastCommit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "misbehaviorArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Misbehavior),
        .number = RequestFinalizeBlock_FieldNumber_MisbehaviorArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestFinalizeBlock__storage_, misbehaviorArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestFinalizeBlock_FieldNumber_Hash_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestFinalizeBlock__storage_, hash_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestFinalizeBlock_FieldNumber_Height,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestFinalizeBlock__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "time",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = RequestFinalizeBlock_FieldNumber_Time,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RequestFinalizeBlock__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextValidatorsHash",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestFinalizeBlock_FieldNumber_NextValidatorsHash,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RequestFinalizeBlock__storage_, nextValidatorsHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "proposerAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestFinalizeBlock_FieldNumber_ProposerAddress,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RequestFinalizeBlock__storage_, proposerAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RequestFinalizeBlock)
                                   messageName:@"RequestFinalizeBlock"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestFinalizeBlock__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Response

@implementation Response

@dynamic valueOneOfCase;
@dynamic exception;
@dynamic echo;
@dynamic flush;
@dynamic info;
@dynamic initChain;
@dynamic query;
@dynamic checkTx;
@dynamic commit;
@dynamic listSnapshots;
@dynamic offerSnapshot;
@dynamic loadSnapshotChunk;
@dynamic applySnapshotChunk;
@dynamic prepareProposal;
@dynamic processProposal;
@dynamic extendVote;
@dynamic verifyVoteExtension;
@dynamic finalizeBlock;

typedef struct Response__storage_ {
  uint32_t _has_storage_[2];
  ResponseException *exception;
  ResponseEcho *echo;
  ResponseFlush *flush;
  ResponseInfo *info;
  ResponseInitChain *initChain;
  ResponseQuery *query;
  ResponseCheckTx *checkTx;
  ResponseCommit *commit;
  ResponseListSnapshots *listSnapshots;
  ResponseOfferSnapshot *offerSnapshot;
  ResponseLoadSnapshotChunk *loadSnapshotChunk;
  ResponseApplySnapshotChunk *applySnapshotChunk;
  ResponsePrepareProposal *prepareProposal;
  ResponseProcessProposal *processProposal;
  ResponseExtendVote *extendVote;
  ResponseVerifyVoteExtension *verifyVoteExtension;
  ResponseFinalizeBlock *finalizeBlock;
} Response__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "exception",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseException),
        .number = Response_FieldNumber_Exception,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Response__storage_, exception),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "echo",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseEcho),
        .number = Response_FieldNumber_Echo,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Response__storage_, echo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "flush",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseFlush),
        .number = Response_FieldNumber_Flush,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Response__storage_, flush),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "info",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseInfo),
        .number = Response_FieldNumber_Info,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Response__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "initChain",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseInitChain),
        .number = Response_FieldNumber_InitChain,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Response__storage_, initChain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "query",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseQuery),
        .number = Response_FieldNumber_Query,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Response__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "checkTx",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseCheckTx),
        .number = Response_FieldNumber_CheckTx,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Response__storage_, checkTx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "commit",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseCommit),
        .number = Response_FieldNumber_Commit,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Response__storage_, commit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "listSnapshots",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseListSnapshots),
        .number = Response_FieldNumber_ListSnapshots,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Response__storage_, listSnapshots),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "offerSnapshot",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseOfferSnapshot),
        .number = Response_FieldNumber_OfferSnapshot,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Response__storage_, offerSnapshot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "loadSnapshotChunk",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseLoadSnapshotChunk),
        .number = Response_FieldNumber_LoadSnapshotChunk,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Response__storage_, loadSnapshotChunk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "applySnapshotChunk",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseApplySnapshotChunk),
        .number = Response_FieldNumber_ApplySnapshotChunk,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Response__storage_, applySnapshotChunk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "prepareProposal",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponsePrepareProposal),
        .number = Response_FieldNumber_PrepareProposal,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Response__storage_, prepareProposal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "processProposal",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseProcessProposal),
        .number = Response_FieldNumber_ProcessProposal,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Response__storage_, processProposal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extendVote",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseExtendVote),
        .number = Response_FieldNumber_ExtendVote,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Response__storage_, extendVote),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "verifyVoteExtension",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseVerifyVoteExtension),
        .number = Response_FieldNumber_VerifyVoteExtension,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Response__storage_, verifyVoteExtension),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "finalizeBlock",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseFinalizeBlock),
        .number = Response_FieldNumber_FinalizeBlock,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Response__storage_, finalizeBlock),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Response)
                                   messageName:@"Response"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Response__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    static const char *oneofs[] = {
      "value",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Response_ClearValueOneOfCase(Response *message) {
  GPBDescriptor *descriptor = [Response descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - ResponseException

@implementation ResponseException

@dynamic error;

typedef struct ResponseException__storage_ {
  uint32_t _has_storage_[1];
  NSString *error;
} ResponseException__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseException_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseException__storage_, error),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ResponseException)
                                   messageName:@"ResponseException"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseException__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseEcho

@implementation ResponseEcho

@dynamic message;

typedef struct ResponseEcho__storage_ {
  uint32_t _has_storage_[1];
  NSString *message;
} ResponseEcho__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseEcho_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseEcho__storage_, message),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ResponseEcho)
                                   messageName:@"ResponseEcho"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseEcho__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseFlush

@implementation ResponseFlush


typedef struct ResponseFlush__storage_ {
  uint32_t _has_storage_[1];
} ResponseFlush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ResponseFlush)
                                   messageName:@"ResponseFlush"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ResponseFlush__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseInfo

@implementation ResponseInfo

@dynamic data_p;
@dynamic version;
@dynamic appVersion;
@dynamic lastBlockHeight;
@dynamic lastBlockAppHash;

typedef struct ResponseInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *data_p;
  NSString *version;
  NSData *lastBlockAppHash;
  uint64_t appVersion;
  int64_t lastBlockHeight;
} ResponseInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseInfo_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseInfo__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseInfo_FieldNumber_Version,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseInfo__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseInfo_FieldNumber_AppVersion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResponseInfo__storage_, appVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "lastBlockHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseInfo_FieldNumber_LastBlockHeight,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ResponseInfo__storage_, lastBlockHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "lastBlockAppHash",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseInfo_FieldNumber_LastBlockAppHash,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ResponseInfo__storage_, lastBlockAppHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ResponseInfo)
                                   messageName:@"ResponseInfo"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseInitChain

@implementation ResponseInitChain

@dynamic hasConsensusParams, consensusParams;
@dynamic validatorsArray, validatorsArray_Count;
@dynamic appHash;

typedef struct ResponseInitChain__storage_ {
  uint32_t _has_storage_[1];
  ConsensusParams *consensusParams;
  NSMutableArray *validatorsArray;
  NSData *appHash;
} ResponseInitChain__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "consensusParams",
        .dataTypeSpecific.clazz = GPBObjCClass(ConsensusParams),
        .number = ResponseInitChain_FieldNumber_ConsensusParams,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseInitChain__storage_, consensusParams),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "validatorsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ValidatorUpdate),
        .number = ResponseInitChain_FieldNumber_ValidatorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseInitChain__storage_, validatorsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "appHash",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseInitChain_FieldNumber_AppHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseInitChain__storage_, appHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ResponseInitChain)
                                   messageName:@"ResponseInitChain"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseInitChain__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseQuery

@implementation ResponseQuery

@dynamic code;
@dynamic log;
@dynamic info;
@dynamic index;
@dynamic key;
@dynamic value;
@dynamic hasProofOps, proofOps;
@dynamic height;
@dynamic codespace;

typedef struct ResponseQuery__storage_ {
  uint32_t _has_storage_[1];
  uint32_t code;
  NSString *log;
  NSString *info;
  NSData *key;
  NSData *value;
  ProofOps *proofOps;
  NSString *codespace;
  int64_t index;
  int64_t height;
} ResponseQuery__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseQuery_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseQuery__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "log",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseQuery_FieldNumber_Log,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseQuery__storage_, log),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "info",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseQuery_FieldNumber_Info,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResponseQuery__storage_, info),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseQuery_FieldNumber_Index,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ResponseQuery__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseQuery_FieldNumber_Key,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ResponseQuery__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseQuery_FieldNumber_Value,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ResponseQuery__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "proofOps",
        .dataTypeSpecific.clazz = GPBObjCClass(ProofOps),
        .number = ResponseQuery_FieldNumber_ProofOps,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ResponseQuery__storage_, proofOps),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseQuery_FieldNumber_Height,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ResponseQuery__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "codespace",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseQuery_FieldNumber_Codespace,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ResponseQuery__storage_, codespace),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ResponseQuery)
                                   messageName:@"ResponseQuery"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseQuery__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseCheckTx

@implementation ResponseCheckTx

@dynamic code;
@dynamic data_p;
@dynamic log;
@dynamic info;
@dynamic gasWanted;
@dynamic gasUsed;
@dynamic eventsArray, eventsArray_Count;
@dynamic codespace;

typedef struct ResponseCheckTx__storage_ {
  uint32_t _has_storage_[1];
  uint32_t code;
  NSData *data_p;
  NSString *log;
  NSString *info;
  NSMutableArray *eventsArray;
  NSString *codespace;
  int64_t gasWanted;
  int64_t gasUsed;
} ResponseCheckTx__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseCheckTx_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseCheckTx__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseCheckTx_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseCheckTx__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "log",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseCheckTx_FieldNumber_Log,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResponseCheckTx__storage_, log),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "info",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseCheckTx_FieldNumber_Info,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ResponseCheckTx__storage_, info),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gasWanted",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseCheckTx_FieldNumber_GasWanted,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ResponseCheckTx__storage_, gasWanted),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "gasUsed",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseCheckTx_FieldNumber_GasUsed,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ResponseCheckTx__storage_, gasUsed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "eventsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Event),
        .number = ResponseCheckTx_FieldNumber_EventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseCheckTx__storage_, eventsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "codespace",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseCheckTx_FieldNumber_Codespace,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ResponseCheckTx__storage_, codespace),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ResponseCheckTx)
                                   messageName:@"ResponseCheckTx"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseCheckTx__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseCommit

@implementation ResponseCommit

@dynamic retainHeight;

typedef struct ResponseCommit__storage_ {
  uint32_t _has_storage_[1];
  int64_t retainHeight;
} ResponseCommit__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "retainHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseCommit_FieldNumber_RetainHeight,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseCommit__storage_, retainHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ResponseCommit)
                                   messageName:@"ResponseCommit"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseCommit__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseListSnapshots

@implementation ResponseListSnapshots

@dynamic snapshotsArray, snapshotsArray_Count;

typedef struct ResponseListSnapshots__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *snapshotsArray;
} ResponseListSnapshots__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "snapshotsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Snapshot),
        .number = ResponseListSnapshots_FieldNumber_SnapshotsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseListSnapshots__storage_, snapshotsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ResponseListSnapshots)
                                   messageName:@"ResponseListSnapshots"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseListSnapshots__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseOfferSnapshot

@implementation ResponseOfferSnapshot

@dynamic result;

typedef struct ResponseOfferSnapshot__storage_ {
  uint32_t _has_storage_[1];
  ResponseOfferSnapshot_Result result;
} ResponseOfferSnapshot__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = ResponseOfferSnapshot_Result_EnumDescriptor,
        .number = ResponseOfferSnapshot_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseOfferSnapshot__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ResponseOfferSnapshot)
                                   messageName:@"ResponseOfferSnapshot"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseOfferSnapshot__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ResponseOfferSnapshot_Result_RawValue(ResponseOfferSnapshot *message) {
  GPBDescriptor *descriptor = [ResponseOfferSnapshot descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ResponseOfferSnapshot_FieldNumber_Result];
  return GPBGetMessageRawEnumField(message, field);
}

void SetResponseOfferSnapshot_Result_RawValue(ResponseOfferSnapshot *message, int32_t value) {
  GPBDescriptor *descriptor = [ResponseOfferSnapshot descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ResponseOfferSnapshot_FieldNumber_Result];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ResponseLoadSnapshotChunk

@implementation ResponseLoadSnapshotChunk

@dynamic chunk;

typedef struct ResponseLoadSnapshotChunk__storage_ {
  uint32_t _has_storage_[1];
  NSData *chunk;
} ResponseLoadSnapshotChunk__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chunk",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseLoadSnapshotChunk_FieldNumber_Chunk,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseLoadSnapshotChunk__storage_, chunk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ResponseLoadSnapshotChunk)
                                   messageName:@"ResponseLoadSnapshotChunk"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseLoadSnapshotChunk__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseApplySnapshotChunk

@implementation ResponseApplySnapshotChunk

@dynamic result;
@dynamic refetchChunksArray, refetchChunksArray_Count;
@dynamic rejectSendersArray, rejectSendersArray_Count;

typedef struct ResponseApplySnapshotChunk__storage_ {
  uint32_t _has_storage_[1];
  ResponseApplySnapshotChunk_Result result;
  GPBUInt32Array *refetchChunksArray;
  NSMutableArray *rejectSendersArray;
} ResponseApplySnapshotChunk__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = ResponseApplySnapshotChunk_Result_EnumDescriptor,
        .number = ResponseApplySnapshotChunk_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseApplySnapshotChunk__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "refetchChunksArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseApplySnapshotChunk_FieldNumber_RefetchChunksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseApplySnapshotChunk__storage_, refetchChunksArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "rejectSendersArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseApplySnapshotChunk_FieldNumber_RejectSendersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseApplySnapshotChunk__storage_, rejectSendersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ResponseApplySnapshotChunk)
                                   messageName:@"ResponseApplySnapshotChunk"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseApplySnapshotChunk__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ResponseApplySnapshotChunk_Result_RawValue(ResponseApplySnapshotChunk *message) {
  GPBDescriptor *descriptor = [ResponseApplySnapshotChunk descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ResponseApplySnapshotChunk_FieldNumber_Result];
  return GPBGetMessageRawEnumField(message, field);
}

void SetResponseApplySnapshotChunk_Result_RawValue(ResponseApplySnapshotChunk *message, int32_t value) {
  GPBDescriptor *descriptor = [ResponseApplySnapshotChunk descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ResponseApplySnapshotChunk_FieldNumber_Result];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ResponsePrepareProposal

@implementation ResponsePrepareProposal

@dynamic txsArray, txsArray_Count;

typedef struct ResponsePrepareProposal__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *txsArray;
} ResponsePrepareProposal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponsePrepareProposal_FieldNumber_TxsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponsePrepareProposal__storage_, txsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ResponsePrepareProposal)
                                   messageName:@"ResponsePrepareProposal"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponsePrepareProposal__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseProcessProposal

@implementation ResponseProcessProposal

@dynamic status;

typedef struct ResponseProcessProposal__storage_ {
  uint32_t _has_storage_[1];
  ResponseProcessProposal_ProposalStatus status;
} ResponseProcessProposal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ResponseProcessProposal_ProposalStatus_EnumDescriptor,
        .number = ResponseProcessProposal_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseProcessProposal__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ResponseProcessProposal)
                                   messageName:@"ResponseProcessProposal"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseProcessProposal__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ResponseProcessProposal_Status_RawValue(ResponseProcessProposal *message) {
  GPBDescriptor *descriptor = [ResponseProcessProposal descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ResponseProcessProposal_FieldNumber_Status];
  return GPBGetMessageRawEnumField(message, field);
}

void SetResponseProcessProposal_Status_RawValue(ResponseProcessProposal *message, int32_t value) {
  GPBDescriptor *descriptor = [ResponseProcessProposal descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ResponseProcessProposal_FieldNumber_Status];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ResponseExtendVote

@implementation ResponseExtendVote

@dynamic voteExtension;

typedef struct ResponseExtendVote__storage_ {
  uint32_t _has_storage_[1];
  NSData *voteExtension;
} ResponseExtendVote__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "voteExtension",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseExtendVote_FieldNumber_VoteExtension,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseExtendVote__storage_, voteExtension),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ResponseExtendVote)
                                   messageName:@"ResponseExtendVote"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseExtendVote__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseVerifyVoteExtension

@implementation ResponseVerifyVoteExtension

@dynamic status;

typedef struct ResponseVerifyVoteExtension__storage_ {
  uint32_t _has_storage_[1];
  ResponseVerifyVoteExtension_VerifyStatus status;
} ResponseVerifyVoteExtension__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ResponseVerifyVoteExtension_VerifyStatus_EnumDescriptor,
        .number = ResponseVerifyVoteExtension_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseVerifyVoteExtension__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ResponseVerifyVoteExtension)
                                   messageName:@"ResponseVerifyVoteExtension"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseVerifyVoteExtension__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ResponseVerifyVoteExtension_Status_RawValue(ResponseVerifyVoteExtension *message) {
  GPBDescriptor *descriptor = [ResponseVerifyVoteExtension descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ResponseVerifyVoteExtension_FieldNumber_Status];
  return GPBGetMessageRawEnumField(message, field);
}

void SetResponseVerifyVoteExtension_Status_RawValue(ResponseVerifyVoteExtension *message, int32_t value) {
  GPBDescriptor *descriptor = [ResponseVerifyVoteExtension descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ResponseVerifyVoteExtension_FieldNumber_Status];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ResponseFinalizeBlock

@implementation ResponseFinalizeBlock

@dynamic eventsArray, eventsArray_Count;
@dynamic txResultsArray, txResultsArray_Count;
@dynamic validatorUpdatesArray, validatorUpdatesArray_Count;
@dynamic hasConsensusParamUpdates, consensusParamUpdates;
@dynamic appHash;

typedef struct ResponseFinalizeBlock__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *eventsArray;
  NSMutableArray *txResultsArray;
  NSMutableArray *validatorUpdatesArray;
  ConsensusParams *consensusParamUpdates;
  NSData *appHash;
} ResponseFinalizeBlock__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eventsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Event),
        .number = ResponseFinalizeBlock_FieldNumber_EventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseFinalizeBlock__storage_, eventsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "txResultsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ExecTxResult),
        .number = ResponseFinalizeBlock_FieldNumber_TxResultsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseFinalizeBlock__storage_, txResultsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "validatorUpdatesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ValidatorUpdate),
        .number = ResponseFinalizeBlock_FieldNumber_ValidatorUpdatesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseFinalizeBlock__storage_, validatorUpdatesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "consensusParamUpdates",
        .dataTypeSpecific.clazz = GPBObjCClass(ConsensusParams),
        .number = ResponseFinalizeBlock_FieldNumber_ConsensusParamUpdates,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseFinalizeBlock__storage_, consensusParamUpdates),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "appHash",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseFinalizeBlock_FieldNumber_AppHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseFinalizeBlock__storage_, appHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ResponseFinalizeBlock)
                                   messageName:@"ResponseFinalizeBlock"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseFinalizeBlock__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CommitInfo

@implementation CommitInfo

@dynamic round;
@dynamic votesArray, votesArray_Count;

typedef struct CommitInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t round;
  NSMutableArray *votesArray;
} CommitInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "round",
        .dataTypeSpecific.clazz = Nil,
        .number = CommitInfo_FieldNumber_Round,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CommitInfo__storage_, round),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "votesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(VoteInfo),
        .number = CommitInfo_FieldNumber_VotesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CommitInfo__storage_, votesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CommitInfo)
                                   messageName:@"CommitInfo"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CommitInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExtendedCommitInfo

@implementation ExtendedCommitInfo

@dynamic round;
@dynamic votesArray, votesArray_Count;

typedef struct ExtendedCommitInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t round;
  NSMutableArray *votesArray;
} ExtendedCommitInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "round",
        .dataTypeSpecific.clazz = Nil,
        .number = ExtendedCommitInfo_FieldNumber_Round,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExtendedCommitInfo__storage_, round),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "votesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ExtendedVoteInfo),
        .number = ExtendedCommitInfo_FieldNumber_VotesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ExtendedCommitInfo__storage_, votesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ExtendedCommitInfo)
                                   messageName:@"ExtendedCommitInfo"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExtendedCommitInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Event

@implementation Event

@dynamic type;
@dynamic attributesArray, attributesArray_Count;

typedef struct Event__storage_ {
  uint32_t _has_storage_[1];
  NSString *type;
  NSMutableArray *attributesArray;
} Event__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.clazz = Nil,
        .number = Event_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Event__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attributesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(EventAttribute),
        .number = Event_FieldNumber_AttributesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Event__storage_, attributesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Event)
                                   messageName:@"Event"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Event__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EventAttribute

@implementation EventAttribute

@dynamic key;
@dynamic value;
@dynamic index;

typedef struct EventAttribute__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSString *value;
} EventAttribute__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = EventAttribute_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EventAttribute__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = EventAttribute_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EventAttribute__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = EventAttribute_FieldNumber_Index,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EventAttribute)
                                   messageName:@"EventAttribute"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EventAttribute__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExecTxResult

@implementation ExecTxResult

@dynamic code;
@dynamic data_p;
@dynamic log;
@dynamic info;
@dynamic gasWanted;
@dynamic gasUsed;
@dynamic eventsArray, eventsArray_Count;
@dynamic codespace;

typedef struct ExecTxResult__storage_ {
  uint32_t _has_storage_[1];
  uint32_t code;
  NSData *data_p;
  NSString *log;
  NSString *info;
  NSMutableArray *eventsArray;
  NSString *codespace;
  int64_t gasWanted;
  int64_t gasUsed;
} ExecTxResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.clazz = Nil,
        .number = ExecTxResult_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExecTxResult__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = ExecTxResult_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ExecTxResult__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "log",
        .dataTypeSpecific.clazz = Nil,
        .number = ExecTxResult_FieldNumber_Log,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ExecTxResult__storage_, log),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "info",
        .dataTypeSpecific.clazz = Nil,
        .number = ExecTxResult_FieldNumber_Info,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ExecTxResult__storage_, info),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gasWanted",
        .dataTypeSpecific.clazz = Nil,
        .number = ExecTxResult_FieldNumber_GasWanted,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ExecTxResult__storage_, gasWanted),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "gasUsed",
        .dataTypeSpecific.clazz = Nil,
        .number = ExecTxResult_FieldNumber_GasUsed,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ExecTxResult__storage_, gasUsed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "eventsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Event),
        .number = ExecTxResult_FieldNumber_EventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ExecTxResult__storage_, eventsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "codespace",
        .dataTypeSpecific.clazz = Nil,
        .number = ExecTxResult_FieldNumber_Codespace,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ExecTxResult__storage_, codespace),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ExecTxResult)
                                   messageName:@"ExecTxResult"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExecTxResult__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TxResult

@implementation TxResult

@dynamic height;
@dynamic index;
@dynamic tx;
@dynamic hasResult, result;

typedef struct TxResult__storage_ {
  uint32_t _has_storage_[1];
  uint32_t index;
  NSData *tx;
  ExecTxResult *result;
  int64_t height;
} TxResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = TxResult_FieldNumber_Height,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TxResult__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = TxResult_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TxResult__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tx",
        .dataTypeSpecific.clazz = Nil,
        .number = TxResult_FieldNumber_Tx,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TxResult__storage_, tx),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "result",
        .dataTypeSpecific.clazz = GPBObjCClass(ExecTxResult),
        .number = TxResult_FieldNumber_Result,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TxResult__storage_, result),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TxResult)
                                   messageName:@"TxResult"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxResult__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Validator

@implementation Validator

@dynamic address;
@dynamic power;

typedef struct Validator__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  int64_t power;
} Validator__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = Validator_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Validator__storage_, address),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "power",
        .dataTypeSpecific.clazz = Nil,
        .number = Validator_FieldNumber_Power,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Validator__storage_, power),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Validator)
                                   messageName:@"Validator"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Validator__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ValidatorUpdate

@implementation ValidatorUpdate

@dynamic hasPubKey, pubKey;
@dynamic power;

typedef struct ValidatorUpdate__storage_ {
  uint32_t _has_storage_[1];
  PublicKey *pubKey;
  int64_t power;
} ValidatorUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.clazz = GPBObjCClass(PublicKey),
        .number = ValidatorUpdate_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ValidatorUpdate__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "power",
        .dataTypeSpecific.clazz = Nil,
        .number = ValidatorUpdate_FieldNumber_Power,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ValidatorUpdate__storage_, power),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ValidatorUpdate)
                                   messageName:@"ValidatorUpdate"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ValidatorUpdate__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VoteInfo

@implementation VoteInfo

@dynamic hasValidator, validator;
@dynamic blockIdFlag;

typedef struct VoteInfo__storage_ {
  uint32_t _has_storage_[1];
  BlockIDFlag blockIdFlag;
  Validator *validator;
} VoteInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "validator",
        .dataTypeSpecific.clazz = GPBObjCClass(Validator),
        .number = VoteInfo_FieldNumber_Validator,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VoteInfo__storage_, validator),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockIdFlag",
        .dataTypeSpecific.enumDescFunc = BlockIDFlag_EnumDescriptor,
        .number = VoteInfo_FieldNumber_BlockIdFlag,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VoteInfo__storage_, blockIdFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VoteInfo)
                                   messageName:@"VoteInfo"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VoteInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t VoteInfo_BlockIdFlag_RawValue(VoteInfo *message) {
  GPBDescriptor *descriptor = [VoteInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:VoteInfo_FieldNumber_BlockIdFlag];
  return GPBGetMessageRawEnumField(message, field);
}

void SetVoteInfo_BlockIdFlag_RawValue(VoteInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [VoteInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:VoteInfo_FieldNumber_BlockIdFlag];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ExtendedVoteInfo

@implementation ExtendedVoteInfo

@dynamic hasValidator, validator;
@dynamic voteExtension;
@dynamic extensionSignature;
@dynamic blockIdFlag;

typedef struct ExtendedVoteInfo__storage_ {
  uint32_t _has_storage_[1];
  BlockIDFlag blockIdFlag;
  Validator *validator;
  NSData *voteExtension;
  NSData *extensionSignature;
} ExtendedVoteInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "validator",
        .dataTypeSpecific.clazz = GPBObjCClass(Validator),
        .number = ExtendedVoteInfo_FieldNumber_Validator,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExtendedVoteInfo__storage_, validator),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "voteExtension",
        .dataTypeSpecific.clazz = Nil,
        .number = ExtendedVoteInfo_FieldNumber_VoteExtension,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ExtendedVoteInfo__storage_, voteExtension),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "extensionSignature",
        .dataTypeSpecific.clazz = Nil,
        .number = ExtendedVoteInfo_FieldNumber_ExtensionSignature,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ExtendedVoteInfo__storage_, extensionSignature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "blockIdFlag",
        .dataTypeSpecific.enumDescFunc = BlockIDFlag_EnumDescriptor,
        .number = ExtendedVoteInfo_FieldNumber_BlockIdFlag,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ExtendedVoteInfo__storage_, blockIdFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ExtendedVoteInfo)
                                   messageName:@"ExtendedVoteInfo"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExtendedVoteInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ExtendedVoteInfo_BlockIdFlag_RawValue(ExtendedVoteInfo *message) {
  GPBDescriptor *descriptor = [ExtendedVoteInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ExtendedVoteInfo_FieldNumber_BlockIdFlag];
  return GPBGetMessageRawEnumField(message, field);
}

void SetExtendedVoteInfo_BlockIdFlag_RawValue(ExtendedVoteInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [ExtendedVoteInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ExtendedVoteInfo_FieldNumber_BlockIdFlag];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Misbehavior

@implementation Misbehavior

@dynamic type;
@dynamic hasValidator, validator;
@dynamic height;
@dynamic hasTime, time;
@dynamic totalVotingPower;

typedef struct Misbehavior__storage_ {
  uint32_t _has_storage_[1];
  MisbehaviorType type;
  Validator *validator;
  GPBTimestamp *time;
  int64_t height;
  int64_t totalVotingPower;
} Misbehavior__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = MisbehaviorType_EnumDescriptor,
        .number = Misbehavior_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Misbehavior__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "validator",
        .dataTypeSpecific.clazz = GPBObjCClass(Validator),
        .number = Misbehavior_FieldNumber_Validator,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Misbehavior__storage_, validator),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = Misbehavior_FieldNumber_Height,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Misbehavior__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "time",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = Misbehavior_FieldNumber_Time,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Misbehavior__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "totalVotingPower",
        .dataTypeSpecific.clazz = Nil,
        .number = Misbehavior_FieldNumber_TotalVotingPower,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Misbehavior__storage_, totalVotingPower),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Misbehavior)
                                   messageName:@"Misbehavior"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Misbehavior__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Misbehavior_Type_RawValue(Misbehavior *message) {
  GPBDescriptor *descriptor = [Misbehavior descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Misbehavior_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMisbehavior_Type_RawValue(Misbehavior *message, int32_t value) {
  GPBDescriptor *descriptor = [Misbehavior descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Misbehavior_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Snapshot

@implementation Snapshot

@dynamic height;
@dynamic format;
@dynamic chunks;
@dynamic hash_p;
@dynamic metadata;

typedef struct Snapshot__storage_ {
  uint32_t _has_storage_[1];
  uint32_t format;
  uint32_t chunks;
  NSData *hash_p;
  NSData *metadata;
  uint64_t height;
} Snapshot__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = Snapshot_FieldNumber_Height,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Snapshot__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "format",
        .dataTypeSpecific.clazz = Nil,
        .number = Snapshot_FieldNumber_Format,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Snapshot__storage_, format),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "chunks",
        .dataTypeSpecific.clazz = Nil,
        .number = Snapshot_FieldNumber_Chunks,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Snapshot__storage_, chunks),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Snapshot_FieldNumber_Hash_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Snapshot__storage_, hash_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.clazz = Nil,
        .number = Snapshot_FieldNumber_Metadata,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Snapshot__storage_, metadata),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Snapshot)
                                   messageName:@"Snapshot"
                               fileDescription:&TypesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Snapshot__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
