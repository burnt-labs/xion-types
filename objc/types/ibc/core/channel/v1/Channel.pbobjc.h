// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// clang-format off
// source: ibc/core/channel/v1/channel.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers.h>
#else
 #import "GPBProtocolBuffers.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import "ibc/core/client/v1/Client.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

CF_EXTERN_C_BEGIN

@class Counterparty;

NS_ASSUME_NONNULL_BEGIN

#pragma mark - Enum State

/**
 * State defines if a channel is in one of the following states:
 * CLOSED, INIT, TRYOPEN, OPEN, or UNINITIALIZED.
 **/
typedef GPB_ENUM(State) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  State_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Default State */
  State_StateUninitializedUnspecified = 0,

  /** A channel has just started the opening handshake. */
  State_StateInit = 1,

  /** A channel has acknowledged the handshake step on the counterparty chain. */
  State_StateTryopen = 2,

  /**
   * A channel has completed the handshake. Open channels are
   * ready to send and receive packets.
   **/
  State_StateOpen = 3,

  /**
   * A channel has been closed and can no longer be used to send or receive
   * packets.
   **/
  State_StateClosed = 4,
};

GPBEnumDescriptor *State_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL State_IsValidValue(int32_t value);

#pragma mark - Enum Order

/** Order defines if a channel is ORDERED or UNORDERED */
typedef GPB_ENUM(Order) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  Order_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** zero-value for channel ordering */
  Order_OrderNoneUnspecified = 0,

  /**
   * packets can be delivered in any order, which may differ from the order in
   * which they were sent.
   **/
  Order_OrderUnordered = 1,

  /** packets are delivered exactly in the order which they were sent */
  Order_OrderOrdered = 2,
};

GPBEnumDescriptor *Order_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL Order_IsValidValue(int32_t value);

#pragma mark - ChannelRoot

/**
 * Exposes the extension registry for this file.
 *
 * The base class provides:
 * @code
 *   + (GPBExtensionRegistry *)extensionRegistry;
 * @endcode
 * which is a @c GPBExtensionRegistry that includes all the extensions defined by
 * this file and all files that it depends on.
 **/
GPB_FINAL @interface ChannelRoot : GPBRootObject
@end

#pragma mark - Channel

typedef GPB_ENUM(Channel_FieldNumber) {
  Channel_FieldNumber_State = 1,
  Channel_FieldNumber_Ordering = 2,
  Channel_FieldNumber_Counterparty = 3,
  Channel_FieldNumber_ConnectionHopsArray = 4,
  Channel_FieldNumber_Version = 5,
};

/**
 * Channel defines pipeline for exactly-once packet delivery between specific
 * modules on separate blockchains, which has at least one end capable of
 * sending packets and one end capable of receiving packets.
 **/
GPB_FINAL @interface Channel : GPBMessage

/** current state of the channel end */
@property(nonatomic, readwrite) State state;

/** whether the channel is ordered or unordered */
@property(nonatomic, readwrite) Order ordering;

/** counterparty channel end */
@property(nonatomic, readwrite, strong, null_resettable) Counterparty *counterparty;
/** Test to see if @c counterparty has been set. */
@property(nonatomic, readwrite) BOOL hasCounterparty;

/**
 * list of connection identifiers, in order, along which packets sent on
 * this channel will travel
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NSString*> *connectionHopsArray;
/** The number of items in @c connectionHopsArray without causing the container to be created. */
@property(nonatomic, readonly) NSUInteger connectionHopsArray_Count;

/** opaque channel version, which is agreed upon during the handshake */
@property(nonatomic, readwrite, copy, null_resettable) NSString *version;

@end

/**
 * Fetches the raw value of a @c Channel's @c state property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t Channel_State_RawValue(Channel *message);
/**
 * Sets the raw value of an @c Channel's @c state property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetChannel_State_RawValue(Channel *message, int32_t value);

/**
 * Fetches the raw value of a @c Channel's @c ordering property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t Channel_Ordering_RawValue(Channel *message);
/**
 * Sets the raw value of an @c Channel's @c ordering property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetChannel_Ordering_RawValue(Channel *message, int32_t value);

#pragma mark - IdentifiedChannel

typedef GPB_ENUM(IdentifiedChannel_FieldNumber) {
  IdentifiedChannel_FieldNumber_State = 1,
  IdentifiedChannel_FieldNumber_Ordering = 2,
  IdentifiedChannel_FieldNumber_Counterparty = 3,
  IdentifiedChannel_FieldNumber_ConnectionHopsArray = 4,
  IdentifiedChannel_FieldNumber_Version = 5,
  IdentifiedChannel_FieldNumber_PortId = 6,
  IdentifiedChannel_FieldNumber_ChannelId = 7,
};

/**
 * IdentifiedChannel defines a channel with additional port and channel
 * identifier fields.
 **/
GPB_FINAL @interface IdentifiedChannel : GPBMessage

/** current state of the channel end */
@property(nonatomic, readwrite) State state;

/** whether the channel is ordered or unordered */
@property(nonatomic, readwrite) Order ordering;

/** counterparty channel end */
@property(nonatomic, readwrite, strong, null_resettable) Counterparty *counterparty;
/** Test to see if @c counterparty has been set. */
@property(nonatomic, readwrite) BOOL hasCounterparty;

/**
 * list of connection identifiers, in order, along which packets sent on
 * this channel will travel
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NSString*> *connectionHopsArray;
/** The number of items in @c connectionHopsArray without causing the container to be created. */
@property(nonatomic, readonly) NSUInteger connectionHopsArray_Count;

/** opaque channel version, which is agreed upon during the handshake */
@property(nonatomic, readwrite, copy, null_resettable) NSString *version;

/** port identifier */
@property(nonatomic, readwrite, copy, null_resettable) NSString *portId;

/** channel identifier */
@property(nonatomic, readwrite, copy, null_resettable) NSString *channelId;

@end

/**
 * Fetches the raw value of a @c IdentifiedChannel's @c state property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t IdentifiedChannel_State_RawValue(IdentifiedChannel *message);
/**
 * Sets the raw value of an @c IdentifiedChannel's @c state property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetIdentifiedChannel_State_RawValue(IdentifiedChannel *message, int32_t value);

/**
 * Fetches the raw value of a @c IdentifiedChannel's @c ordering property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t IdentifiedChannel_Ordering_RawValue(IdentifiedChannel *message);
/**
 * Sets the raw value of an @c IdentifiedChannel's @c ordering property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetIdentifiedChannel_Ordering_RawValue(IdentifiedChannel *message, int32_t value);

#pragma mark - Counterparty

typedef GPB_ENUM(Counterparty_FieldNumber) {
  Counterparty_FieldNumber_PortId = 1,
  Counterparty_FieldNumber_ChannelId = 2,
};

/**
 * Counterparty defines a channel end counterparty
 **/
GPB_FINAL @interface Counterparty : GPBMessage

/** port on the counterparty chain which owns the other end of the channel. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *portId;

/** channel end on the counterparty chain */
@property(nonatomic, readwrite, copy, null_resettable) NSString *channelId;

@end

#pragma mark - Packet

typedef GPB_ENUM(Packet_FieldNumber) {
  Packet_FieldNumber_Sequence = 1,
  Packet_FieldNumber_SourcePort = 2,
  Packet_FieldNumber_SourceChannel = 3,
  Packet_FieldNumber_DestinationPort = 4,
  Packet_FieldNumber_DestinationChannel = 5,
  Packet_FieldNumber_Data_p = 6,
  Packet_FieldNumber_TimeoutHeight = 7,
  Packet_FieldNumber_TimeoutTimestamp = 8,
};

/**
 * Packet defines a type that carries data across different chains through IBC
 **/
GPB_FINAL @interface Packet : GPBMessage

/**
 * number corresponds to the order of sends and receives, where a Packet
 * with an earlier sequence number must be sent and received before a Packet
 * with a later sequence number.
 **/
@property(nonatomic, readwrite) uint64_t sequence;

/** identifies the port on the sending chain. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *sourcePort;

/** identifies the channel end on the sending chain. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *sourceChannel;

/** identifies the port on the receiving chain. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *destinationPort;

/** identifies the channel end on the receiving chain. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *destinationChannel;

/** actual opaque bytes transferred directly to the application module */
@property(nonatomic, readwrite, copy, null_resettable) NSData *data_p;

/** block height after which the packet times out */
@property(nonatomic, readwrite, strong, null_resettable) Height *timeoutHeight;
/** Test to see if @c timeoutHeight has been set. */
@property(nonatomic, readwrite) BOOL hasTimeoutHeight;

/** block timestamp (in nanoseconds) after which the packet times out */
@property(nonatomic, readwrite) uint64_t timeoutTimestamp;

@end

#pragma mark - PacketState

typedef GPB_ENUM(PacketState_FieldNumber) {
  PacketState_FieldNumber_PortId = 1,
  PacketState_FieldNumber_ChannelId = 2,
  PacketState_FieldNumber_Sequence = 3,
  PacketState_FieldNumber_Data_p = 4,
};

/**
 * PacketState defines the generic type necessary to retrieve and store
 * packet commitments, acknowledgements, and receipts.
 * Caller is responsible for knowing the context necessary to interpret this
 * state as a commitment, acknowledgement, or a receipt.
 **/
GPB_FINAL @interface PacketState : GPBMessage

/** channel port identifier. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *portId;

/** channel unique identifier. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *channelId;

/** packet sequence. */
@property(nonatomic, readwrite) uint64_t sequence;

/** embedded data that represents packet state. */
@property(nonatomic, readwrite, copy, null_resettable) NSData *data_p;

@end

#pragma mark - PacketId

typedef GPB_ENUM(PacketId_FieldNumber) {
  PacketId_FieldNumber_PortId = 1,
  PacketId_FieldNumber_ChannelId = 2,
  PacketId_FieldNumber_Sequence = 3,
};

/**
 * PacketId is an identifier for a unique Packet
 * Source chains refer to packets by source port/channel
 * Destination chains refer to packets by destination port/channel
 **/
GPB_FINAL @interface PacketId : GPBMessage

/** channel port identifier */
@property(nonatomic, readwrite, copy, null_resettable) NSString *portId;

/** channel unique identifier */
@property(nonatomic, readwrite, copy, null_resettable) NSString *channelId;

/** packet sequence */
@property(nonatomic, readwrite) uint64_t sequence;

@end

#pragma mark - Acknowledgement

typedef GPB_ENUM(Acknowledgement_FieldNumber) {
  Acknowledgement_FieldNumber_Result = 21,
  Acknowledgement_FieldNumber_Error = 22,
};

typedef GPB_ENUM(Acknowledgement_Response_OneOfCase) {
  Acknowledgement_Response_OneOfCase_GPBUnsetOneOfCase = 0,
  Acknowledgement_Response_OneOfCase_Result = 21,
  Acknowledgement_Response_OneOfCase_Error = 22,
};

/**
 * Acknowledgement is the recommended acknowledgement format to be used by
 * app-specific protocols.
 * NOTE: The field numbers 21 and 22 were explicitly chosen to avoid accidental
 * conflicts with other protobuf message formats used for acknowledgements.
 * The first byte of any message with this format will be the non-ASCII values
 * `0xaa` (result) or `0xb2` (error). Implemented as defined by ICS:
 * https://github.com/cosmos/ibc/tree/master/spec/core/ics-004-channel-and-packet-semantics#acknowledgement-envelope
 **/
GPB_FINAL @interface Acknowledgement : GPBMessage

/** response contains either a result or an error and must be non-empty */
@property(nonatomic, readonly) Acknowledgement_Response_OneOfCase responseOneOfCase;

@property(nonatomic, readwrite, copy, null_resettable) NSData *result;

@property(nonatomic, readwrite, copy, null_resettable) NSString *error;

@end

/**
 * Clears whatever value was set for the oneof 'response'.
 **/
void Acknowledgement_ClearResponseOneOfCase(Acknowledgement *message);

#pragma mark - Timeout

typedef GPB_ENUM(Timeout_FieldNumber) {
  Timeout_FieldNumber_Height = 1,
  Timeout_FieldNumber_Timestamp = 2,
};

/**
 * Timeout defines an execution deadline structure for 04-channel handlers.
 * This includes packet lifecycle handlers.
 * A valid Timeout contains either one or both of a timestamp and block height (sequence).
 **/
GPB_FINAL @interface Timeout : GPBMessage

/** block height after which the packet times out */
@property(nonatomic, readwrite, strong, null_resettable) Height *height;
/** Test to see if @c height has been set. */
@property(nonatomic, readwrite) BOOL hasHeight;

/** block timestamp (in nanoseconds) after which the packet times out */
@property(nonatomic, readwrite) uint64_t timestamp;

@end

NS_ASSUME_NONNULL_END

CF_EXTERN_C_END

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
