// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// clang-format off
// source: xion/feeabs/v1beta1/osmosisibc.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import "xion/feeabs/v1beta1/Osmosisibc.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(CosmosQuery);
GPBObjCClassDeclaration(CosmosResponse);
GPBObjCClassDeclaration(GPBTimestamp);
GPBObjCClassDeclaration(InterchainQueryPacketAck);
GPBObjCClassDeclaration(InterchainQueryPacketData);
GPBObjCClassDeclaration(InterchainQueryRequest);
GPBObjCClassDeclaration(InterchainQueryRequestPacket);
GPBObjCClassDeclaration(QueryArithmeticTwapToNowRequest);
GPBObjCClassDeclaration(QueryArithmeticTwapToNowResponse);
GPBObjCClassDeclaration(RequestQuery);
GPBObjCClassDeclaration(ResponseQuery);

#pragma mark - OsmosisibcRoot

@implementation OsmosisibcRoot

// No extensions in the file and no imports or none of the imports (direct or
// indirect) defined extensions, so no need to generate +extensionRegistry.

@end

static GPBFileDescription OsmosisibcRoot_FileDescription = {
  .package = "xion.feeabs.v1beta1",
  .prefix = NULL,
  .syntax = GPBFileSyntaxProto3
};

#pragma mark - QueryArithmeticTwapToNowRequest

@implementation QueryArithmeticTwapToNowRequest

@dynamic poolId;
@dynamic baseAsset;
@dynamic quoteAsset;
@dynamic hasStartTime, startTime;

typedef struct QueryArithmeticTwapToNowRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *baseAsset;
  NSString *quoteAsset;
  GPBTimestamp *startTime;
  uint64_t poolId;
} QueryArithmeticTwapToNowRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "poolId",
        .dataTypeSpecific.clazz = Nil,
        .number = QueryArithmeticTwapToNowRequest_FieldNumber_PoolId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QueryArithmeticTwapToNowRequest__storage_, poolId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "baseAsset",
        .dataTypeSpecific.clazz = Nil,
        .number = QueryArithmeticTwapToNowRequest_FieldNumber_BaseAsset,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QueryArithmeticTwapToNowRequest__storage_, baseAsset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "quoteAsset",
        .dataTypeSpecific.clazz = Nil,
        .number = QueryArithmeticTwapToNowRequest_FieldNumber_QuoteAsset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QueryArithmeticTwapToNowRequest__storage_, quoteAsset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = QueryArithmeticTwapToNowRequest_FieldNumber_StartTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(QueryArithmeticTwapToNowRequest__storage_, startTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QueryArithmeticTwapToNowRequest)
                                   messageName:@"QueryArithmeticTwapToNowRequest"
                               fileDescription:&OsmosisibcRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QueryArithmeticTwapToNowRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QueryArithmeticTwapToNowResponse

@implementation QueryArithmeticTwapToNowResponse

@dynamic arithmeticTwap;

typedef struct QueryArithmeticTwapToNowResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *arithmeticTwap;
} QueryArithmeticTwapToNowResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "arithmeticTwap",
        .dataTypeSpecific.clazz = Nil,
        .number = QueryArithmeticTwapToNowResponse_FieldNumber_ArithmeticTwap,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QueryArithmeticTwapToNowResponse__storage_, arithmeticTwap),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QueryArithmeticTwapToNowResponse)
                                   messageName:@"QueryArithmeticTwapToNowResponse"
                               fileDescription:&OsmosisibcRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QueryArithmeticTwapToNowResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InterchainQueryRequest

@implementation InterchainQueryRequest

@dynamic data_p;
@dynamic path;

typedef struct InterchainQueryRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *data_p;
  NSString *path;
} InterchainQueryRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = InterchainQueryRequest_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InterchainQueryRequest__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "path",
        .dataTypeSpecific.clazz = Nil,
        .number = InterchainQueryRequest_FieldNumber_Path,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InterchainQueryRequest__storage_, path),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(InterchainQueryRequest)
                                   messageName:@"InterchainQueryRequest"
                               fileDescription:&OsmosisibcRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InterchainQueryRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InterchainQueryPacketData

@implementation InterchainQueryPacketData

@dynamic data_p;
@dynamic memo;

typedef struct InterchainQueryPacketData__storage_ {
  uint32_t _has_storage_[1];
  NSData *data_p;
  NSString *memo;
} InterchainQueryPacketData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = InterchainQueryPacketData_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InterchainQueryPacketData__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "memo",
        .dataTypeSpecific.clazz = Nil,
        .number = InterchainQueryPacketData_FieldNumber_Memo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InterchainQueryPacketData__storage_, memo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(InterchainQueryPacketData)
                                   messageName:@"InterchainQueryPacketData"
                               fileDescription:&OsmosisibcRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InterchainQueryPacketData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InterchainQueryPacketAck

@implementation InterchainQueryPacketAck

@dynamic data_p;

typedef struct InterchainQueryPacketAck__storage_ {
  uint32_t _has_storage_[1];
  NSData *data_p;
} InterchainQueryPacketAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = InterchainQueryPacketAck_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InterchainQueryPacketAck__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(InterchainQueryPacketAck)
                                   messageName:@"InterchainQueryPacketAck"
                               fileDescription:&OsmosisibcRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InterchainQueryPacketAck__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InterchainQueryRequestPacket

@implementation InterchainQueryRequestPacket

@dynamic requestsArray, requestsArray_Count;

typedef struct InterchainQueryRequestPacket__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *requestsArray;
} InterchainQueryRequestPacket__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "requestsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InterchainQueryRequest),
        .number = InterchainQueryRequestPacket_FieldNumber_RequestsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InterchainQueryRequestPacket__storage_, requestsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(InterchainQueryRequestPacket)
                                   messageName:@"InterchainQueryRequestPacket"
                               fileDescription:&OsmosisibcRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InterchainQueryRequestPacket__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CosmosQuery

@implementation CosmosQuery

@dynamic requestsArray, requestsArray_Count;

typedef struct CosmosQuery__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *requestsArray;
} CosmosQuery__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "requestsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(RequestQuery),
        .number = CosmosQuery_FieldNumber_RequestsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CosmosQuery__storage_, requestsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CosmosQuery)
                                   messageName:@"CosmosQuery"
                               fileDescription:&OsmosisibcRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CosmosQuery__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CosmosResponse

@implementation CosmosResponse

@dynamic responsesArray, responsesArray_Count;

typedef struct CosmosResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *responsesArray;
} CosmosResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "responsesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ResponseQuery),
        .number = CosmosResponse_FieldNumber_ResponsesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CosmosResponse__storage_, responsesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CosmosResponse)
                                   messageName:@"CosmosResponse"
                               fileDescription:&OsmosisibcRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CosmosResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
