// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// clang-format off
// source: cosmos/distribution/v1beta1/distribution.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import "cosmos/distribution/v1beta1/Distribution.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Coin);
GPBObjCClassDeclaration(CommunityPoolSpendProposal);
GPBObjCClassDeclaration(CommunityPoolSpendProposalWithDeposit);
GPBObjCClassDeclaration(DecCoin);
GPBObjCClassDeclaration(DelegationDelegatorReward);
GPBObjCClassDeclaration(DelegatorStartingInfo);
GPBObjCClassDeclaration(FeePool);
GPBObjCClassDeclaration(Params);
GPBObjCClassDeclaration(ValidatorAccumulatedCommission);
GPBObjCClassDeclaration(ValidatorCurrentRewards);
GPBObjCClassDeclaration(ValidatorHistoricalRewards);
GPBObjCClassDeclaration(ValidatorOutstandingRewards);
GPBObjCClassDeclaration(ValidatorSlashEvent);
GPBObjCClassDeclaration(ValidatorSlashEvents);

#pragma mark - DistributionRoot

@implementation DistributionRoot

// No extensions in the file and no imports or none of the imports (direct or
// indirect) defined extensions, so no need to generate +extensionRegistry.

@end

static GPBFileDescription DistributionRoot_FileDescription = {
  .package = "cosmos.distribution.v1beta1",
  .prefix = NULL,
  .syntax = GPBFileSyntaxProto3
};

#pragma mark - Params

@implementation Params

@dynamic communityTax;
@dynamic baseProposerReward;
@dynamic bonusProposerReward;
@dynamic withdrawAddrEnabled;

typedef struct Params__storage_ {
  uint32_t _has_storage_[1];
  NSString *communityTax;
  NSString *baseProposerReward;
  NSString *bonusProposerReward;
} Params__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "communityTax",
        .dataTypeSpecific.clazz = Nil,
        .number = Params_FieldNumber_CommunityTax,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Params__storage_, communityTax),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "baseProposerReward",
        .dataTypeSpecific.clazz = Nil,
        .number = Params_FieldNumber_BaseProposerReward,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Params__storage_, baseProposerReward),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bonusProposerReward",
        .dataTypeSpecific.clazz = Nil,
        .number = Params_FieldNumber_BonusProposerReward,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Params__storage_, bonusProposerReward),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "withdrawAddrEnabled",
        .dataTypeSpecific.clazz = Nil,
        .number = Params_FieldNumber_WithdrawAddrEnabled,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Params)
                                   messageName:@"Params"
                               fileDescription:&DistributionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Params__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ValidatorHistoricalRewards

@implementation ValidatorHistoricalRewards

@dynamic cumulativeRewardRatioArray, cumulativeRewardRatioArray_Count;
@dynamic referenceCount;

typedef struct ValidatorHistoricalRewards__storage_ {
  uint32_t _has_storage_[1];
  uint32_t referenceCount;
  NSMutableArray *cumulativeRewardRatioArray;
} ValidatorHistoricalRewards__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cumulativeRewardRatioArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DecCoin),
        .number = ValidatorHistoricalRewards_FieldNumber_CumulativeRewardRatioArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ValidatorHistoricalRewards__storage_, cumulativeRewardRatioArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "referenceCount",
        .dataTypeSpecific.clazz = Nil,
        .number = ValidatorHistoricalRewards_FieldNumber_ReferenceCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ValidatorHistoricalRewards__storage_, referenceCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ValidatorHistoricalRewards)
                                   messageName:@"ValidatorHistoricalRewards"
                               fileDescription:&DistributionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ValidatorHistoricalRewards__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ValidatorCurrentRewards

@implementation ValidatorCurrentRewards

@dynamic rewardsArray, rewardsArray_Count;
@dynamic period;

typedef struct ValidatorCurrentRewards__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *rewardsArray;
  uint64_t period;
} ValidatorCurrentRewards__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rewardsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DecCoin),
        .number = ValidatorCurrentRewards_FieldNumber_RewardsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ValidatorCurrentRewards__storage_, rewardsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "period",
        .dataTypeSpecific.clazz = Nil,
        .number = ValidatorCurrentRewards_FieldNumber_Period,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ValidatorCurrentRewards__storage_, period),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ValidatorCurrentRewards)
                                   messageName:@"ValidatorCurrentRewards"
                               fileDescription:&DistributionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ValidatorCurrentRewards__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ValidatorAccumulatedCommission

@implementation ValidatorAccumulatedCommission

@dynamic commissionArray, commissionArray_Count;

typedef struct ValidatorAccumulatedCommission__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *commissionArray;
} ValidatorAccumulatedCommission__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "commissionArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DecCoin),
        .number = ValidatorAccumulatedCommission_FieldNumber_CommissionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ValidatorAccumulatedCommission__storage_, commissionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ValidatorAccumulatedCommission)
                                   messageName:@"ValidatorAccumulatedCommission"
                               fileDescription:&DistributionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ValidatorAccumulatedCommission__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ValidatorOutstandingRewards

@implementation ValidatorOutstandingRewards

@dynamic rewardsArray, rewardsArray_Count;

typedef struct ValidatorOutstandingRewards__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *rewardsArray;
} ValidatorOutstandingRewards__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rewardsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DecCoin),
        .number = ValidatorOutstandingRewards_FieldNumber_RewardsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ValidatorOutstandingRewards__storage_, rewardsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ValidatorOutstandingRewards)
                                   messageName:@"ValidatorOutstandingRewards"
                               fileDescription:&DistributionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ValidatorOutstandingRewards__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ValidatorSlashEvent

@implementation ValidatorSlashEvent

@dynamic validatorPeriod;
@dynamic fraction;

typedef struct ValidatorSlashEvent__storage_ {
  uint32_t _has_storage_[1];
  NSString *fraction;
  uint64_t validatorPeriod;
} ValidatorSlashEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "validatorPeriod",
        .dataTypeSpecific.clazz = Nil,
        .number = ValidatorSlashEvent_FieldNumber_ValidatorPeriod,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ValidatorSlashEvent__storage_, validatorPeriod),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "fraction",
        .dataTypeSpecific.clazz = Nil,
        .number = ValidatorSlashEvent_FieldNumber_Fraction,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ValidatorSlashEvent__storage_, fraction),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ValidatorSlashEvent)
                                   messageName:@"ValidatorSlashEvent"
                               fileDescription:&DistributionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ValidatorSlashEvent__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ValidatorSlashEvents

@implementation ValidatorSlashEvents

@dynamic validatorSlashEventsArray, validatorSlashEventsArray_Count;

typedef struct ValidatorSlashEvents__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *validatorSlashEventsArray;
} ValidatorSlashEvents__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "validatorSlashEventsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ValidatorSlashEvent),
        .number = ValidatorSlashEvents_FieldNumber_ValidatorSlashEventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ValidatorSlashEvents__storage_, validatorSlashEventsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ValidatorSlashEvents)
                                   messageName:@"ValidatorSlashEvents"
                               fileDescription:&DistributionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ValidatorSlashEvents__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FeePool

@implementation FeePool

@dynamic communityPoolArray, communityPoolArray_Count;

typedef struct FeePool__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *communityPoolArray;
} FeePool__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "communityPoolArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DecCoin),
        .number = FeePool_FieldNumber_CommunityPoolArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FeePool__storage_, communityPoolArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(FeePool)
                                   messageName:@"FeePool"
                               fileDescription:&DistributionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FeePool__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CommunityPoolSpendProposal

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-implementations"

@implementation CommunityPoolSpendProposal

@dynamic title;
@dynamic description_p;
@dynamic recipient;
@dynamic amountArray, amountArray_Count;

typedef struct CommunityPoolSpendProposal__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSString *description_p;
  NSString *recipient;
  NSMutableArray *amountArray;
} CommunityPoolSpendProposal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = CommunityPoolSpendProposal_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CommunityPoolSpendProposal__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = Nil,
        .number = CommunityPoolSpendProposal_FieldNumber_Description_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CommunityPoolSpendProposal__storage_, description_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "recipient",
        .dataTypeSpecific.clazz = Nil,
        .number = CommunityPoolSpendProposal_FieldNumber_Recipient,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CommunityPoolSpendProposal__storage_, recipient),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amountArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Coin),
        .number = CommunityPoolSpendProposal_FieldNumber_AmountArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CommunityPoolSpendProposal__storage_, amountArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CommunityPoolSpendProposal)
                                   messageName:@"CommunityPoolSpendProposal"
                               fileDescription:&DistributionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CommunityPoolSpendProposal__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma clang diagnostic pop

#pragma mark - DelegatorStartingInfo

@implementation DelegatorStartingInfo

@dynamic previousPeriod;
@dynamic stake;
@dynamic height;

typedef struct DelegatorStartingInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *stake;
  uint64_t previousPeriod;
  uint64_t height;
} DelegatorStartingInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "previousPeriod",
        .dataTypeSpecific.clazz = Nil,
        .number = DelegatorStartingInfo_FieldNumber_PreviousPeriod,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DelegatorStartingInfo__storage_, previousPeriod),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "stake",
        .dataTypeSpecific.clazz = Nil,
        .number = DelegatorStartingInfo_FieldNumber_Stake,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DelegatorStartingInfo__storage_, stake),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = DelegatorStartingInfo_FieldNumber_Height,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DelegatorStartingInfo__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DelegatorStartingInfo)
                                   messageName:@"DelegatorStartingInfo"
                               fileDescription:&DistributionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelegatorStartingInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DelegationDelegatorReward

@implementation DelegationDelegatorReward

@dynamic validatorAddress;
@dynamic rewardArray, rewardArray_Count;

typedef struct DelegationDelegatorReward__storage_ {
  uint32_t _has_storage_[1];
  NSString *validatorAddress;
  NSMutableArray *rewardArray;
} DelegationDelegatorReward__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "validatorAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = DelegationDelegatorReward_FieldNumber_ValidatorAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DelegationDelegatorReward__storage_, validatorAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rewardArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DecCoin),
        .number = DelegationDelegatorReward_FieldNumber_RewardArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DelegationDelegatorReward__storage_, rewardArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DelegationDelegatorReward)
                                   messageName:@"DelegationDelegatorReward"
                               fileDescription:&DistributionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelegationDelegatorReward__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CommunityPoolSpendProposalWithDeposit

@implementation CommunityPoolSpendProposalWithDeposit

@dynamic title;
@dynamic description_p;
@dynamic recipient;
@dynamic amount;
@dynamic deposit;

typedef struct CommunityPoolSpendProposalWithDeposit__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSString *description_p;
  NSString *recipient;
  NSString *amount;
  NSString *deposit;
} CommunityPoolSpendProposalWithDeposit__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = CommunityPoolSpendProposalWithDeposit_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CommunityPoolSpendProposalWithDeposit__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = Nil,
        .number = CommunityPoolSpendProposalWithDeposit_FieldNumber_Description_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CommunityPoolSpendProposalWithDeposit__storage_, description_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "recipient",
        .dataTypeSpecific.clazz = Nil,
        .number = CommunityPoolSpendProposalWithDeposit_FieldNumber_Recipient,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CommunityPoolSpendProposalWithDeposit__storage_, recipient),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = CommunityPoolSpendProposalWithDeposit_FieldNumber_Amount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CommunityPoolSpendProposalWithDeposit__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deposit",
        .dataTypeSpecific.clazz = Nil,
        .number = CommunityPoolSpendProposalWithDeposit_FieldNumber_Deposit,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CommunityPoolSpendProposalWithDeposit__storage_, deposit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CommunityPoolSpendProposalWithDeposit)
                                   messageName:@"CommunityPoolSpendProposalWithDeposit"
                               fileDescription:&DistributionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CommunityPoolSpendProposalWithDeposit__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
