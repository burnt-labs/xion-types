// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// clang-format off
// source: cosmos/tx/v1beta1/service.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import <stdatomic.h>

#import "cosmos/tx/v1beta1/Service.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Block);
GPBObjCClassDeclaration(BlockID);
GPBObjCClassDeclaration(BroadcastTxRequest);
GPBObjCClassDeclaration(BroadcastTxResponse);
GPBObjCClassDeclaration(GasInfo);
GPBObjCClassDeclaration(GetBlockWithTxsRequest);
GPBObjCClassDeclaration(GetBlockWithTxsResponse);
GPBObjCClassDeclaration(GetTxRequest);
GPBObjCClassDeclaration(GetTxResponse);
GPBObjCClassDeclaration(GetTxsEventRequest);
GPBObjCClassDeclaration(GetTxsEventResponse);
GPBObjCClassDeclaration(PageRequest);
GPBObjCClassDeclaration(PageResponse);
GPBObjCClassDeclaration(Result);
GPBObjCClassDeclaration(SimulateRequest);
GPBObjCClassDeclaration(SimulateResponse);
GPBObjCClassDeclaration(Tx);
GPBObjCClassDeclaration(TxDecodeAminoRequest);
GPBObjCClassDeclaration(TxDecodeAminoResponse);
GPBObjCClassDeclaration(TxDecodeRequest);
GPBObjCClassDeclaration(TxDecodeResponse);
GPBObjCClassDeclaration(TxEncodeAminoRequest);
GPBObjCClassDeclaration(TxEncodeAminoResponse);
GPBObjCClassDeclaration(TxEncodeRequest);
GPBObjCClassDeclaration(TxEncodeResponse);
GPBObjCClassDeclaration(TxResponse);

#pragma mark - ServiceRoot

@implementation ServiceRoot

// No extensions in the file and no imports or none of the imports (direct or
// indirect) defined extensions, so no need to generate +extensionRegistry.

@end

static GPBFileDescription ServiceRoot_FileDescription = {
  .package = "cosmos.tx.v1beta1",
  .prefix = NULL,
  .syntax = GPBFileSyntaxProto3
};

#pragma mark - Enum OrderBy

GPBEnumDescriptor *OrderBy_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "OrderByUnspecified\000OrderByAsc\000OrderByDes"
        "c\000";
    static const int32_t values[] = {
        OrderBy_OrderByUnspecified,
        OrderBy_OrderByAsc,
        OrderBy_OrderByDesc,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OrderBy)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OrderBy_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OrderBy_IsValidValue(int32_t value__) {
  switch (value__) {
    case OrderBy_OrderByUnspecified:
    case OrderBy_OrderByAsc:
    case OrderBy_OrderByDesc:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum BroadcastMode

GPBEnumDescriptor *BroadcastMode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "BroadcastModeUnspecified\000BroadcastModeBl"
        "ock\000BroadcastModeSync\000BroadcastModeAsync"
        "\000";
    static const int32_t values[] = {
        BroadcastMode_BroadcastModeUnspecified,
        BroadcastMode_BroadcastModeBlock,
        BroadcastMode_BroadcastModeSync,
        BroadcastMode_BroadcastModeAsync,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BroadcastMode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BroadcastMode_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BroadcastMode_IsValidValue(int32_t value__) {
  switch (value__) {
    case BroadcastMode_BroadcastModeUnspecified:
    case BroadcastMode_BroadcastModeBlock:
    case BroadcastMode_BroadcastModeSync:
    case BroadcastMode_BroadcastModeAsync:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GetTxsEventRequest

@implementation GetTxsEventRequest

@dynamic eventsArray, eventsArray_Count;
@dynamic hasPagination, pagination;
@dynamic orderBy;
@dynamic page;
@dynamic limit;
@dynamic query;

typedef struct GetTxsEventRequest__storage_ {
  uint32_t _has_storage_[1];
  OrderBy orderBy;
  NSMutableArray *eventsArray;
  PageRequest *pagination;
  NSString *query;
  uint64_t page;
  uint64_t limit;
} GetTxsEventRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eventsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GetTxsEventRequest_FieldNumber_EventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetTxsEventRequest__storage_, eventsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pagination",
        .dataTypeSpecific.clazz = GPBObjCClass(PageRequest),
        .number = GetTxsEventRequest_FieldNumber_Pagination,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetTxsEventRequest__storage_, pagination),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "orderBy",
        .dataTypeSpecific.enumDescFunc = OrderBy_EnumDescriptor,
        .number = GetTxsEventRequest_FieldNumber_OrderBy,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetTxsEventRequest__storage_, orderBy),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "page",
        .dataTypeSpecific.clazz = Nil,
        .number = GetTxsEventRequest_FieldNumber_Page,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetTxsEventRequest__storage_, page),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = GetTxsEventRequest_FieldNumber_Limit,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetTxsEventRequest__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "query",
        .dataTypeSpecific.clazz = Nil,
        .number = GetTxsEventRequest_FieldNumber_Query,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetTxsEventRequest__storage_, query),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetTxsEventRequest)
                                   messageName:@"GetTxsEventRequest"
                               fileDescription:&ServiceRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTxsEventRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GetTxsEventRequest_OrderBy_RawValue(GetTxsEventRequest *message) {
  GPBDescriptor *descriptor = [GetTxsEventRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetTxsEventRequest_FieldNumber_OrderBy];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGetTxsEventRequest_OrderBy_RawValue(GetTxsEventRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [GetTxsEventRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetTxsEventRequest_FieldNumber_OrderBy];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - GetTxsEventResponse

@implementation GetTxsEventResponse

@dynamic txsArray, txsArray_Count;
@dynamic txResponsesArray, txResponsesArray_Count;
@dynamic hasPagination, pagination;
@dynamic total;

typedef struct GetTxsEventResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *txsArray;
  NSMutableArray *txResponsesArray;
  PageResponse *pagination;
  uint64_t total;
} GetTxsEventResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Tx),
        .number = GetTxsEventResponse_FieldNumber_TxsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetTxsEventResponse__storage_, txsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "txResponsesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TxResponse),
        .number = GetTxsEventResponse_FieldNumber_TxResponsesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetTxsEventResponse__storage_, txResponsesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pagination",
        .dataTypeSpecific.clazz = GPBObjCClass(PageResponse),
        .number = GetTxsEventResponse_FieldNumber_Pagination,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetTxsEventResponse__storage_, pagination),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "total",
        .dataTypeSpecific.clazz = Nil,
        .number = GetTxsEventResponse_FieldNumber_Total,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetTxsEventResponse__storage_, total),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetTxsEventResponse)
                                   messageName:@"GetTxsEventResponse"
                               fileDescription:&ServiceRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTxsEventResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BroadcastTxRequest

@implementation BroadcastTxRequest

@dynamic txBytes;
@dynamic mode;

typedef struct BroadcastTxRequest__storage_ {
  uint32_t _has_storage_[1];
  BroadcastMode mode;
  NSData *txBytes;
} BroadcastTxRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txBytes",
        .dataTypeSpecific.clazz = Nil,
        .number = BroadcastTxRequest_FieldNumber_TxBytes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BroadcastTxRequest__storage_, txBytes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "mode",
        .dataTypeSpecific.enumDescFunc = BroadcastMode_EnumDescriptor,
        .number = BroadcastTxRequest_FieldNumber_Mode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BroadcastTxRequest__storage_, mode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BroadcastTxRequest)
                                   messageName:@"BroadcastTxRequest"
                               fileDescription:&ServiceRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BroadcastTxRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t BroadcastTxRequest_Mode_RawValue(BroadcastTxRequest *message) {
  GPBDescriptor *descriptor = [BroadcastTxRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BroadcastTxRequest_FieldNumber_Mode];
  return GPBGetMessageRawEnumField(message, field);
}

void SetBroadcastTxRequest_Mode_RawValue(BroadcastTxRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [BroadcastTxRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BroadcastTxRequest_FieldNumber_Mode];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - BroadcastTxResponse

@implementation BroadcastTxResponse

@dynamic hasTxResponse, txResponse;

typedef struct BroadcastTxResponse__storage_ {
  uint32_t _has_storage_[1];
  TxResponse *txResponse;
} BroadcastTxResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txResponse",
        .dataTypeSpecific.clazz = GPBObjCClass(TxResponse),
        .number = BroadcastTxResponse_FieldNumber_TxResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BroadcastTxResponse__storage_, txResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BroadcastTxResponse)
                                   messageName:@"BroadcastTxResponse"
                               fileDescription:&ServiceRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BroadcastTxResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SimulateRequest

@implementation SimulateRequest

@dynamic hasTx, tx;
@dynamic txBytes;

typedef struct SimulateRequest__storage_ {
  uint32_t _has_storage_[1];
  Tx *tx;
  NSData *txBytes;
} SimulateRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tx",
        .dataTypeSpecific.clazz = GPBObjCClass(Tx),
        .number = SimulateRequest_FieldNumber_Tx,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SimulateRequest__storage_, tx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "txBytes",
        .dataTypeSpecific.clazz = Nil,
        .number = SimulateRequest_FieldNumber_TxBytes,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SimulateRequest__storage_, txBytes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SimulateRequest)
                                   messageName:@"SimulateRequest"
                               fileDescription:&ServiceRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SimulateRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SimulateResponse

@implementation SimulateResponse

@dynamic hasGasInfo, gasInfo;
@dynamic hasResult, result;

typedef struct SimulateResponse__storage_ {
  uint32_t _has_storage_[1];
  GasInfo *gasInfo;
  Result *result;
} SimulateResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gasInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(GasInfo),
        .number = SimulateResponse_FieldNumber_GasInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SimulateResponse__storage_, gasInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "result",
        .dataTypeSpecific.clazz = GPBObjCClass(Result),
        .number = SimulateResponse_FieldNumber_Result,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SimulateResponse__storage_, result),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SimulateResponse)
                                   messageName:@"SimulateResponse"
                               fileDescription:&ServiceRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SimulateResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTxRequest

@implementation GetTxRequest

@dynamic hash_p;

typedef struct GetTxRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *hash_p;
} GetTxRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = GetTxRequest_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetTxRequest__storage_, hash_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetTxRequest)
                                   messageName:@"GetTxRequest"
                               fileDescription:&ServiceRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTxRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTxResponse

@implementation GetTxResponse

@dynamic hasTx, tx;
@dynamic hasTxResponse, txResponse;

typedef struct GetTxResponse__storage_ {
  uint32_t _has_storage_[1];
  Tx *tx;
  TxResponse *txResponse;
} GetTxResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tx",
        .dataTypeSpecific.clazz = GPBObjCClass(Tx),
        .number = GetTxResponse_FieldNumber_Tx,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetTxResponse__storage_, tx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "txResponse",
        .dataTypeSpecific.clazz = GPBObjCClass(TxResponse),
        .number = GetTxResponse_FieldNumber_TxResponse,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetTxResponse__storage_, txResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetTxResponse)
                                   messageName:@"GetTxResponse"
                               fileDescription:&ServiceRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTxResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBlockWithTxsRequest

@implementation GetBlockWithTxsRequest

@dynamic height;
@dynamic hasPagination, pagination;

typedef struct GetBlockWithTxsRequest__storage_ {
  uint32_t _has_storage_[1];
  PageRequest *pagination;
  int64_t height;
} GetBlockWithTxsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = GetBlockWithTxsRequest_FieldNumber_Height,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetBlockWithTxsRequest__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pagination",
        .dataTypeSpecific.clazz = GPBObjCClass(PageRequest),
        .number = GetBlockWithTxsRequest_FieldNumber_Pagination,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetBlockWithTxsRequest__storage_, pagination),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetBlockWithTxsRequest)
                                   messageName:@"GetBlockWithTxsRequest"
                               fileDescription:&ServiceRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockWithTxsRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBlockWithTxsResponse

@implementation GetBlockWithTxsResponse

@dynamic txsArray, txsArray_Count;
@dynamic hasBlockId, blockId;
@dynamic hasBlock, block;
@dynamic hasPagination, pagination;

typedef struct GetBlockWithTxsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *txsArray;
  BlockID *blockId;
  Block *block;
  PageResponse *pagination;
} GetBlockWithTxsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Tx),
        .number = GetBlockWithTxsResponse_FieldNumber_TxsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetBlockWithTxsResponse__storage_, txsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockId",
        .dataTypeSpecific.clazz = GPBObjCClass(BlockID),
        .number = GetBlockWithTxsResponse_FieldNumber_BlockId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetBlockWithTxsResponse__storage_, blockId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "block",
        .dataTypeSpecific.clazz = GPBObjCClass(Block),
        .number = GetBlockWithTxsResponse_FieldNumber_Block,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetBlockWithTxsResponse__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pagination",
        .dataTypeSpecific.clazz = GPBObjCClass(PageResponse),
        .number = GetBlockWithTxsResponse_FieldNumber_Pagination,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetBlockWithTxsResponse__storage_, pagination),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetBlockWithTxsResponse)
                                   messageName:@"GetBlockWithTxsResponse"
                               fileDescription:&ServiceRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockWithTxsResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TxDecodeRequest

@implementation TxDecodeRequest

@dynamic txBytes;

typedef struct TxDecodeRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *txBytes;
} TxDecodeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txBytes",
        .dataTypeSpecific.clazz = Nil,
        .number = TxDecodeRequest_FieldNumber_TxBytes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TxDecodeRequest__storage_, txBytes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TxDecodeRequest)
                                   messageName:@"TxDecodeRequest"
                               fileDescription:&ServiceRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxDecodeRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TxDecodeResponse

@implementation TxDecodeResponse

@dynamic hasTx, tx;

typedef struct TxDecodeResponse__storage_ {
  uint32_t _has_storage_[1];
  Tx *tx;
} TxDecodeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tx",
        .dataTypeSpecific.clazz = GPBObjCClass(Tx),
        .number = TxDecodeResponse_FieldNumber_Tx,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TxDecodeResponse__storage_, tx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TxDecodeResponse)
                                   messageName:@"TxDecodeResponse"
                               fileDescription:&ServiceRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxDecodeResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TxEncodeRequest

@implementation TxEncodeRequest

@dynamic hasTx, tx;

typedef struct TxEncodeRequest__storage_ {
  uint32_t _has_storage_[1];
  Tx *tx;
} TxEncodeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tx",
        .dataTypeSpecific.clazz = GPBObjCClass(Tx),
        .number = TxEncodeRequest_FieldNumber_Tx,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TxEncodeRequest__storage_, tx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TxEncodeRequest)
                                   messageName:@"TxEncodeRequest"
                               fileDescription:&ServiceRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxEncodeRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TxEncodeResponse

@implementation TxEncodeResponse

@dynamic txBytes;

typedef struct TxEncodeResponse__storage_ {
  uint32_t _has_storage_[1];
  NSData *txBytes;
} TxEncodeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txBytes",
        .dataTypeSpecific.clazz = Nil,
        .number = TxEncodeResponse_FieldNumber_TxBytes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TxEncodeResponse__storage_, txBytes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TxEncodeResponse)
                                   messageName:@"TxEncodeResponse"
                               fileDescription:&ServiceRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxEncodeResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TxEncodeAminoRequest

@implementation TxEncodeAminoRequest

@dynamic aminoJson;

typedef struct TxEncodeAminoRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *aminoJson;
} TxEncodeAminoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "aminoJson",
        .dataTypeSpecific.clazz = Nil,
        .number = TxEncodeAminoRequest_FieldNumber_AminoJson,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TxEncodeAminoRequest__storage_, aminoJson),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TxEncodeAminoRequest)
                                   messageName:@"TxEncodeAminoRequest"
                               fileDescription:&ServiceRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxEncodeAminoRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TxEncodeAminoResponse

@implementation TxEncodeAminoResponse

@dynamic aminoBinary;

typedef struct TxEncodeAminoResponse__storage_ {
  uint32_t _has_storage_[1];
  NSData *aminoBinary;
} TxEncodeAminoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "aminoBinary",
        .dataTypeSpecific.clazz = Nil,
        .number = TxEncodeAminoResponse_FieldNumber_AminoBinary,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TxEncodeAminoResponse__storage_, aminoBinary),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TxEncodeAminoResponse)
                                   messageName:@"TxEncodeAminoResponse"
                               fileDescription:&ServiceRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxEncodeAminoResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TxDecodeAminoRequest

@implementation TxDecodeAminoRequest

@dynamic aminoBinary;

typedef struct TxDecodeAminoRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *aminoBinary;
} TxDecodeAminoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "aminoBinary",
        .dataTypeSpecific.clazz = Nil,
        .number = TxDecodeAminoRequest_FieldNumber_AminoBinary,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TxDecodeAminoRequest__storage_, aminoBinary),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TxDecodeAminoRequest)
                                   messageName:@"TxDecodeAminoRequest"
                               fileDescription:&ServiceRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxDecodeAminoRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TxDecodeAminoResponse

@implementation TxDecodeAminoResponse

@dynamic aminoJson;

typedef struct TxDecodeAminoResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *aminoJson;
} TxDecodeAminoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "aminoJson",
        .dataTypeSpecific.clazz = Nil,
        .number = TxDecodeAminoResponse_FieldNumber_AminoJson,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TxDecodeAminoResponse__storage_, aminoJson),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TxDecodeAminoResponse)
                                   messageName:@"TxDecodeAminoResponse"
                               fileDescription:&ServiceRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxDecodeAminoResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
