// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// clang-format off
// source: cosmos/tx/v1beta1/tx.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import "cosmos/tx/v1beta1/Tx.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(AuthInfo);
GPBObjCClassDeclaration(AuxSignerData);
GPBObjCClassDeclaration(Coin);
GPBObjCClassDeclaration(CompactBitArray);
GPBObjCClassDeclaration(Fee);
GPBObjCClassDeclaration(GPBAny);
GPBObjCClassDeclaration(GPBTimestamp);
GPBObjCClassDeclaration(ModeInfo);
GPBObjCClassDeclaration(ModeInfo_Multi);
GPBObjCClassDeclaration(ModeInfo_Single);
GPBObjCClassDeclaration(SignDoc);
GPBObjCClassDeclaration(SignDocDirectAux);
GPBObjCClassDeclaration(SignerInfo);
GPBObjCClassDeclaration(Tip);
GPBObjCClassDeclaration(Tx);
GPBObjCClassDeclaration(TxBody);
GPBObjCClassDeclaration(TxRaw);

#pragma mark - TxRoot

@implementation TxRoot

// No extensions in the file and no imports or none of the imports (direct or
// indirect) defined extensions, so no need to generate +extensionRegistry.

@end

static GPBFileDescription TxRoot_FileDescription = {
  .package = "cosmos.tx.v1beta1",
  .prefix = NULL,
  .syntax = GPBFileSyntaxProto3
};

#pragma mark - Tx

@implementation Tx

@dynamic hasBody, body;
@dynamic hasAuthInfo, authInfo;
@dynamic signaturesArray, signaturesArray_Count;

typedef struct Tx__storage_ {
  uint32_t _has_storage_[1];
  TxBody *body;
  AuthInfo *authInfo;
  NSMutableArray *signaturesArray;
} Tx__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "body",
        .dataTypeSpecific.clazz = GPBObjCClass(TxBody),
        .number = Tx_FieldNumber_Body,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Tx__storage_, body),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "authInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(AuthInfo),
        .number = Tx_FieldNumber_AuthInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Tx__storage_, authInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signaturesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Tx_FieldNumber_SignaturesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Tx__storage_, signaturesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Tx)
                                   messageName:@"Tx"
                               fileDescription:&TxRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Tx__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TxRaw

@implementation TxRaw

@dynamic bodyBytes;
@dynamic authInfoBytes;
@dynamic signaturesArray, signaturesArray_Count;

typedef struct TxRaw__storage_ {
  uint32_t _has_storage_[1];
  NSData *bodyBytes;
  NSData *authInfoBytes;
  NSMutableArray *signaturesArray;
} TxRaw__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bodyBytes",
        .dataTypeSpecific.clazz = Nil,
        .number = TxRaw_FieldNumber_BodyBytes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TxRaw__storage_, bodyBytes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "authInfoBytes",
        .dataTypeSpecific.clazz = Nil,
        .number = TxRaw_FieldNumber_AuthInfoBytes,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TxRaw__storage_, authInfoBytes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signaturesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = TxRaw_FieldNumber_SignaturesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TxRaw__storage_, signaturesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TxRaw)
                                   messageName:@"TxRaw"
                               fileDescription:&TxRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxRaw__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SignDoc

@implementation SignDoc

@dynamic bodyBytes;
@dynamic authInfoBytes;
@dynamic chainId;
@dynamic accountNumber;

typedef struct SignDoc__storage_ {
  uint32_t _has_storage_[1];
  NSData *bodyBytes;
  NSData *authInfoBytes;
  NSString *chainId;
  uint64_t accountNumber;
} SignDoc__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bodyBytes",
        .dataTypeSpecific.clazz = Nil,
        .number = SignDoc_FieldNumber_BodyBytes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignDoc__storage_, bodyBytes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "authInfoBytes",
        .dataTypeSpecific.clazz = Nil,
        .number = SignDoc_FieldNumber_AuthInfoBytes,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SignDoc__storage_, authInfoBytes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "chainId",
        .dataTypeSpecific.clazz = Nil,
        .number = SignDoc_FieldNumber_ChainId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SignDoc__storage_, chainId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "accountNumber",
        .dataTypeSpecific.clazz = Nil,
        .number = SignDoc_FieldNumber_AccountNumber,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SignDoc__storage_, accountNumber),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SignDoc)
                                   messageName:@"SignDoc"
                               fileDescription:&TxRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignDoc__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SignDocDirectAux

@implementation SignDocDirectAux

@dynamic bodyBytes;
@dynamic hasPublicKey, publicKey;
@dynamic chainId;
@dynamic accountNumber;
@dynamic sequence;
@dynamic hasTip, tip;

typedef struct SignDocDirectAux__storage_ {
  uint32_t _has_storage_[1];
  NSData *bodyBytes;
  GPBAny *publicKey;
  NSString *chainId;
  Tip *tip;
  uint64_t accountNumber;
  uint64_t sequence;
} SignDocDirectAux__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bodyBytes",
        .dataTypeSpecific.clazz = Nil,
        .number = SignDocDirectAux_FieldNumber_BodyBytes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignDocDirectAux__storage_, bodyBytes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "publicKey",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBAny),
        .number = SignDocDirectAux_FieldNumber_PublicKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SignDocDirectAux__storage_, publicKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chainId",
        .dataTypeSpecific.clazz = Nil,
        .number = SignDocDirectAux_FieldNumber_ChainId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SignDocDirectAux__storage_, chainId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "accountNumber",
        .dataTypeSpecific.clazz = Nil,
        .number = SignDocDirectAux_FieldNumber_AccountNumber,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SignDocDirectAux__storage_, accountNumber),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "sequence",
        .dataTypeSpecific.clazz = Nil,
        .number = SignDocDirectAux_FieldNumber_Sequence,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SignDocDirectAux__storage_, sequence),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "tip",
        .dataTypeSpecific.clazz = GPBObjCClass(Tip),
        .number = SignDocDirectAux_FieldNumber_Tip,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SignDocDirectAux__storage_, tip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SignDocDirectAux)
                                   messageName:@"SignDocDirectAux"
                               fileDescription:&TxRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignDocDirectAux__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TxBody

@implementation TxBody

@dynamic messagesArray, messagesArray_Count;
@dynamic memo;
@dynamic timeoutHeight;
@dynamic unordered;
@dynamic hasTimeoutTimestamp, timeoutTimestamp;
@dynamic extensionOptionsArray, extensionOptionsArray_Count;
@dynamic nonCriticalExtensionOptionsArray, nonCriticalExtensionOptionsArray_Count;

typedef struct TxBody__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *messagesArray;
  NSString *memo;
  GPBTimestamp *timeoutTimestamp;
  NSMutableArray *extensionOptionsArray;
  NSMutableArray *nonCriticalExtensionOptionsArray;
  uint64_t timeoutHeight;
} TxBody__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messagesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBAny),
        .number = TxBody_FieldNumber_MessagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TxBody__storage_, messagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "memo",
        .dataTypeSpecific.clazz = Nil,
        .number = TxBody_FieldNumber_Memo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TxBody__storage_, memo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeoutHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = TxBody_FieldNumber_TimeoutHeight,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TxBody__storage_, timeoutHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "unordered",
        .dataTypeSpecific.clazz = Nil,
        .number = TxBody_FieldNumber_Unordered,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "timeoutTimestamp",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = TxBody_FieldNumber_TimeoutTimestamp,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TxBody__storage_, timeoutTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extensionOptionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBAny),
        .number = TxBody_FieldNumber_ExtensionOptionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TxBody__storage_, extensionOptionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nonCriticalExtensionOptionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBAny),
        .number = TxBody_FieldNumber_NonCriticalExtensionOptionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TxBody__storage_, nonCriticalExtensionOptionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TxBody)
                                   messageName:@"TxBody"
                               fileDescription:&TxRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxBody__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AuthInfo

@implementation AuthInfo

@dynamic signerInfosArray, signerInfosArray_Count;
@dynamic hasFee, fee;
@dynamic hasTip, tip;

typedef struct AuthInfo__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *signerInfosArray;
  Fee *fee;
  Tip *tip;
} AuthInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "signerInfosArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SignerInfo),
        .number = AuthInfo_FieldNumber_SignerInfosArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AuthInfo__storage_, signerInfosArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fee",
        .dataTypeSpecific.clazz = GPBObjCClass(Fee),
        .number = AuthInfo_FieldNumber_Fee,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AuthInfo__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tip",
        .dataTypeSpecific.clazz = GPBObjCClass(Tip),
        .number = AuthInfo_FieldNumber_Tip,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AuthInfo__storage_, tip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(AuthInfo)
                                   messageName:@"AuthInfo"
                               fileDescription:&TxRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SignerInfo

@implementation SignerInfo

@dynamic hasPublicKey, publicKey;
@dynamic hasModeInfo, modeInfo;
@dynamic sequence;

typedef struct SignerInfo__storage_ {
  uint32_t _has_storage_[1];
  GPBAny *publicKey;
  ModeInfo *modeInfo;
  uint64_t sequence;
} SignerInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "publicKey",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBAny),
        .number = SignerInfo_FieldNumber_PublicKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignerInfo__storage_, publicKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "modeInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(ModeInfo),
        .number = SignerInfo_FieldNumber_ModeInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SignerInfo__storage_, modeInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sequence",
        .dataTypeSpecific.clazz = Nil,
        .number = SignerInfo_FieldNumber_Sequence,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SignerInfo__storage_, sequence),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SignerInfo)
                                   messageName:@"SignerInfo"
                               fileDescription:&TxRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignerInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModeInfo

@implementation ModeInfo

@dynamic sumOneOfCase;
@dynamic single;
@dynamic multi;

typedef struct ModeInfo__storage_ {
  uint32_t _has_storage_[2];
  ModeInfo_Single *single;
  ModeInfo_Multi *multi;
} ModeInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "single",
        .dataTypeSpecific.clazz = GPBObjCClass(ModeInfo_Single),
        .number = ModeInfo_FieldNumber_Single,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ModeInfo__storage_, single),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "multi",
        .dataTypeSpecific.clazz = GPBObjCClass(ModeInfo_Multi),
        .number = ModeInfo_FieldNumber_Multi,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ModeInfo__storage_, multi),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ModeInfo)
                                   messageName:@"ModeInfo"
                               fileDescription:&TxRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModeInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    static const char *oneofs[] = {
      "sum",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ModeInfo_ClearSumOneOfCase(ModeInfo *message) {
  GPBDescriptor *descriptor = [ModeInfo descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - ModeInfo_Single

@implementation ModeInfo_Single

@dynamic mode;

typedef struct ModeInfo_Single__storage_ {
  uint32_t _has_storage_[1];
  SignMode mode;
} ModeInfo_Single__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mode",
        .dataTypeSpecific.enumDescFunc = SignMode_EnumDescriptor,
        .number = ModeInfo_Single_FieldNumber_Mode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModeInfo_Single__storage_, mode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ModeInfo_Single)
                                   messageName:@"Single"
                               fileDescription:&TxRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModeInfo_Single__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ModeInfo)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ModeInfo_Single_Mode_RawValue(ModeInfo_Single *message) {
  GPBDescriptor *descriptor = [ModeInfo_Single descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ModeInfo_Single_FieldNumber_Mode];
  return GPBGetMessageRawEnumField(message, field);
}

void SetModeInfo_Single_Mode_RawValue(ModeInfo_Single *message, int32_t value) {
  GPBDescriptor *descriptor = [ModeInfo_Single descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ModeInfo_Single_FieldNumber_Mode];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ModeInfo_Multi

@implementation ModeInfo_Multi

@dynamic hasBitarray, bitarray;
@dynamic modeInfosArray, modeInfosArray_Count;

typedef struct ModeInfo_Multi__storage_ {
  uint32_t _has_storage_[1];
  CompactBitArray *bitarray;
  NSMutableArray *modeInfosArray;
} ModeInfo_Multi__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bitarray",
        .dataTypeSpecific.clazz = GPBObjCClass(CompactBitArray),
        .number = ModeInfo_Multi_FieldNumber_Bitarray,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModeInfo_Multi__storage_, bitarray),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "modeInfosArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ModeInfo),
        .number = ModeInfo_Multi_FieldNumber_ModeInfosArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ModeInfo_Multi__storage_, modeInfosArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ModeInfo_Multi)
                                   messageName:@"Multi"
                               fileDescription:&TxRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModeInfo_Multi__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(ModeInfo)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Fee

@implementation Fee

@dynamic amountArray, amountArray_Count;
@dynamic gasLimit;
@dynamic payer;
@dynamic granter;

typedef struct Fee__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *amountArray;
  NSString *payer;
  NSString *granter;
  uint64_t gasLimit;
} Fee__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "amountArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Coin),
        .number = Fee_FieldNumber_AmountArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Fee__storage_, amountArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gasLimit",
        .dataTypeSpecific.clazz = Nil,
        .number = Fee_FieldNumber_GasLimit,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Fee__storage_, gasLimit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "payer",
        .dataTypeSpecific.clazz = Nil,
        .number = Fee_FieldNumber_Payer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Fee__storage_, payer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "granter",
        .dataTypeSpecific.clazz = Nil,
        .number = Fee_FieldNumber_Granter,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Fee__storage_, granter),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Fee)
                                   messageName:@"Fee"
                               fileDescription:&TxRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Fee__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Tip

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-implementations"

@implementation Tip

@dynamic amountArray, amountArray_Count;
@dynamic tipper;

typedef struct Tip__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *amountArray;
  NSString *tipper;
} Tip__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "amountArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Coin),
        .number = Tip_FieldNumber_AmountArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Tip__storage_, amountArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tipper",
        .dataTypeSpecific.clazz = Nil,
        .number = Tip_FieldNumber_Tipper,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Tip__storage_, tipper),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Tip)
                                   messageName:@"Tip"
                               fileDescription:&TxRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Tip__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma clang diagnostic pop

#pragma mark - AuxSignerData

@implementation AuxSignerData

@dynamic address;
@dynamic hasSignDoc, signDoc;
@dynamic mode;
@dynamic sig;

typedef struct AuxSignerData__storage_ {
  uint32_t _has_storage_[1];
  SignMode mode;
  NSString *address;
  SignDocDirectAux *signDoc;
  NSData *sig;
} AuxSignerData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = AuxSignerData_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AuxSignerData__storage_, address),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signDoc",
        .dataTypeSpecific.clazz = GPBObjCClass(SignDocDirectAux),
        .number = AuxSignerData_FieldNumber_SignDoc,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AuxSignerData__storage_, signDoc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mode",
        .dataTypeSpecific.enumDescFunc = SignMode_EnumDescriptor,
        .number = AuxSignerData_FieldNumber_Mode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AuxSignerData__storage_, mode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sig",
        .dataTypeSpecific.clazz = Nil,
        .number = AuxSignerData_FieldNumber_Sig,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AuxSignerData__storage_, sig),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(AuxSignerData)
                                   messageName:@"AuxSignerData"
                               fileDescription:&TxRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuxSignerData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AuxSignerData_Mode_RawValue(AuxSignerData *message) {
  GPBDescriptor *descriptor = [AuxSignerData descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AuxSignerData_FieldNumber_Mode];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAuxSignerData_Mode_RawValue(AuxSignerData *message, int32_t value) {
  GPBDescriptor *descriptor = [AuxSignerData descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AuxSignerData_FieldNumber_Mode];
  GPBSetMessageRawEnumField(message, field, value);
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
