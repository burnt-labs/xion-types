// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// clang-format off
// source: cosmos/tx/v1beta1/tx.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers.h>
#else
 #import "GPBProtocolBuffers.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import "cosmos/crypto/multisig/v1beta1/Multisig.pbobjc.h"
#import "cosmos/base/v1beta1/Coin.pbobjc.h"
#import "cosmos/tx/signing/v1beta1/Signing.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

CF_EXTERN_C_BEGIN

@class AuthInfo;
@class Fee;
@class ModeInfo;
@class ModeInfo_Multi;
@class ModeInfo_Single;
@class SignDocDirectAux;
@class SignerInfo;
@class Tip;
@class TxBody;

NS_ASSUME_NONNULL_BEGIN

#pragma mark - TxRoot

/**
 * Exposes the extension registry for this file.
 *
 * The base class provides:
 * @code
 *   + (GPBExtensionRegistry *)extensionRegistry;
 * @endcode
 * which is a @c GPBExtensionRegistry that includes all the extensions defined by
 * this file and all files that it depends on.
 **/
GPB_FINAL @interface TxRoot : GPBRootObject
@end

#pragma mark - Tx

typedef GPB_ENUM(Tx_FieldNumber) {
  Tx_FieldNumber_Body = 1,
  Tx_FieldNumber_AuthInfo = 2,
  Tx_FieldNumber_SignaturesArray = 3,
};

/**
 * Tx is the standard type used for broadcasting transactions.
 **/
GPB_FINAL @interface Tx : GPBMessage

/** body is the processable content of the transaction */
@property(nonatomic, readwrite, strong, null_resettable) TxBody *body;
/** Test to see if @c body has been set. */
@property(nonatomic, readwrite) BOOL hasBody;

/**
 * auth_info is the authorization related content of the transaction,
 * specifically signers, signer modes and fee
 **/
@property(nonatomic, readwrite, strong, null_resettable) AuthInfo *authInfo;
/** Test to see if @c authInfo has been set. */
@property(nonatomic, readwrite) BOOL hasAuthInfo;

/**
 * signatures is a list of signatures that matches the length and order of
 * AuthInfo's signer_infos to allow connecting signature meta information like
 * public key and signing mode by position.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NSData*> *signaturesArray;
/** The number of items in @c signaturesArray without causing the container to be created. */
@property(nonatomic, readonly) NSUInteger signaturesArray_Count;

@end

#pragma mark - TxRaw

typedef GPB_ENUM(TxRaw_FieldNumber) {
  TxRaw_FieldNumber_BodyBytes = 1,
  TxRaw_FieldNumber_AuthInfoBytes = 2,
  TxRaw_FieldNumber_SignaturesArray = 3,
};

/**
 * TxRaw is a variant of Tx that pins the signer's exact binary representation
 * of body and auth_info. This is used for signing, broadcasting and
 * verification. The binary `serialize(tx: TxRaw)` is stored in Tendermint and
 * the hash `sha256(serialize(tx: TxRaw))` becomes the "txhash", commonly used
 * as the transaction ID.
 **/
GPB_FINAL @interface TxRaw : GPBMessage

/**
 * body_bytes is a protobuf serialization of a TxBody that matches the
 * representation in SignDoc.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *bodyBytes;

/**
 * auth_info_bytes is a protobuf serialization of an AuthInfo that matches the
 * representation in SignDoc.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *authInfoBytes;

/**
 * signatures is a list of signatures that matches the length and order of
 * AuthInfo's signer_infos to allow connecting signature meta information like
 * public key and signing mode by position.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NSData*> *signaturesArray;
/** The number of items in @c signaturesArray without causing the container to be created. */
@property(nonatomic, readonly) NSUInteger signaturesArray_Count;

@end

#pragma mark - SignDoc

typedef GPB_ENUM(SignDoc_FieldNumber) {
  SignDoc_FieldNumber_BodyBytes = 1,
  SignDoc_FieldNumber_AuthInfoBytes = 2,
  SignDoc_FieldNumber_ChainId = 3,
  SignDoc_FieldNumber_AccountNumber = 4,
};

/**
 * SignDoc is the type used for generating sign bytes for SIGN_MODE_DIRECT.
 **/
GPB_FINAL @interface SignDoc : GPBMessage

/**
 * body_bytes is protobuf serialization of a TxBody that matches the
 * representation in TxRaw.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *bodyBytes;

/**
 * auth_info_bytes is a protobuf serialization of an AuthInfo that matches the
 * representation in TxRaw.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *authInfoBytes;

/**
 * chain_id is the unique identifier of the chain this transaction targets.
 * It prevents signed transactions from being used on another chain by an
 * attacker
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *chainId;

/** account_number is the account number of the account in state */
@property(nonatomic, readwrite) uint64_t accountNumber;

@end

#pragma mark - SignDocDirectAux

typedef GPB_ENUM(SignDocDirectAux_FieldNumber) {
  SignDocDirectAux_FieldNumber_BodyBytes = 1,
  SignDocDirectAux_FieldNumber_PublicKey = 2,
  SignDocDirectAux_FieldNumber_ChainId = 3,
  SignDocDirectAux_FieldNumber_AccountNumber = 4,
  SignDocDirectAux_FieldNumber_Sequence = 5,
  SignDocDirectAux_FieldNumber_Tip = 6,
};

/**
 * SignDocDirectAux is the type used for generating sign bytes for
 * SIGN_MODE_DIRECT_AUX.
 **/
GPB_FINAL @interface SignDocDirectAux : GPBMessage

/**
 * body_bytes is protobuf serialization of a TxBody that matches the
 * representation in TxRaw.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *bodyBytes;

/** public_key is the public key of the signing account. */
@property(nonatomic, readwrite, strong, null_resettable) GPBAny *publicKey;
/** Test to see if @c publicKey has been set. */
@property(nonatomic, readwrite) BOOL hasPublicKey;

/**
 * chain_id is the identifier of the chain this transaction targets.
 * It prevents signed transactions from being used on another chain by an
 * attacker.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *chainId;

/** account_number is the account number of the account in state. */
@property(nonatomic, readwrite) uint64_t accountNumber;

/** sequence is the sequence number of the signing account. */
@property(nonatomic, readwrite) uint64_t sequence;

/** tips have been depreacted and should not be used */
@property(nonatomic, readwrite, strong, null_resettable) Tip *tip GPB_DEPRECATED_MSG("cosmos.tx.v1beta1.SignDocDirectAux.tip is deprecated (see cosmos/tx/v1beta1/tx.proto).");
/** Test to see if @c tip has been set. */
@property(nonatomic, readwrite) BOOL hasTip GPB_DEPRECATED_MSG("cosmos.tx.v1beta1.SignDocDirectAux.tip is deprecated (see cosmos/tx/v1beta1/tx.proto).");

@end

#pragma mark - TxBody

typedef GPB_ENUM(TxBody_FieldNumber) {
  TxBody_FieldNumber_MessagesArray = 1,
  TxBody_FieldNumber_Memo = 2,
  TxBody_FieldNumber_TimeoutHeight = 3,
  TxBody_FieldNumber_Unordered = 4,
  TxBody_FieldNumber_TimeoutTimestamp = 5,
  TxBody_FieldNumber_ExtensionOptionsArray = 1023,
  TxBody_FieldNumber_NonCriticalExtensionOptionsArray = 2047,
};

/**
 * TxBody is the body of a transaction that all signers sign over.
 **/
GPB_FINAL @interface TxBody : GPBMessage

/**
 * messages is a list of messages to be executed. The required signers of
 * those messages define the number and order of elements in AuthInfo's
 * signer_infos and Tx's signatures. Each required signer address is added to
 * the list only the first time it occurs.
 * By convention, the first required signer (usually from the first message)
 * is referred to as the primary signer and pays the fee for the whole
 * transaction.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<GPBAny*> *messagesArray;
/** The number of items in @c messagesArray without causing the container to be created. */
@property(nonatomic, readonly) NSUInteger messagesArray_Count;

/**
 * memo is any arbitrary note/comment to be added to the transaction.
 * WARNING: in clients, any publicly exposed text should not be called memo,
 * but should be called `note` instead (see
 * https://github.com/cosmos/cosmos-sdk/issues/9122).
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *memo;

/**
 * timeout_height is the block height after which this transaction will not
 * be processed by the chain.
 **/
@property(nonatomic, readwrite) uint64_t timeoutHeight;

/**
 * unordered, when set to true, indicates that the transaction signer(s)
 * intend for the transaction to be evaluated and executed in an un-ordered
 * fashion. Specifically, the account's nonce will NOT be checked or
 * incremented, which allows for fire-and-forget as well as concurrent
 * transaction execution.
 *
 * Note, when set to true, the existing 'timeout_timestamp' value must
 * be set and will be used to correspond to a timestamp in which the transaction is deemed
 * valid.
 *
 * When true, the sequence value MUST be 0, and any transaction with unordered=true and a non-zero sequence value will
 * be rejected.
 * External services that make assumptions about sequence values may need to be updated because of this.
 **/
@property(nonatomic, readwrite) BOOL unordered;

/**
 * timeout_timestamp is the block time after which this transaction will not
 * be processed by the chain.
 *
 * Note, if unordered=true this value MUST be set
 * and will act as a short-lived TTL in which the transaction is deemed valid
 * and kept in memory to prevent duplicates.
 **/
@property(nonatomic, readwrite, strong, null_resettable) GPBTimestamp *timeoutTimestamp;
/** Test to see if @c timeoutTimestamp has been set. */
@property(nonatomic, readwrite) BOOL hasTimeoutTimestamp;

/**
 * extension_options are arbitrary options that can be added by chains
 * when the default options are not sufficient. If any of these are present
 * and can't be handled, the transaction will be rejected
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<GPBAny*> *extensionOptionsArray;
/** The number of items in @c extensionOptionsArray without causing the container to be created. */
@property(nonatomic, readonly) NSUInteger extensionOptionsArray_Count;

/**
 * extension_options are arbitrary options that can be added by chains
 * when the default options are not sufficient. If any of these are present
 * and can't be handled, they will be ignored
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<GPBAny*> *nonCriticalExtensionOptionsArray;
/** The number of items in @c nonCriticalExtensionOptionsArray without causing the container to be created. */
@property(nonatomic, readonly) NSUInteger nonCriticalExtensionOptionsArray_Count;

@end

#pragma mark - AuthInfo

typedef GPB_ENUM(AuthInfo_FieldNumber) {
  AuthInfo_FieldNumber_SignerInfosArray = 1,
  AuthInfo_FieldNumber_Fee = 2,
  AuthInfo_FieldNumber_Tip = 3,
};

/**
 * AuthInfo describes the fee and signer modes that are used to sign a
 * transaction.
 **/
GPB_FINAL @interface AuthInfo : GPBMessage

/**
 * signer_infos defines the signing modes for the required signers. The number
 * and order of elements must match the required signers from TxBody's
 * messages. The first element is the primary signer and the one which pays
 * the fee.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<SignerInfo*> *signerInfosArray;
/** The number of items in @c signerInfosArray without causing the container to be created. */
@property(nonatomic, readonly) NSUInteger signerInfosArray_Count;

/**
 * Fee is the fee and gas limit for the transaction. The first signer is the
 * primary signer and the one which pays the fee. The fee can be calculated
 * based on the cost of evaluating the body and doing signature verification
 * of the signers. This can be estimated via simulation.
 **/
@property(nonatomic, readwrite, strong, null_resettable) Fee *fee;
/** Test to see if @c fee has been set. */
@property(nonatomic, readwrite) BOOL hasFee;

/**
 * Tip is the optional tip used for transactions fees paid in another denom.
 *
 * This field is ignored if the chain didn't enable tips, i.e. didn't add the
 * `TipDecorator` in its posthandler.
 **/
@property(nonatomic, readwrite, strong, null_resettable) Tip *tip GPB_DEPRECATED_MSG("cosmos.tx.v1beta1.AuthInfo.tip is deprecated (see cosmos/tx/v1beta1/tx.proto).");
/** Test to see if @c tip has been set. */
@property(nonatomic, readwrite) BOOL hasTip GPB_DEPRECATED_MSG("cosmos.tx.v1beta1.AuthInfo.tip is deprecated (see cosmos/tx/v1beta1/tx.proto).");

@end

#pragma mark - SignerInfo

typedef GPB_ENUM(SignerInfo_FieldNumber) {
  SignerInfo_FieldNumber_PublicKey = 1,
  SignerInfo_FieldNumber_ModeInfo = 2,
  SignerInfo_FieldNumber_Sequence = 3,
};

/**
 * SignerInfo describes the public key and signing mode of a single top-level
 * signer.
 **/
GPB_FINAL @interface SignerInfo : GPBMessage

/**
 * public_key is the public key of the signer. It is optional for accounts
 * that already exist in state. If unset, the verifier can use the required \\
 * signer address for this position and lookup the public key.
 **/
@property(nonatomic, readwrite, strong, null_resettable) GPBAny *publicKey;
/** Test to see if @c publicKey has been set. */
@property(nonatomic, readwrite) BOOL hasPublicKey;

/**
 * mode_info describes the signing mode of the signer and is a nested
 * structure to support nested multisig pubkey's
 **/
@property(nonatomic, readwrite, strong, null_resettable) ModeInfo *modeInfo;
/** Test to see if @c modeInfo has been set. */
@property(nonatomic, readwrite) BOOL hasModeInfo;

/**
 * sequence is the sequence of the account, which describes the
 * number of committed transactions signed by a given address. It is used to
 * prevent replay attacks.
 **/
@property(nonatomic, readwrite) uint64_t sequence;

@end

#pragma mark - ModeInfo

typedef GPB_ENUM(ModeInfo_FieldNumber) {
  ModeInfo_FieldNumber_Single = 1,
  ModeInfo_FieldNumber_Multi = 2,
};

typedef GPB_ENUM(ModeInfo_Sum_OneOfCase) {
  ModeInfo_Sum_OneOfCase_GPBUnsetOneOfCase = 0,
  ModeInfo_Sum_OneOfCase_Single = 1,
  ModeInfo_Sum_OneOfCase_Multi = 2,
};

/**
 * ModeInfo describes the signing mode of a single or nested multisig signer.
 **/
GPB_FINAL @interface ModeInfo : GPBMessage

/**
 * sum is the oneof that specifies whether this represents a single or nested
 * multisig signer
 **/
@property(nonatomic, readonly) ModeInfo_Sum_OneOfCase sumOneOfCase;

/** single represents a single signer */
@property(nonatomic, readwrite, strong, null_resettable) ModeInfo_Single *single;

/** multi represents a nested multisig signer */
@property(nonatomic, readwrite, strong, null_resettable) ModeInfo_Multi *multi;

@end

/**
 * Clears whatever value was set for the oneof 'sum'.
 **/
void ModeInfo_ClearSumOneOfCase(ModeInfo *message);

#pragma mark - ModeInfo_Single

typedef GPB_ENUM(ModeInfo_Single_FieldNumber) {
  ModeInfo_Single_FieldNumber_Mode = 1,
};

/**
 * Single is the mode info for a single signer. It is structured as a message
 * to allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the
 * future
 **/
GPB_FINAL @interface ModeInfo_Single : GPBMessage

/** mode is the signing mode of the single signer */
@property(nonatomic, readwrite) SignMode mode;

@end

/**
 * Fetches the raw value of a @c ModeInfo_Single's @c mode property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t ModeInfo_Single_Mode_RawValue(ModeInfo_Single *message);
/**
 * Sets the raw value of an @c ModeInfo_Single's @c mode property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetModeInfo_Single_Mode_RawValue(ModeInfo_Single *message, int32_t value);

#pragma mark - ModeInfo_Multi

typedef GPB_ENUM(ModeInfo_Multi_FieldNumber) {
  ModeInfo_Multi_FieldNumber_Bitarray = 1,
  ModeInfo_Multi_FieldNumber_ModeInfosArray = 2,
};

/**
 * Multi is the mode info for a multisig public key
 **/
GPB_FINAL @interface ModeInfo_Multi : GPBMessage

/** bitarray specifies which keys within the multisig are signing */
@property(nonatomic, readwrite, strong, null_resettable) CompactBitArray *bitarray;
/** Test to see if @c bitarray has been set. */
@property(nonatomic, readwrite) BOOL hasBitarray;

/**
 * mode_infos is the corresponding modes of the signers of the multisig
 * which could include nested multisig public keys
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<ModeInfo*> *modeInfosArray;
/** The number of items in @c modeInfosArray without causing the container to be created. */
@property(nonatomic, readonly) NSUInteger modeInfosArray_Count;

@end

#pragma mark - Fee

typedef GPB_ENUM(Fee_FieldNumber) {
  Fee_FieldNumber_AmountArray = 1,
  Fee_FieldNumber_GasLimit = 2,
  Fee_FieldNumber_Payer = 3,
  Fee_FieldNumber_Granter = 4,
};

/**
 * Fee includes the amount of coins paid in fees and the maximum
 * gas to be used by the transaction. The ratio yields an effective "gasprice",
 * which must be above some miminum to be accepted into the mempool.
 **/
GPB_FINAL @interface Fee : GPBMessage

/** amount is the amount of coins to be paid as a fee */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Coin*> *amountArray;
/** The number of items in @c amountArray without causing the container to be created. */
@property(nonatomic, readonly) NSUInteger amountArray_Count;

/**
 * gas_limit is the maximum gas that can be used in transaction processing
 * before an out of gas error occurs
 **/
@property(nonatomic, readwrite) uint64_t gasLimit;

/**
 * if unset, the first signer is responsible for paying the fees. If set, the
 * specified account must pay the fees. the payer must be a tx signer (and
 * thus have signed this field in AuthInfo). setting this field does *not*
 * change the ordering of required signers for the transaction.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *payer;

/**
 * if set, the fee payer (either the first signer or the value of the payer
 * field) requests that a fee grant be used to pay fees instead of the fee
 * payer's own balance. If an appropriate fee grant does not exist or the
 * chain does not support fee grants, this will fail
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *granter;

@end

#pragma mark - Tip

typedef GPB_ENUM(Tip_FieldNumber) {
  Tip_FieldNumber_AmountArray = 1,
  Tip_FieldNumber_Tipper = 2,
};

/**
 * Tip is the tip used for meta-transactions.
 **/
GPB_DEPRECATED_MSG("cosmos.tx.v1beta1.Tip is deprecated (see cosmos/tx/v1beta1/tx.proto).")
GPB_FINAL @interface Tip : GPBMessage

/** amount is the amount of the tip */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Coin*> *amountArray;
/** The number of items in @c amountArray without causing the container to be created. */
@property(nonatomic, readonly) NSUInteger amountArray_Count;

/** tipper is the address of the account paying for the tip */
@property(nonatomic, readwrite, copy, null_resettable) NSString *tipper;

@end

#pragma mark - AuxSignerData

typedef GPB_ENUM(AuxSignerData_FieldNumber) {
  AuxSignerData_FieldNumber_Address = 1,
  AuxSignerData_FieldNumber_SignDoc = 2,
  AuxSignerData_FieldNumber_Mode = 3,
  AuxSignerData_FieldNumber_Sig = 4,
};

/**
 * AuxSignerData is the intermediary format that an auxiliary signer (e.g. a
 * tipper) builds and sends to the fee payer (who will build and broadcast the
 * actual tx). AuxSignerData is not a valid tx in itself, and will be rejected
 * by the node if sent directly as-is.
 **/
GPB_FINAL @interface AuxSignerData : GPBMessage

/**
 * address is the bech32-encoded address of the auxiliary signer. If using
 * AuxSignerData across different chains, the bech32 prefix of the target
 * chain (where the final transaction is broadcasted) should be used.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *address;

/**
 * sign_doc is the SIGN_MODE_DIRECT_AUX sign doc that the auxiliary signer
 * signs. Note: we use the same sign doc even if we're signing with
 * LEGACY_AMINO_JSON.
 **/
@property(nonatomic, readwrite, strong, null_resettable) SignDocDirectAux *signDoc;
/** Test to see if @c signDoc has been set. */
@property(nonatomic, readwrite) BOOL hasSignDoc;

/** mode is the signing mode of the single signer. */
@property(nonatomic, readwrite) SignMode mode;

/** sig is the signature of the sign doc. */
@property(nonatomic, readwrite, copy, null_resettable) NSData *sig;

@end

/**
 * Fetches the raw value of a @c AuxSignerData's @c mode property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t AuxSignerData_Mode_RawValue(AuxSignerData *message);
/**
 * Sets the raw value of an @c AuxSignerData's @c mode property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetAuxSignerData_Mode_RawValue(AuxSignerData *message, int32_t value);

NS_ASSUME_NONNULL_END

CF_EXTERN_C_END

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
