// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// clang-format off
// source: cosmos/base/reflection/v2alpha1/reflection.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import "cosmos/base/reflection/v2alpha1/Reflection.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(AppDescriptor);
GPBObjCClassDeclaration(AuthnDescriptor);
GPBObjCClassDeclaration(ChainDescriptor);
GPBObjCClassDeclaration(CodecDescriptor);
GPBObjCClassDeclaration(ConfigurationDescriptor);
GPBObjCClassDeclaration(GetAuthnDescriptorRequest);
GPBObjCClassDeclaration(GetAuthnDescriptorResponse);
GPBObjCClassDeclaration(GetChainDescriptorRequest);
GPBObjCClassDeclaration(GetChainDescriptorResponse);
GPBObjCClassDeclaration(GetCodecDescriptorRequest);
GPBObjCClassDeclaration(GetCodecDescriptorResponse);
GPBObjCClassDeclaration(GetConfigurationDescriptorRequest);
GPBObjCClassDeclaration(GetConfigurationDescriptorResponse);
GPBObjCClassDeclaration(GetQueryServicesDescriptorRequest);
GPBObjCClassDeclaration(GetQueryServicesDescriptorResponse);
GPBObjCClassDeclaration(GetTxDescriptorRequest);
GPBObjCClassDeclaration(GetTxDescriptorResponse);
GPBObjCClassDeclaration(InterfaceAcceptingMessageDescriptor);
GPBObjCClassDeclaration(InterfaceDescriptor);
GPBObjCClassDeclaration(InterfaceImplementerDescriptor);
GPBObjCClassDeclaration(MsgDescriptor);
GPBObjCClassDeclaration(QueryMethodDescriptor);
GPBObjCClassDeclaration(QueryServiceDescriptor);
GPBObjCClassDeclaration(QueryServicesDescriptor);
GPBObjCClassDeclaration(SigningModeDescriptor);
GPBObjCClassDeclaration(TxDescriptor);

#pragma mark - ReflectionRoot

@implementation ReflectionRoot

// No extensions in the file and no imports or none of the imports (direct or
// indirect) defined extensions, so no need to generate +extensionRegistry.

@end

static GPBFileDescription ReflectionRoot_FileDescription = {
  .package = "cosmos.base.reflection.v2alpha1",
  .prefix = NULL,
  .syntax = GPBFileSyntaxProto3
};

#pragma mark - AppDescriptor

@implementation AppDescriptor

@dynamic hasAuthn, authn;
@dynamic hasChain, chain;
@dynamic hasCodec, codec;
@dynamic hasConfiguration, configuration;
@dynamic hasQueryServices, queryServices;
@dynamic hasTx, tx;

typedef struct AppDescriptor__storage_ {
  uint32_t _has_storage_[1];
  AuthnDescriptor *authn;
  ChainDescriptor *chain;
  CodecDescriptor *codec;
  ConfigurationDescriptor *configuration;
  QueryServicesDescriptor *queryServices;
  TxDescriptor *tx;
} AppDescriptor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "authn",
        .dataTypeSpecific.clazz = GPBObjCClass(AuthnDescriptor),
        .number = AppDescriptor_FieldNumber_Authn,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AppDescriptor__storage_, authn),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chain",
        .dataTypeSpecific.clazz = GPBObjCClass(ChainDescriptor),
        .number = AppDescriptor_FieldNumber_Chain,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AppDescriptor__storage_, chain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "codec",
        .dataTypeSpecific.clazz = GPBObjCClass(CodecDescriptor),
        .number = AppDescriptor_FieldNumber_Codec,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AppDescriptor__storage_, codec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "configuration",
        .dataTypeSpecific.clazz = GPBObjCClass(ConfigurationDescriptor),
        .number = AppDescriptor_FieldNumber_Configuration,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AppDescriptor__storage_, configuration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "queryServices",
        .dataTypeSpecific.clazz = GPBObjCClass(QueryServicesDescriptor),
        .number = AppDescriptor_FieldNumber_QueryServices,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AppDescriptor__storage_, queryServices),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tx",
        .dataTypeSpecific.clazz = GPBObjCClass(TxDescriptor),
        .number = AppDescriptor_FieldNumber_Tx,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AppDescriptor__storage_, tx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(AppDescriptor)
                                   messageName:@"AppDescriptor"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AppDescriptor__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TxDescriptor

@implementation TxDescriptor

@dynamic fullname;
@dynamic msgsArray, msgsArray_Count;

typedef struct TxDescriptor__storage_ {
  uint32_t _has_storage_[1];
  NSString *fullname;
  NSMutableArray *msgsArray;
} TxDescriptor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fullname",
        .dataTypeSpecific.clazz = Nil,
        .number = TxDescriptor_FieldNumber_Fullname,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TxDescriptor__storage_, fullname),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MsgDescriptor),
        .number = TxDescriptor_FieldNumber_MsgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TxDescriptor__storage_, msgsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TxDescriptor)
                                   messageName:@"TxDescriptor"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxDescriptor__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AuthnDescriptor

@implementation AuthnDescriptor

@dynamic signModesArray, signModesArray_Count;

typedef struct AuthnDescriptor__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *signModesArray;
} AuthnDescriptor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "signModesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SigningModeDescriptor),
        .number = AuthnDescriptor_FieldNumber_SignModesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AuthnDescriptor__storage_, signModesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(AuthnDescriptor)
                                   messageName:@"AuthnDescriptor"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthnDescriptor__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SigningModeDescriptor

@implementation SigningModeDescriptor

@dynamic name;
@dynamic number;
@dynamic authnInfoProviderMethodFullname;

typedef struct SigningModeDescriptor__storage_ {
  uint32_t _has_storage_[1];
  int32_t number;
  NSString *name;
  NSString *authnInfoProviderMethodFullname;
} SigningModeDescriptor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = SigningModeDescriptor_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SigningModeDescriptor__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "number",
        .dataTypeSpecific.clazz = Nil,
        .number = SigningModeDescriptor_FieldNumber_Number,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SigningModeDescriptor__storage_, number),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "authnInfoProviderMethodFullname",
        .dataTypeSpecific.clazz = Nil,
        .number = SigningModeDescriptor_FieldNumber_AuthnInfoProviderMethodFullname,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SigningModeDescriptor__storage_, authnInfoProviderMethodFullname),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SigningModeDescriptor)
                                   messageName:@"SigningModeDescriptor"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SigningModeDescriptor__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChainDescriptor

@implementation ChainDescriptor

@dynamic id_p;

typedef struct ChainDescriptor__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
} ChainDescriptor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = ChainDescriptor_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChainDescriptor__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChainDescriptor)
                                   messageName:@"ChainDescriptor"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChainDescriptor__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CodecDescriptor

@implementation CodecDescriptor

@dynamic interfacesArray, interfacesArray_Count;

typedef struct CodecDescriptor__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *interfacesArray;
} CodecDescriptor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "interfacesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InterfaceDescriptor),
        .number = CodecDescriptor_FieldNumber_InterfacesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CodecDescriptor__storage_, interfacesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CodecDescriptor)
                                   messageName:@"CodecDescriptor"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CodecDescriptor__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InterfaceDescriptor

@implementation InterfaceDescriptor

@dynamic fullname;
@dynamic interfaceAcceptingMessagesArray, interfaceAcceptingMessagesArray_Count;
@dynamic interfaceImplementersArray, interfaceImplementersArray_Count;

typedef struct InterfaceDescriptor__storage_ {
  uint32_t _has_storage_[1];
  NSString *fullname;
  NSMutableArray *interfaceAcceptingMessagesArray;
  NSMutableArray *interfaceImplementersArray;
} InterfaceDescriptor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fullname",
        .dataTypeSpecific.clazz = Nil,
        .number = InterfaceDescriptor_FieldNumber_Fullname,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InterfaceDescriptor__storage_, fullname),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "interfaceAcceptingMessagesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InterfaceAcceptingMessageDescriptor),
        .number = InterfaceDescriptor_FieldNumber_InterfaceAcceptingMessagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InterfaceDescriptor__storage_, interfaceAcceptingMessagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "interfaceImplementersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InterfaceImplementerDescriptor),
        .number = InterfaceDescriptor_FieldNumber_InterfaceImplementersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InterfaceDescriptor__storage_, interfaceImplementersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(InterfaceDescriptor)
                                   messageName:@"InterfaceDescriptor"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InterfaceDescriptor__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InterfaceImplementerDescriptor

@implementation InterfaceImplementerDescriptor

@dynamic fullname;
@dynamic typeURL;

typedef struct InterfaceImplementerDescriptor__storage_ {
  uint32_t _has_storage_[1];
  NSString *fullname;
  NSString *typeURL;
} InterfaceImplementerDescriptor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fullname",
        .dataTypeSpecific.clazz = Nil,
        .number = InterfaceImplementerDescriptor_FieldNumber_Fullname,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InterfaceImplementerDescriptor__storage_, fullname),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "typeURL",
        .dataTypeSpecific.clazz = Nil,
        .number = InterfaceImplementerDescriptor_FieldNumber_TypeURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InterfaceImplementerDescriptor__storage_, typeURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(InterfaceImplementerDescriptor)
                                   messageName:@"InterfaceImplementerDescriptor"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InterfaceImplementerDescriptor__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\002\004\241!!\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InterfaceAcceptingMessageDescriptor

@implementation InterfaceAcceptingMessageDescriptor

@dynamic fullname;
@dynamic fieldDescriptorNamesArray, fieldDescriptorNamesArray_Count;

typedef struct InterfaceAcceptingMessageDescriptor__storage_ {
  uint32_t _has_storage_[1];
  NSString *fullname;
  NSMutableArray *fieldDescriptorNamesArray;
} InterfaceAcceptingMessageDescriptor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fullname",
        .dataTypeSpecific.clazz = Nil,
        .number = InterfaceAcceptingMessageDescriptor_FieldNumber_Fullname,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InterfaceAcceptingMessageDescriptor__storage_, fullname),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fieldDescriptorNamesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = InterfaceAcceptingMessageDescriptor_FieldNumber_FieldDescriptorNamesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InterfaceAcceptingMessageDescriptor__storage_, fieldDescriptorNamesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(InterfaceAcceptingMessageDescriptor)
                                   messageName:@"InterfaceAcceptingMessageDescriptor"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InterfaceAcceptingMessageDescriptor__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConfigurationDescriptor

@implementation ConfigurationDescriptor

@dynamic bech32AccountAddressPrefix;

typedef struct ConfigurationDescriptor__storage_ {
  uint32_t _has_storage_[1];
  NSString *bech32AccountAddressPrefix;
} ConfigurationDescriptor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bech32AccountAddressPrefix",
        .dataTypeSpecific.clazz = Nil,
        .number = ConfigurationDescriptor_FieldNumber_Bech32AccountAddressPrefix,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConfigurationDescriptor__storage_, bech32AccountAddressPrefix),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ConfigurationDescriptor)
                                   messageName:@"ConfigurationDescriptor"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConfigurationDescriptor__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MsgDescriptor

@implementation MsgDescriptor

@dynamic msgTypeURL;

typedef struct MsgDescriptor__storage_ {
  uint32_t _has_storage_[1];
  NSString *msgTypeURL;
} MsgDescriptor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgTypeURL",
        .dataTypeSpecific.clazz = Nil,
        .number = MsgDescriptor_FieldNumber_MsgTypeURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MsgDescriptor__storage_, msgTypeURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MsgDescriptor)
                                   messageName:@"MsgDescriptor"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MsgDescriptor__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\003\244\241!!\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAuthnDescriptorRequest

@implementation GetAuthnDescriptorRequest


typedef struct GetAuthnDescriptorRequest__storage_ {
  uint32_t _has_storage_[1];
} GetAuthnDescriptorRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetAuthnDescriptorRequest)
                                   messageName:@"GetAuthnDescriptorRequest"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetAuthnDescriptorRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAuthnDescriptorResponse

@implementation GetAuthnDescriptorResponse

@dynamic hasAuthn, authn;

typedef struct GetAuthnDescriptorResponse__storage_ {
  uint32_t _has_storage_[1];
  AuthnDescriptor *authn;
} GetAuthnDescriptorResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "authn",
        .dataTypeSpecific.clazz = GPBObjCClass(AuthnDescriptor),
        .number = GetAuthnDescriptorResponse_FieldNumber_Authn,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAuthnDescriptorResponse__storage_, authn),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetAuthnDescriptorResponse)
                                   messageName:@"GetAuthnDescriptorResponse"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAuthnDescriptorResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetChainDescriptorRequest

@implementation GetChainDescriptorRequest


typedef struct GetChainDescriptorRequest__storage_ {
  uint32_t _has_storage_[1];
} GetChainDescriptorRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetChainDescriptorRequest)
                                   messageName:@"GetChainDescriptorRequest"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetChainDescriptorRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetChainDescriptorResponse

@implementation GetChainDescriptorResponse

@dynamic hasChain, chain;

typedef struct GetChainDescriptorResponse__storage_ {
  uint32_t _has_storage_[1];
  ChainDescriptor *chain;
} GetChainDescriptorResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chain",
        .dataTypeSpecific.clazz = GPBObjCClass(ChainDescriptor),
        .number = GetChainDescriptorResponse_FieldNumber_Chain,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetChainDescriptorResponse__storage_, chain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetChainDescriptorResponse)
                                   messageName:@"GetChainDescriptorResponse"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetChainDescriptorResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetCodecDescriptorRequest

@implementation GetCodecDescriptorRequest


typedef struct GetCodecDescriptorRequest__storage_ {
  uint32_t _has_storage_[1];
} GetCodecDescriptorRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetCodecDescriptorRequest)
                                   messageName:@"GetCodecDescriptorRequest"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetCodecDescriptorRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetCodecDescriptorResponse

@implementation GetCodecDescriptorResponse

@dynamic hasCodec, codec;

typedef struct GetCodecDescriptorResponse__storage_ {
  uint32_t _has_storage_[1];
  CodecDescriptor *codec;
} GetCodecDescriptorResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "codec",
        .dataTypeSpecific.clazz = GPBObjCClass(CodecDescriptor),
        .number = GetCodecDescriptorResponse_FieldNumber_Codec,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetCodecDescriptorResponse__storage_, codec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetCodecDescriptorResponse)
                                   messageName:@"GetCodecDescriptorResponse"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetCodecDescriptorResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetConfigurationDescriptorRequest

@implementation GetConfigurationDescriptorRequest


typedef struct GetConfigurationDescriptorRequest__storage_ {
  uint32_t _has_storage_[1];
} GetConfigurationDescriptorRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetConfigurationDescriptorRequest)
                                   messageName:@"GetConfigurationDescriptorRequest"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetConfigurationDescriptorRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetConfigurationDescriptorResponse

@implementation GetConfigurationDescriptorResponse

@dynamic hasConfig, config;

typedef struct GetConfigurationDescriptorResponse__storage_ {
  uint32_t _has_storage_[1];
  ConfigurationDescriptor *config;
} GetConfigurationDescriptorResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "config",
        .dataTypeSpecific.clazz = GPBObjCClass(ConfigurationDescriptor),
        .number = GetConfigurationDescriptorResponse_FieldNumber_Config,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetConfigurationDescriptorResponse__storage_, config),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetConfigurationDescriptorResponse)
                                   messageName:@"GetConfigurationDescriptorResponse"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetConfigurationDescriptorResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetQueryServicesDescriptorRequest

@implementation GetQueryServicesDescriptorRequest


typedef struct GetQueryServicesDescriptorRequest__storage_ {
  uint32_t _has_storage_[1];
} GetQueryServicesDescriptorRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetQueryServicesDescriptorRequest)
                                   messageName:@"GetQueryServicesDescriptorRequest"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetQueryServicesDescriptorRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetQueryServicesDescriptorResponse

@implementation GetQueryServicesDescriptorResponse

@dynamic hasQueries, queries;

typedef struct GetQueryServicesDescriptorResponse__storage_ {
  uint32_t _has_storage_[1];
  QueryServicesDescriptor *queries;
} GetQueryServicesDescriptorResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "queries",
        .dataTypeSpecific.clazz = GPBObjCClass(QueryServicesDescriptor),
        .number = GetQueryServicesDescriptorResponse_FieldNumber_Queries,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetQueryServicesDescriptorResponse__storage_, queries),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetQueryServicesDescriptorResponse)
                                   messageName:@"GetQueryServicesDescriptorResponse"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetQueryServicesDescriptorResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTxDescriptorRequest

@implementation GetTxDescriptorRequest


typedef struct GetTxDescriptorRequest__storage_ {
  uint32_t _has_storage_[1];
} GetTxDescriptorRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetTxDescriptorRequest)
                                   messageName:@"GetTxDescriptorRequest"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetTxDescriptorRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTxDescriptorResponse

@implementation GetTxDescriptorResponse

@dynamic hasTx, tx;

typedef struct GetTxDescriptorResponse__storage_ {
  uint32_t _has_storage_[1];
  TxDescriptor *tx;
} GetTxDescriptorResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tx",
        .dataTypeSpecific.clazz = GPBObjCClass(TxDescriptor),
        .number = GetTxDescriptorResponse_FieldNumber_Tx,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetTxDescriptorResponse__storage_, tx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetTxDescriptorResponse)
                                   messageName:@"GetTxDescriptorResponse"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTxDescriptorResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QueryServicesDescriptor

@implementation QueryServicesDescriptor

@dynamic queryServicesArray, queryServicesArray_Count;

typedef struct QueryServicesDescriptor__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *queryServicesArray;
} QueryServicesDescriptor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "queryServicesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(QueryServiceDescriptor),
        .number = QueryServicesDescriptor_FieldNumber_QueryServicesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QueryServicesDescriptor__storage_, queryServicesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QueryServicesDescriptor)
                                   messageName:@"QueryServicesDescriptor"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QueryServicesDescriptor__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QueryServiceDescriptor

@implementation QueryServiceDescriptor

@dynamic fullname;
@dynamic isModule;
@dynamic methodsArray, methodsArray_Count;

typedef struct QueryServiceDescriptor__storage_ {
  uint32_t _has_storage_[1];
  NSString *fullname;
  NSMutableArray *methodsArray;
} QueryServiceDescriptor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fullname",
        .dataTypeSpecific.clazz = Nil,
        .number = QueryServiceDescriptor_FieldNumber_Fullname,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QueryServiceDescriptor__storage_, fullname),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isModule",
        .dataTypeSpecific.clazz = Nil,
        .number = QueryServiceDescriptor_FieldNumber_IsModule,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "methodsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(QueryMethodDescriptor),
        .number = QueryServiceDescriptor_FieldNumber_MethodsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QueryServiceDescriptor__storage_, methodsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QueryServiceDescriptor)
                                   messageName:@"QueryServiceDescriptor"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QueryServiceDescriptor__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QueryMethodDescriptor

@implementation QueryMethodDescriptor

@dynamic name;
@dynamic fullQueryPath;

typedef struct QueryMethodDescriptor__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *fullQueryPath;
} QueryMethodDescriptor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = QueryMethodDescriptor_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QueryMethodDescriptor__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fullQueryPath",
        .dataTypeSpecific.clazz = Nil,
        .number = QueryMethodDescriptor_FieldNumber_FullQueryPath,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QueryMethodDescriptor__storage_, fullQueryPath),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QueryMethodDescriptor)
                                   messageName:@"QueryMethodDescriptor"
                               fileDescription:&ReflectionRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QueryMethodDescriptor__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
