// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// clang-format off
// source: cosmos/base/abci/v1beta1/abci.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import "cosmos/base/abci/v1beta1/Abci.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(ABCIMessageLog);
GPBObjCClassDeclaration(Attribute);
GPBObjCClassDeclaration(Block);
GPBObjCClassDeclaration(Event);
GPBObjCClassDeclaration(GPBAny);
GPBObjCClassDeclaration(GasInfo);
GPBObjCClassDeclaration(MsgData);
GPBObjCClassDeclaration(Result);
GPBObjCClassDeclaration(SearchBlocksResult);
GPBObjCClassDeclaration(SearchTxsResult);
GPBObjCClassDeclaration(SimulationResponse);
GPBObjCClassDeclaration(StringEvent);
GPBObjCClassDeclaration(TxMsgData);
GPBObjCClassDeclaration(TxResponse);

#pragma mark - AbciRoot

@implementation AbciRoot

// No extensions in the file and no imports or none of the imports (direct or
// indirect) defined extensions, so no need to generate +extensionRegistry.

@end

static GPBFileDescription AbciRoot_FileDescription = {
  .package = "cosmos.base.abci.v1beta1",
  .prefix = NULL,
  .syntax = GPBFileSyntaxProto3
};

#pragma mark - TxResponse

@implementation TxResponse

@dynamic height;
@dynamic txhash;
@dynamic codespace;
@dynamic code;
@dynamic data_p;
@dynamic rawLog;
@dynamic logsArray, logsArray_Count;
@dynamic info;
@dynamic gasWanted;
@dynamic gasUsed;
@dynamic hasTx, tx;
@dynamic timestamp;
@dynamic eventsArray, eventsArray_Count;

typedef struct TxResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t code;
  NSString *txhash;
  NSString *codespace;
  NSString *data_p;
  NSString *rawLog;
  NSMutableArray *logsArray;
  NSString *info;
  GPBAny *tx;
  NSString *timestamp;
  NSMutableArray *eventsArray;
  int64_t height;
  int64_t gasWanted;
  int64_t gasUsed;
} TxResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = TxResponse_FieldNumber_Height,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TxResponse__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "txhash",
        .dataTypeSpecific.clazz = Nil,
        .number = TxResponse_FieldNumber_Txhash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TxResponse__storage_, txhash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "codespace",
        .dataTypeSpecific.clazz = Nil,
        .number = TxResponse_FieldNumber_Codespace,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TxResponse__storage_, codespace),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "code",
        .dataTypeSpecific.clazz = Nil,
        .number = TxResponse_FieldNumber_Code,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TxResponse__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = TxResponse_FieldNumber_Data_p,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TxResponse__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rawLog",
        .dataTypeSpecific.clazz = Nil,
        .number = TxResponse_FieldNumber_RawLog,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TxResponse__storage_, rawLog),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "logsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ABCIMessageLog),
        .number = TxResponse_FieldNumber_LogsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TxResponse__storage_, logsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "info",
        .dataTypeSpecific.clazz = Nil,
        .number = TxResponse_FieldNumber_Info,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(TxResponse__storage_, info),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gasWanted",
        .dataTypeSpecific.clazz = Nil,
        .number = TxResponse_FieldNumber_GasWanted,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(TxResponse__storage_, gasWanted),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "gasUsed",
        .dataTypeSpecific.clazz = Nil,
        .number = TxResponse_FieldNumber_GasUsed,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(TxResponse__storage_, gasUsed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "tx",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBAny),
        .number = TxResponse_FieldNumber_Tx,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(TxResponse__storage_, tx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = Nil,
        .number = TxResponse_FieldNumber_Timestamp,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(TxResponse__storage_, timestamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "eventsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Event),
        .number = TxResponse_FieldNumber_EventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TxResponse__storage_, eventsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TxResponse)
                                   messageName:@"TxResponse"
                               fileDescription:&AbciRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ABCIMessageLog

@implementation ABCIMessageLog

@dynamic msgIndex;
@dynamic log;
@dynamic eventsArray, eventsArray_Count;

typedef struct ABCIMessageLog__storage_ {
  uint32_t _has_storage_[1];
  uint32_t msgIndex;
  NSString *log;
  NSMutableArray *eventsArray;
} ABCIMessageLog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = ABCIMessageLog_FieldNumber_MsgIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ABCIMessageLog__storage_, msgIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "log",
        .dataTypeSpecific.clazz = Nil,
        .number = ABCIMessageLog_FieldNumber_Log,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ABCIMessageLog__storage_, log),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "eventsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(StringEvent),
        .number = ABCIMessageLog_FieldNumber_EventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ABCIMessageLog__storage_, eventsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ABCIMessageLog)
                                   messageName:@"ABCIMessageLog"
                               fileDescription:&AbciRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ABCIMessageLog__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StringEvent

@implementation StringEvent

@dynamic type;
@dynamic attributesArray, attributesArray_Count;

typedef struct StringEvent__storage_ {
  uint32_t _has_storage_[1];
  NSString *type;
  NSMutableArray *attributesArray;
} StringEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.clazz = Nil,
        .number = StringEvent_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StringEvent__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attributesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Attribute),
        .number = StringEvent_FieldNumber_AttributesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(StringEvent__storage_, attributesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(StringEvent)
                                   messageName:@"StringEvent"
                               fileDescription:&AbciRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StringEvent__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Attribute

@implementation Attribute

@dynamic key;
@dynamic value;

typedef struct Attribute__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSString *value;
} Attribute__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = Attribute_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Attribute__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = Attribute_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Attribute__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Attribute)
                                   messageName:@"Attribute"
                               fileDescription:&AbciRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Attribute__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GasInfo

@implementation GasInfo

@dynamic gasWanted;
@dynamic gasUsed;

typedef struct GasInfo__storage_ {
  uint32_t _has_storage_[1];
  uint64_t gasWanted;
  uint64_t gasUsed;
} GasInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gasWanted",
        .dataTypeSpecific.clazz = Nil,
        .number = GasInfo_FieldNumber_GasWanted,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GasInfo__storage_, gasWanted),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "gasUsed",
        .dataTypeSpecific.clazz = Nil,
        .number = GasInfo_FieldNumber_GasUsed,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GasInfo__storage_, gasUsed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GasInfo)
                                   messageName:@"GasInfo"
                               fileDescription:&AbciRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GasInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Result

@implementation Result

@dynamic data_p;
@dynamic log;
@dynamic eventsArray, eventsArray_Count;
@dynamic msgResponsesArray, msgResponsesArray_Count;

typedef struct Result__storage_ {
  uint32_t _has_storage_[1];
  NSData *data_p;
  NSString *log;
  NSMutableArray *eventsArray;
  NSMutableArray *msgResponsesArray;
} Result__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Result_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Result__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "log",
        .dataTypeSpecific.clazz = Nil,
        .number = Result_FieldNumber_Log,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Result__storage_, log),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "eventsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Event),
        .number = Result_FieldNumber_EventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Result__storage_, eventsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msgResponsesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBAny),
        .number = Result_FieldNumber_MsgResponsesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Result__storage_, msgResponsesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Result)
                                   messageName:@"Result"
                               fileDescription:&AbciRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Result__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SimulationResponse

@implementation SimulationResponse

@dynamic hasGasInfo, gasInfo;
@dynamic hasResult, result;

typedef struct SimulationResponse__storage_ {
  uint32_t _has_storage_[1];
  GasInfo *gasInfo;
  Result *result;
} SimulationResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gasInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(GasInfo),
        .number = SimulationResponse_FieldNumber_GasInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SimulationResponse__storage_, gasInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "result",
        .dataTypeSpecific.clazz = GPBObjCClass(Result),
        .number = SimulationResponse_FieldNumber_Result,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SimulationResponse__storage_, result),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SimulationResponse)
                                   messageName:@"SimulationResponse"
                               fileDescription:&AbciRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SimulationResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MsgData

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-implementations"

@implementation MsgData

@dynamic msgType;
@dynamic data_p;

typedef struct MsgData__storage_ {
  uint32_t _has_storage_[1];
  NSString *msgType;
  NSData *data_p;
} MsgData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgType",
        .dataTypeSpecific.clazz = Nil,
        .number = MsgData_FieldNumber_MsgType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MsgData__storage_, msgType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = MsgData_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MsgData__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MsgData)
                                   messageName:@"MsgData"
                               fileDescription:&AbciRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MsgData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma clang diagnostic pop

#pragma mark - TxMsgData

@implementation TxMsgData

@dynamic dataArray, dataArray_Count;
@dynamic msgResponsesArray, msgResponsesArray_Count;

typedef struct TxMsgData__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *dataArray;
  NSMutableArray *msgResponsesArray;
} TxMsgData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MsgData),
        .number = TxMsgData_FieldNumber_DataArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TxMsgData__storage_, dataArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msgResponsesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBAny),
        .number = TxMsgData_FieldNumber_MsgResponsesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TxMsgData__storage_, msgResponsesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TxMsgData)
                                   messageName:@"TxMsgData"
                               fileDescription:&AbciRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TxMsgData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SearchTxsResult

@implementation SearchTxsResult

@dynamic totalCount;
@dynamic count;
@dynamic pageNumber;
@dynamic pageTotal;
@dynamic limit;
@dynamic txsArray, txsArray_Count;

typedef struct SearchTxsResult__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *txsArray;
  uint64_t totalCount;
  uint64_t count;
  uint64_t pageNumber;
  uint64_t pageTotal;
  uint64_t limit;
} SearchTxsResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "totalCount",
        .dataTypeSpecific.clazz = Nil,
        .number = SearchTxsResult_FieldNumber_TotalCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SearchTxsResult__storage_, totalCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = SearchTxsResult_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SearchTxsResult__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pageNumber",
        .dataTypeSpecific.clazz = Nil,
        .number = SearchTxsResult_FieldNumber_PageNumber,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SearchTxsResult__storage_, pageNumber),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pageTotal",
        .dataTypeSpecific.clazz = Nil,
        .number = SearchTxsResult_FieldNumber_PageTotal,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SearchTxsResult__storage_, pageTotal),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = SearchTxsResult_FieldNumber_Limit,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SearchTxsResult__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "txsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(TxResponse),
        .number = SearchTxsResult_FieldNumber_TxsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SearchTxsResult__storage_, txsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SearchTxsResult)
                                   messageName:@"SearchTxsResult"
                               fileDescription:&AbciRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchTxsResult__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SearchBlocksResult

@implementation SearchBlocksResult

@dynamic totalCount;
@dynamic count;
@dynamic pageNumber;
@dynamic pageTotal;
@dynamic limit;
@dynamic blocksArray, blocksArray_Count;

typedef struct SearchBlocksResult__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *blocksArray;
  int64_t totalCount;
  int64_t count;
  int64_t pageNumber;
  int64_t pageTotal;
  int64_t limit;
} SearchBlocksResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "totalCount",
        .dataTypeSpecific.clazz = Nil,
        .number = SearchBlocksResult_FieldNumber_TotalCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SearchBlocksResult__storage_, totalCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = SearchBlocksResult_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SearchBlocksResult__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pageNumber",
        .dataTypeSpecific.clazz = Nil,
        .number = SearchBlocksResult_FieldNumber_PageNumber,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SearchBlocksResult__storage_, pageNumber),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pageTotal",
        .dataTypeSpecific.clazz = Nil,
        .number = SearchBlocksResult_FieldNumber_PageTotal,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SearchBlocksResult__storage_, pageTotal),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = SearchBlocksResult_FieldNumber_Limit,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SearchBlocksResult__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "blocksArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Block),
        .number = SearchBlocksResult_FieldNumber_BlocksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SearchBlocksResult__storage_, blocksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SearchBlocksResult)
                                   messageName:@"SearchBlocksResult"
                               fileDescription:&AbciRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchBlocksResult__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
