// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// clang-format off
// source: cosmos/ics23/v1/proofs.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers.h>
#else
 #import "GPBProtocolBuffers.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

CF_EXTERN_C_BEGIN

@class BatchEntry;
@class BatchProof;
@class CompressedBatchEntry;
@class CompressedBatchProof;
@class CompressedExistenceProof;
@class CompressedNonExistenceProof;
@class ExistenceProof;
@class InnerOp;
@class InnerSpec;
@class LeafOp;
@class NonExistenceProof;

NS_ASSUME_NONNULL_BEGIN

#pragma mark - Enum HashOp

typedef GPB_ENUM(HashOp) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  HashOp_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** NO_HASH is the default if no data passed. Note this is an illegal argument some places. */
  HashOp_NoHash = 0,
  HashOp_Sha256 = 1,
  HashOp_Sha512 = 2,
  HashOp_Keccak = 3,
  HashOp_Ripemd160 = 4,

  /** ripemd160(sha256(x)) */
  HashOp_Bitcoin = 5,
  HashOp_Sha512256 = 6,
};

GPBEnumDescriptor *HashOp_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL HashOp_IsValidValue(int32_t value);

#pragma mark - Enum LengthOp

/**
 * *
 * LengthOp defines how to process the key and value of the LeafOp
 * to include length information. After encoding the length with the given
 * algorithm, the length will be prepended to the key and value bytes.
 * (Each one with it's own encoded length)
 **/
typedef GPB_ENUM(LengthOp) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  LengthOp_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** NO_PREFIX don't include any length info */
  LengthOp_NoPrefix = 0,

  /** VAR_PROTO uses protobuf (and go-amino) varint encoding of the length */
  LengthOp_VarProto = 1,

  /** VAR_RLP uses rlp int encoding of the length */
  LengthOp_VarRlp = 2,

  /** FIXED32_BIG uses big-endian encoding of the length as a 32 bit integer */
  LengthOp_Fixed32Big = 3,

  /** FIXED32_LITTLE uses little-endian encoding of the length as a 32 bit integer */
  LengthOp_Fixed32Little = 4,

  /** FIXED64_BIG uses big-endian encoding of the length as a 64 bit integer */
  LengthOp_Fixed64Big = 5,

  /** FIXED64_LITTLE uses little-endian encoding of the length as a 64 bit integer */
  LengthOp_Fixed64Little = 6,

  /** REQUIRE_32_BYTES is like NONE, but will fail if the input is not exactly 32 bytes (sha256 output) */
  LengthOp_Require32Bytes = 7,

  /** REQUIRE_64_BYTES is like NONE, but will fail if the input is not exactly 64 bytes (sha512 output) */
  LengthOp_Require64Bytes = 8,
};

GPBEnumDescriptor *LengthOp_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL LengthOp_IsValidValue(int32_t value);

#pragma mark - ProofsRoot

/**
 * Exposes the extension registry for this file.
 *
 * The base class provides:
 * @code
 *   + (GPBExtensionRegistry *)extensionRegistry;
 * @endcode
 * which is a @c GPBExtensionRegistry that includes all the extensions defined by
 * this file and all files that it depends on.
 **/
GPB_FINAL @interface ProofsRoot : GPBRootObject
@end

#pragma mark - ExistenceProof

typedef GPB_ENUM(ExistenceProof_FieldNumber) {
  ExistenceProof_FieldNumber_Key = 1,
  ExistenceProof_FieldNumber_Value = 2,
  ExistenceProof_FieldNumber_Leaf = 3,
  ExistenceProof_FieldNumber_PathArray = 4,
};

/**
 * *
 * ExistenceProof takes a key and a value and a set of steps to perform on it.
 * The result of peforming all these steps will provide a "root hash", which can
 * be compared to the value in a header.
 *
 * Since it is computationally infeasible to produce a hash collission for any of the used
 * cryptographic hash functions, if someone can provide a series of operations to transform
 * a given key and value into a root hash that matches some trusted root, these key and values
 * must be in the referenced merkle tree.
 *
 * The only possible issue is maliablity in LeafOp, such as providing extra prefix data,
 * which should be controlled by a spec. Eg. with lengthOp as NONE,
 * prefix = FOO, key = BAR, value = CHOICE
 * and
 * prefix = F, key = OOBAR, value = CHOICE
 * would produce the same value.
 *
 * With LengthOp this is tricker but not impossible. Which is why the "leafPrefixEqual" field
 * in the ProofSpec is valuable to prevent this mutability. And why all trees should
 * length-prefix the data before hashing it.
 **/
GPB_FINAL @interface ExistenceProof : GPBMessage

@property(nonatomic, readwrite, copy, null_resettable) NSData *key;

@property(nonatomic, readwrite, copy, null_resettable) NSData *value;

@property(nonatomic, readwrite, strong, null_resettable) LeafOp *leaf;
/** Test to see if @c leaf has been set. */
@property(nonatomic, readwrite) BOOL hasLeaf;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<InnerOp*> *pathArray;
/** The number of items in @c pathArray without causing the container to be created. */
@property(nonatomic, readonly) NSUInteger pathArray_Count;

@end

#pragma mark - NonExistenceProof

typedef GPB_ENUM(NonExistenceProof_FieldNumber) {
  NonExistenceProof_FieldNumber_Key = 1,
  NonExistenceProof_FieldNumber_Left = 2,
  NonExistenceProof_FieldNumber_Right = 3,
};

/**
 *
 * NonExistenceProof takes a proof of two neighbors, one left of the desired key,
 * one right of the desired key. If both proofs are valid AND they are neighbors,
 * then there is no valid proof for the given key.
 **/
GPB_FINAL @interface NonExistenceProof : GPBMessage

/** TODO: remove this as unnecessary??? we prove a range */
@property(nonatomic, readwrite, copy, null_resettable) NSData *key;

@property(nonatomic, readwrite, strong, null_resettable) ExistenceProof *left;
/** Test to see if @c left has been set. */
@property(nonatomic, readwrite) BOOL hasLeft;

@property(nonatomic, readwrite, strong, null_resettable) ExistenceProof *right;
/** Test to see if @c right has been set. */
@property(nonatomic, readwrite) BOOL hasRight;

@end

#pragma mark - CommitmentProof

typedef GPB_ENUM(CommitmentProof_FieldNumber) {
  CommitmentProof_FieldNumber_Exist = 1,
  CommitmentProof_FieldNumber_Nonexist = 2,
  CommitmentProof_FieldNumber_Batch = 3,
  CommitmentProof_FieldNumber_Compressed = 4,
};

typedef GPB_ENUM(CommitmentProof_Proof_OneOfCase) {
  CommitmentProof_Proof_OneOfCase_GPBUnsetOneOfCase = 0,
  CommitmentProof_Proof_OneOfCase_Exist = 1,
  CommitmentProof_Proof_OneOfCase_Nonexist = 2,
  CommitmentProof_Proof_OneOfCase_Batch = 3,
  CommitmentProof_Proof_OneOfCase_Compressed = 4,
};

/**
 *
 * CommitmentProof is either an ExistenceProof or a NonExistenceProof, or a Batch of such messages
 **/
GPB_FINAL @interface CommitmentProof : GPBMessage

@property(nonatomic, readonly) CommitmentProof_Proof_OneOfCase proofOneOfCase;

@property(nonatomic, readwrite, strong, null_resettable) ExistenceProof *exist;

@property(nonatomic, readwrite, strong, null_resettable) NonExistenceProof *nonexist;

@property(nonatomic, readwrite, strong, null_resettable) BatchProof *batch;

@property(nonatomic, readwrite, strong, null_resettable) CompressedBatchProof *compressed;

@end

/**
 * Clears whatever value was set for the oneof 'proof'.
 **/
void CommitmentProof_ClearProofOneOfCase(CommitmentProof *message);

#pragma mark - LeafOp

typedef GPB_ENUM(LeafOp_FieldNumber) {
  LeafOp_FieldNumber_Hash_p = 1,
  LeafOp_FieldNumber_PrehashKey = 2,
  LeafOp_FieldNumber_PrehashValue = 3,
  LeafOp_FieldNumber_Length = 4,
  LeafOp_FieldNumber_Prefix = 5,
};

/**
 * *
 * LeafOp represents the raw key-value data we wish to prove, and
 * must be flexible to represent the internal transformation from
 * the original key-value pairs into the basis hash, for many existing
 * merkle trees.
 *
 * key and value are passed in. So that the signature of this operation is:
 * leafOp(key, value) -> output
 *
 * To process this, first prehash the keys and values if needed (ANY means no hash in this case):
 * hkey = prehashKey(key)
 * hvalue = prehashValue(value)
 *
 * Then combine the bytes, and hash it
 * output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue)
 **/
GPB_FINAL @interface LeafOp : GPBMessage

@property(nonatomic, readwrite) HashOp hash_p;

@property(nonatomic, readwrite) HashOp prehashKey;

@property(nonatomic, readwrite) HashOp prehashValue;

@property(nonatomic, readwrite) LengthOp length;

/**
 * prefix is a fixed bytes that may optionally be included at the beginning to differentiate
 * a leaf node from an inner node.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSData *prefix;

@end

/**
 * Fetches the raw value of a @c LeafOp's @c hash_p property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t LeafOp_Hash_p_RawValue(LeafOp *message);
/**
 * Sets the raw value of an @c LeafOp's @c hash_p property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetLeafOp_Hash_p_RawValue(LeafOp *message, int32_t value);

/**
 * Fetches the raw value of a @c LeafOp's @c prehashKey property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t LeafOp_PrehashKey_RawValue(LeafOp *message);
/**
 * Sets the raw value of an @c LeafOp's @c prehashKey property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetLeafOp_PrehashKey_RawValue(LeafOp *message, int32_t value);

/**
 * Fetches the raw value of a @c LeafOp's @c prehashValue property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t LeafOp_PrehashValue_RawValue(LeafOp *message);
/**
 * Sets the raw value of an @c LeafOp's @c prehashValue property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetLeafOp_PrehashValue_RawValue(LeafOp *message, int32_t value);

/**
 * Fetches the raw value of a @c LeafOp's @c length property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t LeafOp_Length_RawValue(LeafOp *message);
/**
 * Sets the raw value of an @c LeafOp's @c length property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetLeafOp_Length_RawValue(LeafOp *message, int32_t value);

#pragma mark - InnerOp

typedef GPB_ENUM(InnerOp_FieldNumber) {
  InnerOp_FieldNumber_Hash_p = 1,
  InnerOp_FieldNumber_Prefix = 2,
  InnerOp_FieldNumber_Suffix = 3,
};

/**
 * *
 * InnerOp represents a merkle-proof step that is not a leaf.
 * It represents concatenating two children and hashing them to provide the next result.
 *
 * The result of the previous step is passed in, so the signature of this op is:
 * innerOp(child) -> output
 *
 * The result of applying InnerOp should be:
 * output = op.hash(op.prefix || child || op.suffix)
 *
 * where the || operator is concatenation of binary data,
 * and child is the result of hashing all the tree below this step.
 *
 * Any special data, like prepending child with the length, or prepending the entire operation with
 * some value to differentiate from leaf nodes, should be included in prefix and suffix.
 * If either of prefix or suffix is empty, we just treat it as an empty string
 **/
GPB_FINAL @interface InnerOp : GPBMessage

@property(nonatomic, readwrite) HashOp hash_p;

@property(nonatomic, readwrite, copy, null_resettable) NSData *prefix;

@property(nonatomic, readwrite, copy, null_resettable) NSData *suffix;

@end

/**
 * Fetches the raw value of a @c InnerOp's @c hash_p property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t InnerOp_Hash_p_RawValue(InnerOp *message);
/**
 * Sets the raw value of an @c InnerOp's @c hash_p property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetInnerOp_Hash_p_RawValue(InnerOp *message, int32_t value);

#pragma mark - ProofSpec

typedef GPB_ENUM(ProofSpec_FieldNumber) {
  ProofSpec_FieldNumber_LeafSpec = 1,
  ProofSpec_FieldNumber_InnerSpec = 2,
  ProofSpec_FieldNumber_MaxDepth = 3,
  ProofSpec_FieldNumber_MinDepth = 4,
};

/**
 * *
 * ProofSpec defines what the expected parameters are for a given proof type.
 * This can be stored in the client and used to validate any incoming proofs.
 *
 * verify(ProofSpec, Proof) -> Proof | Error
 *
 * As demonstrated in tests, if we don't fix the algorithm used to calculate the
 * LeafHash for a given tree, there are many possible key-value pairs that can
 * generate a given hash (by interpretting the preimage differently).
 * We need this for proper security, requires client knows a priori what
 * tree format server uses. But not in code, rather a configuration object.
 **/
GPB_FINAL @interface ProofSpec : GPBMessage

/**
 * any field in the ExistenceProof must be the same as in this spec.
 * except Prefix, which is just the first bytes of prefix (spec can be longer)
 **/
@property(nonatomic, readwrite, strong, null_resettable) LeafOp *leafSpec;
/** Test to see if @c leafSpec has been set. */
@property(nonatomic, readwrite) BOOL hasLeafSpec;

@property(nonatomic, readwrite, strong, null_resettable) InnerSpec *innerSpec;
/** Test to see if @c innerSpec has been set. */
@property(nonatomic, readwrite) BOOL hasInnerSpec;

/** max_depth (if > 0) is the maximum number of InnerOps allowed (mainly for fixed-depth tries) */
@property(nonatomic, readwrite) int32_t maxDepth;

/** min_depth (if > 0) is the minimum number of InnerOps allowed (mainly for fixed-depth tries) */
@property(nonatomic, readwrite) int32_t minDepth;

@end

#pragma mark - InnerSpec

typedef GPB_ENUM(InnerSpec_FieldNumber) {
  InnerSpec_FieldNumber_ChildOrderArray = 1,
  InnerSpec_FieldNumber_ChildSize = 2,
  InnerSpec_FieldNumber_MinPrefixLength = 3,
  InnerSpec_FieldNumber_MaxPrefixLength = 4,
  InnerSpec_FieldNumber_EmptyChild = 5,
  InnerSpec_FieldNumber_Hash_p = 6,
};

/**
 *
 * InnerSpec contains all store-specific structure info to determine if two proofs from a
 * given store are neighbors.
 *
 * This enables:
 *
 * isLeftMost(spec: InnerSpec, op: InnerOp)
 * isRightMost(spec: InnerSpec, op: InnerOp)
 * isLeftNeighbor(spec: InnerSpec, left: InnerOp, right: InnerOp)
 **/
GPB_FINAL @interface InnerSpec : GPBMessage

/**
 * Child order is the ordering of the children node, must count from 0
 * iavl tree is [0, 1] (left then right)
 * merk is [0, 2, 1] (left, right, here)
 **/
@property(nonatomic, readwrite, strong, null_resettable) GPBInt32Array *childOrderArray;
/** The number of items in @c childOrderArray without causing the container to be created. */
@property(nonatomic, readonly) NSUInteger childOrderArray_Count;

@property(nonatomic, readwrite) int32_t childSize;

@property(nonatomic, readwrite) int32_t minPrefixLength;

@property(nonatomic, readwrite) int32_t maxPrefixLength;

/** empty child is the prehash image that is used when one child is nil (eg. 20 bytes of 0) */
@property(nonatomic, readwrite, copy, null_resettable) NSData *emptyChild;

/** hash is the algorithm that must be used for each InnerOp */
@property(nonatomic, readwrite) HashOp hash_p;

@end

/**
 * Fetches the raw value of a @c InnerSpec's @c hash_p property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t InnerSpec_Hash_p_RawValue(InnerSpec *message);
/**
 * Sets the raw value of an @c InnerSpec's @c hash_p property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetInnerSpec_Hash_p_RawValue(InnerSpec *message, int32_t value);

#pragma mark - BatchProof

typedef GPB_ENUM(BatchProof_FieldNumber) {
  BatchProof_FieldNumber_EntriesArray = 1,
};

/**
 *
 * BatchProof is a group of multiple proof types than can be compressed
 **/
GPB_FINAL @interface BatchProof : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<BatchEntry*> *entriesArray;
/** The number of items in @c entriesArray without causing the container to be created. */
@property(nonatomic, readonly) NSUInteger entriesArray_Count;

@end

#pragma mark - BatchEntry

typedef GPB_ENUM(BatchEntry_FieldNumber) {
  BatchEntry_FieldNumber_Exist = 1,
  BatchEntry_FieldNumber_Nonexist = 2,
};

typedef GPB_ENUM(BatchEntry_Proof_OneOfCase) {
  BatchEntry_Proof_OneOfCase_GPBUnsetOneOfCase = 0,
  BatchEntry_Proof_OneOfCase_Exist = 1,
  BatchEntry_Proof_OneOfCase_Nonexist = 2,
};

/**
 * Use BatchEntry not CommitmentProof, to avoid recursion
 **/
GPB_FINAL @interface BatchEntry : GPBMessage

@property(nonatomic, readonly) BatchEntry_Proof_OneOfCase proofOneOfCase;

@property(nonatomic, readwrite, strong, null_resettable) ExistenceProof *exist;

@property(nonatomic, readwrite, strong, null_resettable) NonExistenceProof *nonexist;

@end

/**
 * Clears whatever value was set for the oneof 'proof'.
 **/
void BatchEntry_ClearProofOneOfCase(BatchEntry *message);

#pragma mark - CompressedBatchProof

typedef GPB_ENUM(CompressedBatchProof_FieldNumber) {
  CompressedBatchProof_FieldNumber_EntriesArray = 1,
  CompressedBatchProof_FieldNumber_LookupInnersArray = 2,
};

GPB_FINAL @interface CompressedBatchProof : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<CompressedBatchEntry*> *entriesArray;
/** The number of items in @c entriesArray without causing the container to be created. */
@property(nonatomic, readonly) NSUInteger entriesArray_Count;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<InnerOp*> *lookupInnersArray;
/** The number of items in @c lookupInnersArray without causing the container to be created. */
@property(nonatomic, readonly) NSUInteger lookupInnersArray_Count;

@end

#pragma mark - CompressedBatchEntry

typedef GPB_ENUM(CompressedBatchEntry_FieldNumber) {
  CompressedBatchEntry_FieldNumber_Exist = 1,
  CompressedBatchEntry_FieldNumber_Nonexist = 2,
};

typedef GPB_ENUM(CompressedBatchEntry_Proof_OneOfCase) {
  CompressedBatchEntry_Proof_OneOfCase_GPBUnsetOneOfCase = 0,
  CompressedBatchEntry_Proof_OneOfCase_Exist = 1,
  CompressedBatchEntry_Proof_OneOfCase_Nonexist = 2,
};

/**
 * Use BatchEntry not CommitmentProof, to avoid recursion
 **/
GPB_FINAL @interface CompressedBatchEntry : GPBMessage

@property(nonatomic, readonly) CompressedBatchEntry_Proof_OneOfCase proofOneOfCase;

@property(nonatomic, readwrite, strong, null_resettable) CompressedExistenceProof *exist;

@property(nonatomic, readwrite, strong, null_resettable) CompressedNonExistenceProof *nonexist;

@end

/**
 * Clears whatever value was set for the oneof 'proof'.
 **/
void CompressedBatchEntry_ClearProofOneOfCase(CompressedBatchEntry *message);

#pragma mark - CompressedExistenceProof

typedef GPB_ENUM(CompressedExistenceProof_FieldNumber) {
  CompressedExistenceProof_FieldNumber_Key = 1,
  CompressedExistenceProof_FieldNumber_Value = 2,
  CompressedExistenceProof_FieldNumber_Leaf = 3,
  CompressedExistenceProof_FieldNumber_PathArray = 4,
};

GPB_FINAL @interface CompressedExistenceProof : GPBMessage

@property(nonatomic, readwrite, copy, null_resettable) NSData *key;

@property(nonatomic, readwrite, copy, null_resettable) NSData *value;

@property(nonatomic, readwrite, strong, null_resettable) LeafOp *leaf;
/** Test to see if @c leaf has been set. */
@property(nonatomic, readwrite) BOOL hasLeaf;

/** these are indexes into the lookup_inners table in CompressedBatchProof */
@property(nonatomic, readwrite, strong, null_resettable) GPBInt32Array *pathArray;
/** The number of items in @c pathArray without causing the container to be created. */
@property(nonatomic, readonly) NSUInteger pathArray_Count;

@end

#pragma mark - CompressedNonExistenceProof

typedef GPB_ENUM(CompressedNonExistenceProof_FieldNumber) {
  CompressedNonExistenceProof_FieldNumber_Key = 1,
  CompressedNonExistenceProof_FieldNumber_Left = 2,
  CompressedNonExistenceProof_FieldNumber_Right = 3,
};

GPB_FINAL @interface CompressedNonExistenceProof : GPBMessage

/** TODO: remove this as unnecessary??? we prove a range */
@property(nonatomic, readwrite, copy, null_resettable) NSData *key;

@property(nonatomic, readwrite, strong, null_resettable) CompressedExistenceProof *left;
/** Test to see if @c left has been set. */
@property(nonatomic, readwrite) BOOL hasLeft;

@property(nonatomic, readwrite, strong, null_resettable) CompressedExistenceProof *right;
/** Test to see if @c right has been set. */
@property(nonatomic, readwrite) BOOL hasRight;

@end

NS_ASSUME_NONNULL_END

CF_EXTERN_C_END

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
