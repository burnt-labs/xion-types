// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// clang-format off
// source: cosmos/ics23/v1/proofs.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import <stdatomic.h>

#import "cosmos/ics23/v1/Proofs.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(BatchEntry);
GPBObjCClassDeclaration(BatchProof);
GPBObjCClassDeclaration(CommitmentProof);
GPBObjCClassDeclaration(CompressedBatchEntry);
GPBObjCClassDeclaration(CompressedBatchProof);
GPBObjCClassDeclaration(CompressedExistenceProof);
GPBObjCClassDeclaration(CompressedNonExistenceProof);
GPBObjCClassDeclaration(ExistenceProof);
GPBObjCClassDeclaration(InnerOp);
GPBObjCClassDeclaration(InnerSpec);
GPBObjCClassDeclaration(LeafOp);
GPBObjCClassDeclaration(NonExistenceProof);
GPBObjCClassDeclaration(ProofSpec);

#pragma mark - ProofsRoot

@implementation ProofsRoot

// No extensions in the file and no imports or none of the imports (direct or
// indirect) defined extensions, so no need to generate +extensionRegistry.

@end

static GPBFileDescription ProofsRoot_FileDescription = {
  .package = "cosmos.ics23.v1",
  .prefix = NULL,
  .syntax = GPBFileSyntaxProto3
};

#pragma mark - Enum HashOp

GPBEnumDescriptor *HashOp_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "NoHash\000Sha256\000Sha512\000Keccak\000Ripemd160\000Bi"
        "tcoin\000Sha512256\000";
    static const int32_t values[] = {
        HashOp_NoHash,
        HashOp_Sha256,
        HashOp_Sha512,
        HashOp_Keccak,
        HashOp_Ripemd160,
        HashOp_Bitcoin,
        HashOp_Sha512256,
    };
    static const char *extraTextFormatInfo = "\001\006c\003\203\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(HashOp)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:HashOp_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL HashOp_IsValidValue(int32_t value__) {
  switch (value__) {
    case HashOp_NoHash:
    case HashOp_Sha256:
    case HashOp_Sha512:
    case HashOp_Keccak:
    case HashOp_Ripemd160:
    case HashOp_Bitcoin:
    case HashOp_Sha512256:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum LengthOp

GPBEnumDescriptor *LengthOp_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "NoPrefix\000VarProto\000VarRlp\000Fixed32Big\000Fixe"
        "d32Little\000Fixed64Big\000Fixed64Little\000Requi"
        "re32Bytes\000Require64Bytes\000";
    static const int32_t values[] = {
        LengthOp_NoPrefix,
        LengthOp_VarProto,
        LengthOp_VarRlp,
        LengthOp_Fixed32Big,
        LengthOp_Fixed32Little,
        LengthOp_Fixed64Big,
        LengthOp_Fixed64Little,
        LengthOp_Require32Bytes,
        LengthOp_Require64Bytes,
    };
    static const char *extraTextFormatInfo = "\002\007g\202\345\000\010g\202\345\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(LengthOp)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:LengthOp_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL LengthOp_IsValidValue(int32_t value__) {
  switch (value__) {
    case LengthOp_NoPrefix:
    case LengthOp_VarProto:
    case LengthOp_VarRlp:
    case LengthOp_Fixed32Big:
    case LengthOp_Fixed32Little:
    case LengthOp_Fixed64Big:
    case LengthOp_Fixed64Little:
    case LengthOp_Require32Bytes:
    case LengthOp_Require64Bytes:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ExistenceProof

@implementation ExistenceProof

@dynamic key;
@dynamic value;
@dynamic hasLeaf, leaf;
@dynamic pathArray, pathArray_Count;

typedef struct ExistenceProof__storage_ {
  uint32_t _has_storage_[1];
  NSData *key;
  NSData *value;
  LeafOp *leaf;
  NSMutableArray *pathArray;
} ExistenceProof__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = ExistenceProof_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExistenceProof__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = ExistenceProof_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ExistenceProof__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "leaf",
        .dataTypeSpecific.clazz = GPBObjCClass(LeafOp),
        .number = ExistenceProof_FieldNumber_Leaf,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ExistenceProof__storage_, leaf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pathArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InnerOp),
        .number = ExistenceProof_FieldNumber_PathArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ExistenceProof__storage_, pathArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ExistenceProof)
                                   messageName:@"ExistenceProof"
                               fileDescription:&ProofsRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExistenceProof__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NonExistenceProof

@implementation NonExistenceProof

@dynamic key;
@dynamic hasLeft, left;
@dynamic hasRight, right;

typedef struct NonExistenceProof__storage_ {
  uint32_t _has_storage_[1];
  NSData *key;
  ExistenceProof *left;
  ExistenceProof *right;
} NonExistenceProof__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = NonExistenceProof_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NonExistenceProof__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "left",
        .dataTypeSpecific.clazz = GPBObjCClass(ExistenceProof),
        .number = NonExistenceProof_FieldNumber_Left,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NonExistenceProof__storage_, left),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "right",
        .dataTypeSpecific.clazz = GPBObjCClass(ExistenceProof),
        .number = NonExistenceProof_FieldNumber_Right,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NonExistenceProof__storage_, right),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(NonExistenceProof)
                                   messageName:@"NonExistenceProof"
                               fileDescription:&ProofsRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NonExistenceProof__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CommitmentProof

@implementation CommitmentProof

@dynamic proofOneOfCase;
@dynamic exist;
@dynamic nonexist;
@dynamic batch;
@dynamic compressed;

typedef struct CommitmentProof__storage_ {
  uint32_t _has_storage_[2];
  ExistenceProof *exist;
  NonExistenceProof *nonexist;
  BatchProof *batch;
  CompressedBatchProof *compressed;
} CommitmentProof__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "exist",
        .dataTypeSpecific.clazz = GPBObjCClass(ExistenceProof),
        .number = CommitmentProof_FieldNumber_Exist,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(CommitmentProof__storage_, exist),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nonexist",
        .dataTypeSpecific.clazz = GPBObjCClass(NonExistenceProof),
        .number = CommitmentProof_FieldNumber_Nonexist,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(CommitmentProof__storage_, nonexist),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "batch",
        .dataTypeSpecific.clazz = GPBObjCClass(BatchProof),
        .number = CommitmentProof_FieldNumber_Batch,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(CommitmentProof__storage_, batch),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "compressed",
        .dataTypeSpecific.clazz = GPBObjCClass(CompressedBatchProof),
        .number = CommitmentProof_FieldNumber_Compressed,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(CommitmentProof__storage_, compressed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CommitmentProof)
                                   messageName:@"CommitmentProof"
                               fileDescription:&ProofsRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CommitmentProof__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    static const char *oneofs[] = {
      "proof",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void CommitmentProof_ClearProofOneOfCase(CommitmentProof *message) {
  GPBDescriptor *descriptor = [CommitmentProof descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - LeafOp

@implementation LeafOp

@dynamic hash_p;
@dynamic prehashKey;
@dynamic prehashValue;
@dynamic length;
@dynamic prefix;

typedef struct LeafOp__storage_ {
  uint32_t _has_storage_[1];
  HashOp hash_p;
  HashOp prehashKey;
  HashOp prehashValue;
  LengthOp length;
  NSData *prefix;
} LeafOp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.enumDescFunc = HashOp_EnumDescriptor,
        .number = LeafOp_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LeafOp__storage_, hash_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "prehashKey",
        .dataTypeSpecific.enumDescFunc = HashOp_EnumDescriptor,
        .number = LeafOp_FieldNumber_PrehashKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LeafOp__storage_, prehashKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "prehashValue",
        .dataTypeSpecific.enumDescFunc = HashOp_EnumDescriptor,
        .number = LeafOp_FieldNumber_PrehashValue,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LeafOp__storage_, prehashValue),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "length",
        .dataTypeSpecific.enumDescFunc = LengthOp_EnumDescriptor,
        .number = LeafOp_FieldNumber_Length,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LeafOp__storage_, length),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "prefix",
        .dataTypeSpecific.clazz = Nil,
        .number = LeafOp_FieldNumber_Prefix,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LeafOp__storage_, prefix),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(LeafOp)
                                   messageName:@"LeafOp"
                               fileDescription:&ProofsRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LeafOp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t LeafOp_Hash_p_RawValue(LeafOp *message) {
  GPBDescriptor *descriptor = [LeafOp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LeafOp_FieldNumber_Hash_p];
  return GPBGetMessageRawEnumField(message, field);
}

void SetLeafOp_Hash_p_RawValue(LeafOp *message, int32_t value) {
  GPBDescriptor *descriptor = [LeafOp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LeafOp_FieldNumber_Hash_p];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t LeafOp_PrehashKey_RawValue(LeafOp *message) {
  GPBDescriptor *descriptor = [LeafOp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LeafOp_FieldNumber_PrehashKey];
  return GPBGetMessageRawEnumField(message, field);
}

void SetLeafOp_PrehashKey_RawValue(LeafOp *message, int32_t value) {
  GPBDescriptor *descriptor = [LeafOp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LeafOp_FieldNumber_PrehashKey];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t LeafOp_PrehashValue_RawValue(LeafOp *message) {
  GPBDescriptor *descriptor = [LeafOp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LeafOp_FieldNumber_PrehashValue];
  return GPBGetMessageRawEnumField(message, field);
}

void SetLeafOp_PrehashValue_RawValue(LeafOp *message, int32_t value) {
  GPBDescriptor *descriptor = [LeafOp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LeafOp_FieldNumber_PrehashValue];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t LeafOp_Length_RawValue(LeafOp *message) {
  GPBDescriptor *descriptor = [LeafOp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LeafOp_FieldNumber_Length];
  return GPBGetMessageRawEnumField(message, field);
}

void SetLeafOp_Length_RawValue(LeafOp *message, int32_t value) {
  GPBDescriptor *descriptor = [LeafOp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LeafOp_FieldNumber_Length];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - InnerOp

@implementation InnerOp

@dynamic hash_p;
@dynamic prefix;
@dynamic suffix;

typedef struct InnerOp__storage_ {
  uint32_t _has_storage_[1];
  HashOp hash_p;
  NSData *prefix;
  NSData *suffix;
} InnerOp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.enumDescFunc = HashOp_EnumDescriptor,
        .number = InnerOp_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InnerOp__storage_, hash_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "prefix",
        .dataTypeSpecific.clazz = Nil,
        .number = InnerOp_FieldNumber_Prefix,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InnerOp__storage_, prefix),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "suffix",
        .dataTypeSpecific.clazz = Nil,
        .number = InnerOp_FieldNumber_Suffix,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InnerOp__storage_, suffix),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(InnerOp)
                                   messageName:@"InnerOp"
                               fileDescription:&ProofsRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InnerOp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t InnerOp_Hash_p_RawValue(InnerOp *message) {
  GPBDescriptor *descriptor = [InnerOp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:InnerOp_FieldNumber_Hash_p];
  return GPBGetMessageRawEnumField(message, field);
}

void SetInnerOp_Hash_p_RawValue(InnerOp *message, int32_t value) {
  GPBDescriptor *descriptor = [InnerOp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:InnerOp_FieldNumber_Hash_p];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ProofSpec

@implementation ProofSpec

@dynamic hasLeafSpec, leafSpec;
@dynamic hasInnerSpec, innerSpec;
@dynamic maxDepth;
@dynamic minDepth;

typedef struct ProofSpec__storage_ {
  uint32_t _has_storage_[1];
  int32_t maxDepth;
  int32_t minDepth;
  LeafOp *leafSpec;
  InnerSpec *innerSpec;
} ProofSpec__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "leafSpec",
        .dataTypeSpecific.clazz = GPBObjCClass(LeafOp),
        .number = ProofSpec_FieldNumber_LeafSpec,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProofSpec__storage_, leafSpec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "innerSpec",
        .dataTypeSpecific.clazz = GPBObjCClass(InnerSpec),
        .number = ProofSpec_FieldNumber_InnerSpec,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ProofSpec__storage_, innerSpec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "maxDepth",
        .dataTypeSpecific.clazz = Nil,
        .number = ProofSpec_FieldNumber_MaxDepth,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ProofSpec__storage_, maxDepth),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "minDepth",
        .dataTypeSpecific.clazz = Nil,
        .number = ProofSpec_FieldNumber_MinDepth,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ProofSpec__storage_, minDepth),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ProofSpec)
                                   messageName:@"ProofSpec"
                               fileDescription:&ProofsRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProofSpec__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InnerSpec

@implementation InnerSpec

@dynamic childOrderArray, childOrderArray_Count;
@dynamic childSize;
@dynamic minPrefixLength;
@dynamic maxPrefixLength;
@dynamic emptyChild;
@dynamic hash_p;

typedef struct InnerSpec__storage_ {
  uint32_t _has_storage_[1];
  int32_t childSize;
  int32_t minPrefixLength;
  int32_t maxPrefixLength;
  HashOp hash_p;
  GPBInt32Array *childOrderArray;
  NSData *emptyChild;
} InnerSpec__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "childOrderArray",
        .dataTypeSpecific.clazz = Nil,
        .number = InnerSpec_FieldNumber_ChildOrderArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InnerSpec__storage_, childOrderArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "childSize",
        .dataTypeSpecific.clazz = Nil,
        .number = InnerSpec_FieldNumber_ChildSize,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InnerSpec__storage_, childSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "minPrefixLength",
        .dataTypeSpecific.clazz = Nil,
        .number = InnerSpec_FieldNumber_MinPrefixLength,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InnerSpec__storage_, minPrefixLength),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxPrefixLength",
        .dataTypeSpecific.clazz = Nil,
        .number = InnerSpec_FieldNumber_MaxPrefixLength,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InnerSpec__storage_, maxPrefixLength),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "emptyChild",
        .dataTypeSpecific.clazz = Nil,
        .number = InnerSpec_FieldNumber_EmptyChild,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(InnerSpec__storage_, emptyChild),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "hash_p",
        .dataTypeSpecific.enumDescFunc = HashOp_EnumDescriptor,
        .number = InnerSpec_FieldNumber_Hash_p,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(InnerSpec__storage_, hash_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(InnerSpec)
                                   messageName:@"InnerSpec"
                               fileDescription:&ProofsRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InnerSpec__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t InnerSpec_Hash_p_RawValue(InnerSpec *message) {
  GPBDescriptor *descriptor = [InnerSpec descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:InnerSpec_FieldNumber_Hash_p];
  return GPBGetMessageRawEnumField(message, field);
}

void SetInnerSpec_Hash_p_RawValue(InnerSpec *message, int32_t value) {
  GPBDescriptor *descriptor = [InnerSpec descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:InnerSpec_FieldNumber_Hash_p];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - BatchProof

@implementation BatchProof

@dynamic entriesArray, entriesArray_Count;

typedef struct BatchProof__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *entriesArray;
} BatchProof__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "entriesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BatchEntry),
        .number = BatchProof_FieldNumber_EntriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BatchProof__storage_, entriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BatchProof)
                                   messageName:@"BatchProof"
                               fileDescription:&ProofsRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BatchProof__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BatchEntry

@implementation BatchEntry

@dynamic proofOneOfCase;
@dynamic exist;
@dynamic nonexist;

typedef struct BatchEntry__storage_ {
  uint32_t _has_storage_[2];
  ExistenceProof *exist;
  NonExistenceProof *nonexist;
} BatchEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "exist",
        .dataTypeSpecific.clazz = GPBObjCClass(ExistenceProof),
        .number = BatchEntry_FieldNumber_Exist,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(BatchEntry__storage_, exist),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nonexist",
        .dataTypeSpecific.clazz = GPBObjCClass(NonExistenceProof),
        .number = BatchEntry_FieldNumber_Nonexist,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(BatchEntry__storage_, nonexist),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BatchEntry)
                                   messageName:@"BatchEntry"
                               fileDescription:&ProofsRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BatchEntry__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    static const char *oneofs[] = {
      "proof",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void BatchEntry_ClearProofOneOfCase(BatchEntry *message) {
  GPBDescriptor *descriptor = [BatchEntry descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - CompressedBatchProof

@implementation CompressedBatchProof

@dynamic entriesArray, entriesArray_Count;
@dynamic lookupInnersArray, lookupInnersArray_Count;

typedef struct CompressedBatchProof__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *entriesArray;
  NSMutableArray *lookupInnersArray;
} CompressedBatchProof__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "entriesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(CompressedBatchEntry),
        .number = CompressedBatchProof_FieldNumber_EntriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CompressedBatchProof__storage_, entriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lookupInnersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(InnerOp),
        .number = CompressedBatchProof_FieldNumber_LookupInnersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CompressedBatchProof__storage_, lookupInnersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CompressedBatchProof)
                                   messageName:@"CompressedBatchProof"
                               fileDescription:&ProofsRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CompressedBatchProof__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CompressedBatchEntry

@implementation CompressedBatchEntry

@dynamic proofOneOfCase;
@dynamic exist;
@dynamic nonexist;

typedef struct CompressedBatchEntry__storage_ {
  uint32_t _has_storage_[2];
  CompressedExistenceProof *exist;
  CompressedNonExistenceProof *nonexist;
} CompressedBatchEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "exist",
        .dataTypeSpecific.clazz = GPBObjCClass(CompressedExistenceProof),
        .number = CompressedBatchEntry_FieldNumber_Exist,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(CompressedBatchEntry__storage_, exist),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nonexist",
        .dataTypeSpecific.clazz = GPBObjCClass(CompressedNonExistenceProof),
        .number = CompressedBatchEntry_FieldNumber_Nonexist,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(CompressedBatchEntry__storage_, nonexist),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CompressedBatchEntry)
                                   messageName:@"CompressedBatchEntry"
                               fileDescription:&ProofsRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CompressedBatchEntry__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    static const char *oneofs[] = {
      "proof",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void CompressedBatchEntry_ClearProofOneOfCase(CompressedBatchEntry *message) {
  GPBDescriptor *descriptor = [CompressedBatchEntry descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - CompressedExistenceProof

@implementation CompressedExistenceProof

@dynamic key;
@dynamic value;
@dynamic hasLeaf, leaf;
@dynamic pathArray, pathArray_Count;

typedef struct CompressedExistenceProof__storage_ {
  uint32_t _has_storage_[1];
  NSData *key;
  NSData *value;
  LeafOp *leaf;
  GPBInt32Array *pathArray;
} CompressedExistenceProof__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = CompressedExistenceProof_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CompressedExistenceProof__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = CompressedExistenceProof_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CompressedExistenceProof__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "leaf",
        .dataTypeSpecific.clazz = GPBObjCClass(LeafOp),
        .number = CompressedExistenceProof_FieldNumber_Leaf,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CompressedExistenceProof__storage_, leaf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pathArray",
        .dataTypeSpecific.clazz = Nil,
        .number = CompressedExistenceProof_FieldNumber_PathArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CompressedExistenceProof__storage_, pathArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CompressedExistenceProof)
                                   messageName:@"CompressedExistenceProof"
                               fileDescription:&ProofsRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CompressedExistenceProof__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CompressedNonExistenceProof

@implementation CompressedNonExistenceProof

@dynamic key;
@dynamic hasLeft, left;
@dynamic hasRight, right;

typedef struct CompressedNonExistenceProof__storage_ {
  uint32_t _has_storage_[1];
  NSData *key;
  CompressedExistenceProof *left;
  CompressedExistenceProof *right;
} CompressedNonExistenceProof__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = CompressedNonExistenceProof_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CompressedNonExistenceProof__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "left",
        .dataTypeSpecific.clazz = GPBObjCClass(CompressedExistenceProof),
        .number = CompressedNonExistenceProof_FieldNumber_Left,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CompressedNonExistenceProof__storage_, left),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "right",
        .dataTypeSpecific.clazz = GPBObjCClass(CompressedExistenceProof),
        .number = CompressedNonExistenceProof_FieldNumber_Right,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CompressedNonExistenceProof__storage_, right),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CompressedNonExistenceProof)
                                   messageName:@"CompressedNonExistenceProof"
                               fileDescription:&ProofsRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CompressedNonExistenceProof__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
