// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// clang-format off
// source: cosmos/staking/v1beta1/staking.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import <stdatomic.h>

#import "cosmos/staking/v1beta1/Staking.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Coin);
GPBObjCClassDeclaration(Commission);
GPBObjCClassDeclaration(CommissionRates);
GPBObjCClassDeclaration(DVPair);
GPBObjCClassDeclaration(DVPairs);
GPBObjCClassDeclaration(DVVTriplet);
GPBObjCClassDeclaration(DVVTriplets);
GPBObjCClassDeclaration(Delegation);
GPBObjCClassDeclaration(DelegationResponse);
GPBObjCClassDeclaration(Description);
GPBObjCClassDeclaration(GPBAny);
GPBObjCClassDeclaration(GPBDuration);
GPBObjCClassDeclaration(GPBTimestamp);
GPBObjCClassDeclaration(Header);
GPBObjCClassDeclaration(HistoricalInfo);
GPBObjCClassDeclaration(Params);
GPBObjCClassDeclaration(Pool);
GPBObjCClassDeclaration(Redelegation);
GPBObjCClassDeclaration(RedelegationEntry);
GPBObjCClassDeclaration(RedelegationEntryResponse);
GPBObjCClassDeclaration(RedelegationResponse);
GPBObjCClassDeclaration(UnbondingDelegation);
GPBObjCClassDeclaration(UnbondingDelegationEntry);
GPBObjCClassDeclaration(ValAddresses);
GPBObjCClassDeclaration(Validator);
GPBObjCClassDeclaration(ValidatorUpdate);
GPBObjCClassDeclaration(ValidatorUpdates);

#pragma mark - StakingRoot

@implementation StakingRoot

// No extensions in the file and no imports or none of the imports (direct or
// indirect) defined extensions, so no need to generate +extensionRegistry.

@end

static GPBFileDescription StakingRoot_FileDescription = {
  .package = "cosmos.staking.v1beta1",
  .prefix = NULL,
  .syntax = GPBFileSyntaxProto3
};

#pragma mark - Enum BondStatus

GPBEnumDescriptor *BondStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "BondStatusUnspecified\000BondStatusUnbonded"
        "\000BondStatusUnbonding\000BondStatusBonded\000";
    static const int32_t values[] = {
        BondStatus_BondStatusUnspecified,
        BondStatus_BondStatusUnbonded,
        BondStatus_BondStatusUnbonding,
        BondStatus_BondStatusBonded,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BondStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BondStatus_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BondStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case BondStatus_BondStatusUnspecified:
    case BondStatus_BondStatusUnbonded:
    case BondStatus_BondStatusUnbonding:
    case BondStatus_BondStatusBonded:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Infraction

GPBEnumDescriptor *Infraction_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "InfractionUnspecified\000InfractionDoubleSi"
        "gn\000InfractionDowntime\000";
    static const int32_t values[] = {
        Infraction_InfractionUnspecified,
        Infraction_InfractionDoubleSign,
        Infraction_InfractionDowntime,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Infraction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Infraction_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Infraction_IsValidValue(int32_t value__) {
  switch (value__) {
    case Infraction_InfractionUnspecified:
    case Infraction_InfractionDoubleSign:
    case Infraction_InfractionDowntime:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - HistoricalInfo

@implementation HistoricalInfo

@dynamic hasHeader, header;
@dynamic valsetArray, valsetArray_Count;

typedef struct HistoricalInfo__storage_ {
  uint32_t _has_storage_[1];
  Header *header;
  NSMutableArray *valsetArray;
} HistoricalInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.clazz = GPBObjCClass(Header),
        .number = HistoricalInfo_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HistoricalInfo__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "valsetArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Validator),
        .number = HistoricalInfo_FieldNumber_ValsetArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(HistoricalInfo__storage_, valsetArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(HistoricalInfo)
                                   messageName:@"HistoricalInfo"
                               fileDescription:&StakingRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HistoricalInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CommissionRates

@implementation CommissionRates

@dynamic rate;
@dynamic maxRate;
@dynamic maxChangeRate;

typedef struct CommissionRates__storage_ {
  uint32_t _has_storage_[1];
  NSString *rate;
  NSString *maxRate;
  NSString *maxChangeRate;
} CommissionRates__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rate",
        .dataTypeSpecific.clazz = Nil,
        .number = CommissionRates_FieldNumber_Rate,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CommissionRates__storage_, rate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "maxRate",
        .dataTypeSpecific.clazz = Nil,
        .number = CommissionRates_FieldNumber_MaxRate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CommissionRates__storage_, maxRate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "maxChangeRate",
        .dataTypeSpecific.clazz = Nil,
        .number = CommissionRates_FieldNumber_MaxChangeRate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CommissionRates__storage_, maxChangeRate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CommissionRates)
                                   messageName:@"CommissionRates"
                               fileDescription:&StakingRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CommissionRates__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Commission

@implementation Commission

@dynamic hasCommissionRates, commissionRates;
@dynamic hasUpdateTime, updateTime;

typedef struct Commission__storage_ {
  uint32_t _has_storage_[1];
  CommissionRates *commissionRates;
  GPBTimestamp *updateTime;
} Commission__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "commissionRates",
        .dataTypeSpecific.clazz = GPBObjCClass(CommissionRates),
        .number = Commission_FieldNumber_CommissionRates,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Commission__storage_, commissionRates),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "updateTime",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = Commission_FieldNumber_UpdateTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Commission__storage_, updateTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Commission)
                                   messageName:@"Commission"
                               fileDescription:&StakingRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Commission__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Description

@implementation Description

@dynamic moniker;
@dynamic identity;
@dynamic website;
@dynamic securityContact;
@dynamic details;

typedef struct Description__storage_ {
  uint32_t _has_storage_[1];
  NSString *moniker;
  NSString *identity;
  NSString *website;
  NSString *securityContact;
  NSString *details;
} Description__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "moniker",
        .dataTypeSpecific.clazz = Nil,
        .number = Description_FieldNumber_Moniker,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Description__storage_, moniker),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "identity",
        .dataTypeSpecific.clazz = Nil,
        .number = Description_FieldNumber_Identity,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Description__storage_, identity),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "website",
        .dataTypeSpecific.clazz = Nil,
        .number = Description_FieldNumber_Website,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Description__storage_, website),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "securityContact",
        .dataTypeSpecific.clazz = Nil,
        .number = Description_FieldNumber_SecurityContact,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Description__storage_, securityContact),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "details",
        .dataTypeSpecific.clazz = Nil,
        .number = Description_FieldNumber_Details,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Description__storage_, details),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Description)
                                   messageName:@"Description"
                               fileDescription:&StakingRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Description__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Validator

@implementation Validator

@dynamic operatorAddress;
@dynamic hasConsensusPubkey, consensusPubkey;
@dynamic jailed;
@dynamic status;
@dynamic tokens;
@dynamic delegatorShares;
@dynamic hasDescription_p, description_p;
@dynamic unbondingHeight;
@dynamic hasUnbondingTime, unbondingTime;
@dynamic hasCommission, commission;
@dynamic minSelfDelegation;
@dynamic unbondingOnHoldRefCount;
@dynamic unbondingIdsArray, unbondingIdsArray_Count;

typedef struct Validator__storage_ {
  uint32_t _has_storage_[1];
  BondStatus status;
  NSString *operatorAddress;
  GPBAny *consensusPubkey;
  NSString *tokens;
  NSString *delegatorShares;
  Description *description_p;
  GPBTimestamp *unbondingTime;
  Commission *commission;
  NSString *minSelfDelegation;
  GPBUInt64Array *unbondingIdsArray;
  int64_t unbondingHeight;
  int64_t unbondingOnHoldRefCount;
} Validator__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "operatorAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = Validator_FieldNumber_OperatorAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Validator__storage_, operatorAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "consensusPubkey",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBAny),
        .number = Validator_FieldNumber_ConsensusPubkey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Validator__storage_, consensusPubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "jailed",
        .dataTypeSpecific.clazz = Nil,
        .number = Validator_FieldNumber_Jailed,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = BondStatus_EnumDescriptor,
        .number = Validator_FieldNumber_Status,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Validator__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "tokens",
        .dataTypeSpecific.clazz = Nil,
        .number = Validator_FieldNumber_Tokens,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Validator__storage_, tokens),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "delegatorShares",
        .dataTypeSpecific.clazz = Nil,
        .number = Validator_FieldNumber_DelegatorShares,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Validator__storage_, delegatorShares),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = GPBObjCClass(Description),
        .number = Validator_FieldNumber_Description_p,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Validator__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unbondingHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = Validator_FieldNumber_UnbondingHeight,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Validator__storage_, unbondingHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unbondingTime",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = Validator_FieldNumber_UnbondingTime,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Validator__storage_, unbondingTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "commission",
        .dataTypeSpecific.clazz = GPBObjCClass(Commission),
        .number = Validator_FieldNumber_Commission,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Validator__storage_, commission),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "minSelfDelegation",
        .dataTypeSpecific.clazz = Nil,
        .number = Validator_FieldNumber_MinSelfDelegation,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Validator__storage_, minSelfDelegation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "unbondingOnHoldRefCount",
        .dataTypeSpecific.clazz = Nil,
        .number = Validator_FieldNumber_UnbondingOnHoldRefCount,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Validator__storage_, unbondingOnHoldRefCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unbondingIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Validator_FieldNumber_UnbondingIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Validator__storage_, unbondingIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Validator)
                                   messageName:@"Validator"
                               fileDescription:&StakingRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Validator__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Validator_Status_RawValue(Validator *message) {
  GPBDescriptor *descriptor = [Validator descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Validator_FieldNumber_Status];
  return GPBGetMessageRawEnumField(message, field);
}

void SetValidator_Status_RawValue(Validator *message, int32_t value) {
  GPBDescriptor *descriptor = [Validator descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Validator_FieldNumber_Status];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ValAddresses

@implementation ValAddresses

@dynamic addressesArray, addressesArray_Count;

typedef struct ValAddresses__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addressesArray;
} ValAddresses__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ValAddresses_FieldNumber_AddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ValAddresses__storage_, addressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ValAddresses)
                                   messageName:@"ValAddresses"
                               fileDescription:&StakingRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ValAddresses__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DVPair

@implementation DVPair

@dynamic delegatorAddress;
@dynamic validatorAddress;

typedef struct DVPair__storage_ {
  uint32_t _has_storage_[1];
  NSString *delegatorAddress;
  NSString *validatorAddress;
} DVPair__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "delegatorAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = DVPair_FieldNumber_DelegatorAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DVPair__storage_, delegatorAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "validatorAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = DVPair_FieldNumber_ValidatorAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DVPair__storage_, validatorAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DVPair)
                                   messageName:@"DVPair"
                               fileDescription:&StakingRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DVPair__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DVPairs

@implementation DVPairs

@dynamic pairsArray, pairsArray_Count;

typedef struct DVPairs__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *pairsArray;
} DVPairs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pairsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DVPair),
        .number = DVPairs_FieldNumber_PairsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DVPairs__storage_, pairsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DVPairs)
                                   messageName:@"DVPairs"
                               fileDescription:&StakingRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DVPairs__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DVVTriplet

@implementation DVVTriplet

@dynamic delegatorAddress;
@dynamic validatorSrcAddress;
@dynamic validatorDstAddress;

typedef struct DVVTriplet__storage_ {
  uint32_t _has_storage_[1];
  NSString *delegatorAddress;
  NSString *validatorSrcAddress;
  NSString *validatorDstAddress;
} DVVTriplet__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "delegatorAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = DVVTriplet_FieldNumber_DelegatorAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DVVTriplet__storage_, delegatorAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "validatorSrcAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = DVVTriplet_FieldNumber_ValidatorSrcAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DVVTriplet__storage_, validatorSrcAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "validatorDstAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = DVVTriplet_FieldNumber_ValidatorDstAddress,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DVVTriplet__storage_, validatorDstAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DVVTriplet)
                                   messageName:@"DVVTriplet"
                               fileDescription:&StakingRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DVVTriplet__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DVVTriplets

@implementation DVVTriplets

@dynamic tripletsArray, tripletsArray_Count;

typedef struct DVVTriplets__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *tripletsArray;
} DVVTriplets__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tripletsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DVVTriplet),
        .number = DVVTriplets_FieldNumber_TripletsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DVVTriplets__storage_, tripletsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DVVTriplets)
                                   messageName:@"DVVTriplets"
                               fileDescription:&StakingRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DVVTriplets__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Delegation

@implementation Delegation

@dynamic delegatorAddress;
@dynamic validatorAddress;
@dynamic shares;

typedef struct Delegation__storage_ {
  uint32_t _has_storage_[1];
  NSString *delegatorAddress;
  NSString *validatorAddress;
  NSString *shares;
} Delegation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "delegatorAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = Delegation_FieldNumber_DelegatorAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Delegation__storage_, delegatorAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "validatorAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = Delegation_FieldNumber_ValidatorAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Delegation__storage_, validatorAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shares",
        .dataTypeSpecific.clazz = Nil,
        .number = Delegation_FieldNumber_Shares,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Delegation__storage_, shares),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Delegation)
                                   messageName:@"Delegation"
                               fileDescription:&StakingRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Delegation__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnbondingDelegation

@implementation UnbondingDelegation

@dynamic delegatorAddress;
@dynamic validatorAddress;
@dynamic entriesArray, entriesArray_Count;

typedef struct UnbondingDelegation__storage_ {
  uint32_t _has_storage_[1];
  NSString *delegatorAddress;
  NSString *validatorAddress;
  NSMutableArray *entriesArray;
} UnbondingDelegation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "delegatorAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = UnbondingDelegation_FieldNumber_DelegatorAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnbondingDelegation__storage_, delegatorAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "validatorAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = UnbondingDelegation_FieldNumber_ValidatorAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnbondingDelegation__storage_, validatorAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "entriesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UnbondingDelegationEntry),
        .number = UnbondingDelegation_FieldNumber_EntriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UnbondingDelegation__storage_, entriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UnbondingDelegation)
                                   messageName:@"UnbondingDelegation"
                               fileDescription:&StakingRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnbondingDelegation__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnbondingDelegationEntry

@implementation UnbondingDelegationEntry

@dynamic creationHeight;
@dynamic hasCompletionTime, completionTime;
@dynamic initialBalance;
@dynamic balance;
@dynamic unbondingId;
@dynamic unbondingOnHoldRefCount;

typedef struct UnbondingDelegationEntry__storage_ {
  uint32_t _has_storage_[1];
  GPBTimestamp *completionTime;
  NSString *initialBalance;
  NSString *balance;
  int64_t creationHeight;
  uint64_t unbondingId;
  int64_t unbondingOnHoldRefCount;
} UnbondingDelegationEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "creationHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = UnbondingDelegationEntry_FieldNumber_CreationHeight,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnbondingDelegationEntry__storage_, creationHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "completionTime",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = UnbondingDelegationEntry_FieldNumber_CompletionTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnbondingDelegationEntry__storage_, completionTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "initialBalance",
        .dataTypeSpecific.clazz = Nil,
        .number = UnbondingDelegationEntry_FieldNumber_InitialBalance,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UnbondingDelegationEntry__storage_, initialBalance),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "balance",
        .dataTypeSpecific.clazz = Nil,
        .number = UnbondingDelegationEntry_FieldNumber_Balance,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UnbondingDelegationEntry__storage_, balance),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "unbondingId",
        .dataTypeSpecific.clazz = Nil,
        .number = UnbondingDelegationEntry_FieldNumber_UnbondingId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UnbondingDelegationEntry__storage_, unbondingId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "unbondingOnHoldRefCount",
        .dataTypeSpecific.clazz = Nil,
        .number = UnbondingDelegationEntry_FieldNumber_UnbondingOnHoldRefCount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UnbondingDelegationEntry__storage_, unbondingOnHoldRefCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UnbondingDelegationEntry)
                                   messageName:@"UnbondingDelegationEntry"
                               fileDescription:&StakingRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnbondingDelegationEntry__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RedelegationEntry

@implementation RedelegationEntry

@dynamic creationHeight;
@dynamic hasCompletionTime, completionTime;
@dynamic initialBalance;
@dynamic sharesDst;
@dynamic unbondingId;
@dynamic unbondingOnHoldRefCount;

typedef struct RedelegationEntry__storage_ {
  uint32_t _has_storage_[1];
  GPBTimestamp *completionTime;
  NSString *initialBalance;
  NSString *sharesDst;
  int64_t creationHeight;
  uint64_t unbondingId;
  int64_t unbondingOnHoldRefCount;
} RedelegationEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "creationHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = RedelegationEntry_FieldNumber_CreationHeight,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedelegationEntry__storage_, creationHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "completionTime",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = RedelegationEntry_FieldNumber_CompletionTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedelegationEntry__storage_, completionTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "initialBalance",
        .dataTypeSpecific.clazz = Nil,
        .number = RedelegationEntry_FieldNumber_InitialBalance,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RedelegationEntry__storage_, initialBalance),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sharesDst",
        .dataTypeSpecific.clazz = Nil,
        .number = RedelegationEntry_FieldNumber_SharesDst,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RedelegationEntry__storage_, sharesDst),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "unbondingId",
        .dataTypeSpecific.clazz = Nil,
        .number = RedelegationEntry_FieldNumber_UnbondingId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RedelegationEntry__storage_, unbondingId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "unbondingOnHoldRefCount",
        .dataTypeSpecific.clazz = Nil,
        .number = RedelegationEntry_FieldNumber_UnbondingOnHoldRefCount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RedelegationEntry__storage_, unbondingOnHoldRefCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RedelegationEntry)
                                   messageName:@"RedelegationEntry"
                               fileDescription:&StakingRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedelegationEntry__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Redelegation

@implementation Redelegation

@dynamic delegatorAddress;
@dynamic validatorSrcAddress;
@dynamic validatorDstAddress;
@dynamic entriesArray, entriesArray_Count;

typedef struct Redelegation__storage_ {
  uint32_t _has_storage_[1];
  NSString *delegatorAddress;
  NSString *validatorSrcAddress;
  NSString *validatorDstAddress;
  NSMutableArray *entriesArray;
} Redelegation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "delegatorAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = Redelegation_FieldNumber_DelegatorAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Redelegation__storage_, delegatorAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "validatorSrcAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = Redelegation_FieldNumber_ValidatorSrcAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Redelegation__storage_, validatorSrcAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "validatorDstAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = Redelegation_FieldNumber_ValidatorDstAddress,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Redelegation__storage_, validatorDstAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "entriesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(RedelegationEntry),
        .number = Redelegation_FieldNumber_EntriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Redelegation__storage_, entriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Redelegation)
                                   messageName:@"Redelegation"
                               fileDescription:&StakingRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Redelegation__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Params

@implementation Params

@dynamic hasUnbondingTime, unbondingTime;
@dynamic maxValidators;
@dynamic maxEntries;
@dynamic historicalEntries;
@dynamic bondDenom;
@dynamic minCommissionRate;

typedef struct Params__storage_ {
  uint32_t _has_storage_[1];
  uint32_t maxValidators;
  uint32_t maxEntries;
  uint32_t historicalEntries;
  GPBDuration *unbondingTime;
  NSString *bondDenom;
  NSString *minCommissionRate;
} Params__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "unbondingTime",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBDuration),
        .number = Params_FieldNumber_UnbondingTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Params__storage_, unbondingTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "maxValidators",
        .dataTypeSpecific.clazz = Nil,
        .number = Params_FieldNumber_MaxValidators,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Params__storage_, maxValidators),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "maxEntries",
        .dataTypeSpecific.clazz = Nil,
        .number = Params_FieldNumber_MaxEntries,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Params__storage_, maxEntries),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "historicalEntries",
        .dataTypeSpecific.clazz = Nil,
        .number = Params_FieldNumber_HistoricalEntries,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Params__storage_, historicalEntries),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bondDenom",
        .dataTypeSpecific.clazz = Nil,
        .number = Params_FieldNumber_BondDenom,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Params__storage_, bondDenom),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "minCommissionRate",
        .dataTypeSpecific.clazz = Nil,
        .number = Params_FieldNumber_MinCommissionRate,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Params__storage_, minCommissionRate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Params)
                                   messageName:@"Params"
                               fileDescription:&StakingRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Params__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DelegationResponse

@implementation DelegationResponse

@dynamic hasDelegation, delegation;
@dynamic hasBalance, balance;

typedef struct DelegationResponse__storage_ {
  uint32_t _has_storage_[1];
  Delegation *delegation;
  Coin *balance;
} DelegationResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "delegation",
        .dataTypeSpecific.clazz = GPBObjCClass(Delegation),
        .number = DelegationResponse_FieldNumber_Delegation,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DelegationResponse__storage_, delegation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "balance",
        .dataTypeSpecific.clazz = GPBObjCClass(Coin),
        .number = DelegationResponse_FieldNumber_Balance,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DelegationResponse__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DelegationResponse)
                                   messageName:@"DelegationResponse"
                               fileDescription:&StakingRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelegationResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RedelegationEntryResponse

@implementation RedelegationEntryResponse

@dynamic hasRedelegationEntry, redelegationEntry;
@dynamic balance;

typedef struct RedelegationEntryResponse__storage_ {
  uint32_t _has_storage_[1];
  RedelegationEntry *redelegationEntry;
  NSString *balance;
} RedelegationEntryResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "redelegationEntry",
        .dataTypeSpecific.clazz = GPBObjCClass(RedelegationEntry),
        .number = RedelegationEntryResponse_FieldNumber_RedelegationEntry,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedelegationEntryResponse__storage_, redelegationEntry),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "balance",
        .dataTypeSpecific.clazz = Nil,
        .number = RedelegationEntryResponse_FieldNumber_Balance,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedelegationEntryResponse__storage_, balance),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RedelegationEntryResponse)
                                   messageName:@"RedelegationEntryResponse"
                               fileDescription:&StakingRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedelegationEntryResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RedelegationResponse

@implementation RedelegationResponse

@dynamic hasRedelegation, redelegation;
@dynamic entriesArray, entriesArray_Count;

typedef struct RedelegationResponse__storage_ {
  uint32_t _has_storage_[1];
  Redelegation *redelegation;
  NSMutableArray *entriesArray;
} RedelegationResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "redelegation",
        .dataTypeSpecific.clazz = GPBObjCClass(Redelegation),
        .number = RedelegationResponse_FieldNumber_Redelegation,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedelegationResponse__storage_, redelegation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "entriesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(RedelegationEntryResponse),
        .number = RedelegationResponse_FieldNumber_EntriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedelegationResponse__storage_, entriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RedelegationResponse)
                                   messageName:@"RedelegationResponse"
                               fileDescription:&StakingRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedelegationResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Pool

@implementation Pool

@dynamic notBondedTokens;
@dynamic bondedTokens;

typedef struct Pool__storage_ {
  uint32_t _has_storage_[1];
  NSString *notBondedTokens;
  NSString *bondedTokens;
} Pool__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "notBondedTokens",
        .dataTypeSpecific.clazz = Nil,
        .number = Pool_FieldNumber_NotBondedTokens,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Pool__storage_, notBondedTokens),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bondedTokens",
        .dataTypeSpecific.clazz = Nil,
        .number = Pool_FieldNumber_BondedTokens,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Pool__storage_, bondedTokens),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Pool)
                                   messageName:@"Pool"
                               fileDescription:&StakingRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Pool__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ValidatorUpdates

@implementation ValidatorUpdates

@dynamic updatesArray, updatesArray_Count;

typedef struct ValidatorUpdates__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *updatesArray;
} ValidatorUpdates__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "updatesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ValidatorUpdate),
        .number = ValidatorUpdates_FieldNumber_UpdatesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ValidatorUpdates__storage_, updatesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ValidatorUpdates)
                                   messageName:@"ValidatorUpdates"
                               fileDescription:&StakingRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ValidatorUpdates__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
