// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// clang-format off
// source: cosmos/app/runtime/v1alpha1/module.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import "cosmos/app/runtime/v1alpha1/Module.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Module);
GPBObjCClassDeclaration(StoreKeyConfig);

#pragma mark - ModuleRoot

@implementation ModuleRoot

// No extensions in the file and no imports or none of the imports (direct or
// indirect) defined extensions, so no need to generate +extensionRegistry.

@end

static GPBFileDescription ModuleRoot_FileDescription = {
  .package = "cosmos.app.runtime.v1alpha1",
  .prefix = NULL,
  .syntax = GPBFileSyntaxProto3
};

#pragma mark - Module

@implementation Module

@dynamic appName;
@dynamic beginBlockersArray, beginBlockersArray_Count;
@dynamic endBlockersArray, endBlockersArray_Count;
@dynamic initGenesisArray, initGenesisArray_Count;
@dynamic exportGenesisArray, exportGenesisArray_Count;
@dynamic overrideStoreKeysArray, overrideStoreKeysArray_Count;
@dynamic skipStoreKeysArray, skipStoreKeysArray_Count;
@dynamic orderMigrationsArray, orderMigrationsArray_Count;
@dynamic precommitersArray, precommitersArray_Count;
@dynamic prepareCheckStatersArray, prepareCheckStatersArray_Count;
@dynamic preBlockersArray, preBlockersArray_Count;

typedef struct Module__storage_ {
  uint32_t _has_storage_[1];
  NSString *appName;
  NSMutableArray *beginBlockersArray;
  NSMutableArray *endBlockersArray;
  NSMutableArray *initGenesisArray;
  NSMutableArray *exportGenesisArray;
  NSMutableArray *overrideStoreKeysArray;
  NSMutableArray *orderMigrationsArray;
  NSMutableArray *precommitersArray;
  NSMutableArray *prepareCheckStatersArray;
  NSMutableArray *preBlockersArray;
  NSMutableArray *skipStoreKeysArray;
} Module__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "appName",
        .dataTypeSpecific.clazz = Nil,
        .number = Module_FieldNumber_AppName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Module__storage_, appName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "beginBlockersArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Module_FieldNumber_BeginBlockersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Module__storage_, beginBlockersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "endBlockersArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Module_FieldNumber_EndBlockersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Module__storage_, endBlockersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "initGenesisArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Module_FieldNumber_InitGenesisArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Module__storage_, initGenesisArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "exportGenesisArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Module_FieldNumber_ExportGenesisArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Module__storage_, exportGenesisArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "overrideStoreKeysArray",
        .dataTypeSpecific.clazz = GPBObjCClass(StoreKeyConfig),
        .number = Module_FieldNumber_OverrideStoreKeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Module__storage_, overrideStoreKeysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "orderMigrationsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Module_FieldNumber_OrderMigrationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Module__storage_, orderMigrationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "precommitersArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Module_FieldNumber_PrecommitersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Module__storage_, precommitersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "prepareCheckStatersArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Module_FieldNumber_PrepareCheckStatersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Module__storage_, prepareCheckStatersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "preBlockersArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Module_FieldNumber_PreBlockersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Module__storage_, preBlockersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "skipStoreKeysArray",
        .dataTypeSpecific.clazz = Nil,
        .number = Module_FieldNumber_SkipStoreKeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Module__storage_, skipStoreKeysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Module)
                                   messageName:@"Module"
                               fileDescription:&ModuleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Module__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StoreKeyConfig

@implementation StoreKeyConfig

@dynamic moduleName;
@dynamic kvStoreKey;

typedef struct StoreKeyConfig__storage_ {
  uint32_t _has_storage_[1];
  NSString *moduleName;
  NSString *kvStoreKey;
} StoreKeyConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "moduleName",
        .dataTypeSpecific.clazz = Nil,
        .number = StoreKeyConfig_FieldNumber_ModuleName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StoreKeyConfig__storage_, moduleName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "kvStoreKey",
        .dataTypeSpecific.clazz = Nil,
        .number = StoreKeyConfig_FieldNumber_KvStoreKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StoreKeyConfig__storage_, kvStoreKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(StoreKeyConfig)
                                   messageName:@"StoreKeyConfig"
                               fileDescription:&ModuleRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StoreKeyConfig__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
