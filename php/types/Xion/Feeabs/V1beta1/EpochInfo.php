<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: xion/feeabs/v1beta1/epoch.proto

namespace Xion\Feeabs\V1beta1;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * EpochInfo defines information of a epoch
 *
 * Generated from protobuf message <code>xion.feeabs.v1beta1.EpochInfo</code>
 */
class EpochInfo extends \Google\Protobuf\Internal\Message
{
    /**
     * identifier is a unique reference to this particular timer.
     *
     * Generated from protobuf field <code>string identifier = 1 [json_name = "identifier"];</code>
     */
    protected $identifier = '';
    /**
     * start_time is the time at which the timer first ever ticks.
     * If start_time is in the future, the epoch will not begin until the start
     * time.
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp start_time = 2 [json_name = "startTime", (.gogoproto.nullable) = false, (.gogoproto.moretags) = "yaml:\"start_time\"", (.gogoproto.stdtime) = true];</code>
     */
    protected $start_time = null;
    /**
     * duration is the time in between epoch ticks.
     * In order for intended behavior to be met, duration should
     * be greater than the chains expected block time.
     * Duration must be non-zero.
     *
     * Generated from protobuf field <code>.google.protobuf.Duration duration = 3 [json_name = "duration", (.gogoproto.nullable) = false, (.gogoproto.jsontag) = "duration,omitempty", (.gogoproto.moretags) = "yaml:\"duration\"", (.gogoproto.stdduration) = true];</code>
     */
    protected $duration = null;
    /**
     * current_epoch is the current epoch number, or in other words,
     * how many times has the timer 'ticked'.
     * The first tick (current_epoch=1) is defined as
     * the first block whose blocktime is greater than the EpochInfo start_time.
     *
     * Generated from protobuf field <code>int64 current_epoch = 4 [json_name = "currentEpoch"];</code>
     */
    protected $current_epoch = 0;
    /**
     * current_epoch_start_time describes the start time of the current timer
     * interval. The interval is (current_epoch_start_time,
     * current_epoch_start_time + duration] When the timer ticks, this is set to
     * current_epoch_start_time = last_epoch_start_time + duration only one timer
     * tick for a given identifier can occur per block.
     * NOTE! The current_epoch_start_time may diverge significantly from the
     * wall-clock time the epoch began at. Wall-clock time of epoch start may be
     * >> current_epoch_start_time. Suppose current_epoch_start_time = 10,
     * duration = 5. Suppose the chain goes offline at t=14, and comes back online
     * at t=30, and produces blocks at every successive time. (t=31, 32, etc.)
     * * The t=30 block will start the epoch for (10, 15]
     * * The t=31 block will start the epoch for (15, 20]
     * * The t=32 block will start the epoch for (20, 25]
     * * The t=33 block will start the epoch for (25, 30]
     * * The t=34 block will start the epoch for (30, 35]
     * * The **t=36** block will start the epoch for (35, 40]
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp current_epoch_start_time = 5 [json_name = "currentEpochStartTime", (.gogoproto.nullable) = false, (.gogoproto.moretags) = "yaml:\"current_epoch_start_time\"", (.gogoproto.stdtime) = true];</code>
     */
    protected $current_epoch_start_time = null;
    /**
     * epoch_counting_started is a boolean, that indicates whether this
     * epoch timer has began yet.
     *
     * Generated from protobuf field <code>bool epoch_counting_started = 6 [json_name = "epochCountingStarted"];</code>
     */
    protected $epoch_counting_started = false;
    /**
     * current_epoch_start_height is the block height at which the current epoch
     * started. (The block height at which the timer last ticked)
     *
     * Generated from protobuf field <code>int64 current_epoch_start_height = 8 [json_name = "currentEpochStartHeight"];</code>
     */
    protected $current_epoch_start_height = 0;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type string $identifier
     *           identifier is a unique reference to this particular timer.
     *     @type \Google\Protobuf\Timestamp $start_time
     *           start_time is the time at which the timer first ever ticks.
     *           If start_time is in the future, the epoch will not begin until the start
     *           time.
     *     @type \Google\Protobuf\Duration $duration
     *           duration is the time in between epoch ticks.
     *           In order for intended behavior to be met, duration should
     *           be greater than the chains expected block time.
     *           Duration must be non-zero.
     *     @type int|string $current_epoch
     *           current_epoch is the current epoch number, or in other words,
     *           how many times has the timer 'ticked'.
     *           The first tick (current_epoch=1) is defined as
     *           the first block whose blocktime is greater than the EpochInfo start_time.
     *     @type \Google\Protobuf\Timestamp $current_epoch_start_time
     *           current_epoch_start_time describes the start time of the current timer
     *           interval. The interval is (current_epoch_start_time,
     *           current_epoch_start_time + duration] When the timer ticks, this is set to
     *           current_epoch_start_time = last_epoch_start_time + duration only one timer
     *           tick for a given identifier can occur per block.
     *           NOTE! The current_epoch_start_time may diverge significantly from the
     *           wall-clock time the epoch began at. Wall-clock time of epoch start may be
     *           >> current_epoch_start_time. Suppose current_epoch_start_time = 10,
     *           duration = 5. Suppose the chain goes offline at t=14, and comes back online
     *           at t=30, and produces blocks at every successive time. (t=31, 32, etc.)
     *           * The t=30 block will start the epoch for (10, 15]
     *           * The t=31 block will start the epoch for (15, 20]
     *           * The t=32 block will start the epoch for (20, 25]
     *           * The t=33 block will start the epoch for (25, 30]
     *           * The t=34 block will start the epoch for (30, 35]
     *           * The **t=36** block will start the epoch for (35, 40]
     *     @type bool $epoch_counting_started
     *           epoch_counting_started is a boolean, that indicates whether this
     *           epoch timer has began yet.
     *     @type int|string $current_epoch_start_height
     *           current_epoch_start_height is the block height at which the current epoch
     *           started. (The block height at which the timer last ticked)
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Xion\Feeabs\V1Beta1\Epoch::initOnce();
        parent::__construct($data);
    }

    /**
     * identifier is a unique reference to this particular timer.
     *
     * Generated from protobuf field <code>string identifier = 1 [json_name = "identifier"];</code>
     * @return string
     */
    public function getIdentifier()
    {
        return $this->identifier;
    }

    /**
     * identifier is a unique reference to this particular timer.
     *
     * Generated from protobuf field <code>string identifier = 1 [json_name = "identifier"];</code>
     * @param string $var
     * @return $this
     */
    public function setIdentifier($var)
    {
        GPBUtil::checkString($var, True);
        $this->identifier = $var;

        return $this;
    }

    /**
     * start_time is the time at which the timer first ever ticks.
     * If start_time is in the future, the epoch will not begin until the start
     * time.
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp start_time = 2 [json_name = "startTime", (.gogoproto.nullable) = false, (.gogoproto.moretags) = "yaml:\"start_time\"", (.gogoproto.stdtime) = true];</code>
     * @return \Google\Protobuf\Timestamp|null
     */
    public function getStartTime()
    {
        return $this->start_time;
    }

    public function hasStartTime()
    {
        return isset($this->start_time);
    }

    public function clearStartTime()
    {
        unset($this->start_time);
    }

    /**
     * start_time is the time at which the timer first ever ticks.
     * If start_time is in the future, the epoch will not begin until the start
     * time.
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp start_time = 2 [json_name = "startTime", (.gogoproto.nullable) = false, (.gogoproto.moretags) = "yaml:\"start_time\"", (.gogoproto.stdtime) = true];</code>
     * @param \Google\Protobuf\Timestamp $var
     * @return $this
     */
    public function setStartTime($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Timestamp::class);
        $this->start_time = $var;

        return $this;
    }

    /**
     * duration is the time in between epoch ticks.
     * In order for intended behavior to be met, duration should
     * be greater than the chains expected block time.
     * Duration must be non-zero.
     *
     * Generated from protobuf field <code>.google.protobuf.Duration duration = 3 [json_name = "duration", (.gogoproto.nullable) = false, (.gogoproto.jsontag) = "duration,omitempty", (.gogoproto.moretags) = "yaml:\"duration\"", (.gogoproto.stdduration) = true];</code>
     * @return \Google\Protobuf\Duration|null
     */
    public function getDuration()
    {
        return $this->duration;
    }

    public function hasDuration()
    {
        return isset($this->duration);
    }

    public function clearDuration()
    {
        unset($this->duration);
    }

    /**
     * duration is the time in between epoch ticks.
     * In order for intended behavior to be met, duration should
     * be greater than the chains expected block time.
     * Duration must be non-zero.
     *
     * Generated from protobuf field <code>.google.protobuf.Duration duration = 3 [json_name = "duration", (.gogoproto.nullable) = false, (.gogoproto.jsontag) = "duration,omitempty", (.gogoproto.moretags) = "yaml:\"duration\"", (.gogoproto.stdduration) = true];</code>
     * @param \Google\Protobuf\Duration $var
     * @return $this
     */
    public function setDuration($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Duration::class);
        $this->duration = $var;

        return $this;
    }

    /**
     * current_epoch is the current epoch number, or in other words,
     * how many times has the timer 'ticked'.
     * The first tick (current_epoch=1) is defined as
     * the first block whose blocktime is greater than the EpochInfo start_time.
     *
     * Generated from protobuf field <code>int64 current_epoch = 4 [json_name = "currentEpoch"];</code>
     * @return int|string
     */
    public function getCurrentEpoch()
    {
        return $this->current_epoch;
    }

    /**
     * current_epoch is the current epoch number, or in other words,
     * how many times has the timer 'ticked'.
     * The first tick (current_epoch=1) is defined as
     * the first block whose blocktime is greater than the EpochInfo start_time.
     *
     * Generated from protobuf field <code>int64 current_epoch = 4 [json_name = "currentEpoch"];</code>
     * @param int|string $var
     * @return $this
     */
    public function setCurrentEpoch($var)
    {
        GPBUtil::checkInt64($var);
        $this->current_epoch = $var;

        return $this;
    }

    /**
     * current_epoch_start_time describes the start time of the current timer
     * interval. The interval is (current_epoch_start_time,
     * current_epoch_start_time + duration] When the timer ticks, this is set to
     * current_epoch_start_time = last_epoch_start_time + duration only one timer
     * tick for a given identifier can occur per block.
     * NOTE! The current_epoch_start_time may diverge significantly from the
     * wall-clock time the epoch began at. Wall-clock time of epoch start may be
     * >> current_epoch_start_time. Suppose current_epoch_start_time = 10,
     * duration = 5. Suppose the chain goes offline at t=14, and comes back online
     * at t=30, and produces blocks at every successive time. (t=31, 32, etc.)
     * * The t=30 block will start the epoch for (10, 15]
     * * The t=31 block will start the epoch for (15, 20]
     * * The t=32 block will start the epoch for (20, 25]
     * * The t=33 block will start the epoch for (25, 30]
     * * The t=34 block will start the epoch for (30, 35]
     * * The **t=36** block will start the epoch for (35, 40]
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp current_epoch_start_time = 5 [json_name = "currentEpochStartTime", (.gogoproto.nullable) = false, (.gogoproto.moretags) = "yaml:\"current_epoch_start_time\"", (.gogoproto.stdtime) = true];</code>
     * @return \Google\Protobuf\Timestamp|null
     */
    public function getCurrentEpochStartTime()
    {
        return $this->current_epoch_start_time;
    }

    public function hasCurrentEpochStartTime()
    {
        return isset($this->current_epoch_start_time);
    }

    public function clearCurrentEpochStartTime()
    {
        unset($this->current_epoch_start_time);
    }

    /**
     * current_epoch_start_time describes the start time of the current timer
     * interval. The interval is (current_epoch_start_time,
     * current_epoch_start_time + duration] When the timer ticks, this is set to
     * current_epoch_start_time = last_epoch_start_time + duration only one timer
     * tick for a given identifier can occur per block.
     * NOTE! The current_epoch_start_time may diverge significantly from the
     * wall-clock time the epoch began at. Wall-clock time of epoch start may be
     * >> current_epoch_start_time. Suppose current_epoch_start_time = 10,
     * duration = 5. Suppose the chain goes offline at t=14, and comes back online
     * at t=30, and produces blocks at every successive time. (t=31, 32, etc.)
     * * The t=30 block will start the epoch for (10, 15]
     * * The t=31 block will start the epoch for (15, 20]
     * * The t=32 block will start the epoch for (20, 25]
     * * The t=33 block will start the epoch for (25, 30]
     * * The t=34 block will start the epoch for (30, 35]
     * * The **t=36** block will start the epoch for (35, 40]
     *
     * Generated from protobuf field <code>.google.protobuf.Timestamp current_epoch_start_time = 5 [json_name = "currentEpochStartTime", (.gogoproto.nullable) = false, (.gogoproto.moretags) = "yaml:\"current_epoch_start_time\"", (.gogoproto.stdtime) = true];</code>
     * @param \Google\Protobuf\Timestamp $var
     * @return $this
     */
    public function setCurrentEpochStartTime($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Timestamp::class);
        $this->current_epoch_start_time = $var;

        return $this;
    }

    /**
     * epoch_counting_started is a boolean, that indicates whether this
     * epoch timer has began yet.
     *
     * Generated from protobuf field <code>bool epoch_counting_started = 6 [json_name = "epochCountingStarted"];</code>
     * @return bool
     */
    public function getEpochCountingStarted()
    {
        return $this->epoch_counting_started;
    }

    /**
     * epoch_counting_started is a boolean, that indicates whether this
     * epoch timer has began yet.
     *
     * Generated from protobuf field <code>bool epoch_counting_started = 6 [json_name = "epochCountingStarted"];</code>
     * @param bool $var
     * @return $this
     */
    public function setEpochCountingStarted($var)
    {
        GPBUtil::checkBool($var);
        $this->epoch_counting_started = $var;

        return $this;
    }

    /**
     * current_epoch_start_height is the block height at which the current epoch
     * started. (The block height at which the timer last ticked)
     *
     * Generated from protobuf field <code>int64 current_epoch_start_height = 8 [json_name = "currentEpochStartHeight"];</code>
     * @return int|string
     */
    public function getCurrentEpochStartHeight()
    {
        return $this->current_epoch_start_height;
    }

    /**
     * current_epoch_start_height is the block height at which the current epoch
     * started. (The block height at which the timer last ticked)
     *
     * Generated from protobuf field <code>int64 current_epoch_start_height = 8 [json_name = "currentEpochStartHeight"];</code>
     * @param int|string $var
     * @return $this
     */
    public function setCurrentEpochStartHeight($var)
    {
        GPBUtil::checkInt64($var);
        $this->current_epoch_start_height = $var;

        return $this;
    }

}

