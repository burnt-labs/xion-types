/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.12.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Addr, Binary, InstantiateMsg, FeeConfig, Any, GrantConfig, ExecuteMsg, Uint128, Params, Coin, QueryMsg } from "./Treasury.types";
import { TreasuryQueryClient, TreasuryClient } from "./Treasury.client";
export const treasuryQueryKeys = {
  contract: ([{
    contract: "treasury"
  }] as const),
  address: (contractAddress: string | undefined) => ([{
    ...treasuryQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  grantConfigByTypeUrl: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...treasuryQueryKeys.address(contractAddress)[0],
    method: "grant_config_by_type_url",
    args
  }] as const),
  grantConfigTypeUrls: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...treasuryQueryKeys.address(contractAddress)[0],
    method: "grant_config_type_urls",
    args
  }] as const),
  feeConfig: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...treasuryQueryKeys.address(contractAddress)[0],
    method: "fee_config",
    args
  }] as const),
  admin: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...treasuryQueryKeys.address(contractAddress)[0],
    method: "admin",
    args
  }] as const),
  pendingAdmin: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...treasuryQueryKeys.address(contractAddress)[0],
    method: "pending_admin",
    args
  }] as const),
  params: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...treasuryQueryKeys.address(contractAddress)[0],
    method: "params",
    args
  }] as const)
};
export const treasuryQueries = {
  grantConfigByTypeUrl: <TData = Binary,>({
    client,
    args,
    options
  }: TreasuryGrantConfigByTypeUrlQuery<TData>): UseQueryOptions<Binary, Error, TData> => ({
    queryKey: treasuryQueryKeys.grantConfigByTypeUrl(client?.contractAddress, args),
    queryFn: () => client ? client.grantConfigByTypeUrl({
      msgTypeUrl: args.msgTypeUrl
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  grantConfigTypeUrls: <TData = Binary,>({
    client,
    options
  }: TreasuryGrantConfigTypeUrlsQuery<TData>): UseQueryOptions<Binary, Error, TData> => ({
    queryKey: treasuryQueryKeys.grantConfigTypeUrls(client?.contractAddress),
    queryFn: () => client ? client.grantConfigTypeUrls() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  feeConfig: <TData = Binary,>({
    client,
    options
  }: TreasuryFeeConfigQuery<TData>): UseQueryOptions<Binary, Error, TData> => ({
    queryKey: treasuryQueryKeys.feeConfig(client?.contractAddress),
    queryFn: () => client ? client.feeConfig() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  admin: <TData = Binary,>({
    client,
    options
  }: TreasuryAdminQuery<TData>): UseQueryOptions<Binary, Error, TData> => ({
    queryKey: treasuryQueryKeys.admin(client?.contractAddress),
    queryFn: () => client ? client.admin() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  pendingAdmin: <TData = Binary,>({
    client,
    options
  }: TreasuryPendingAdminQuery<TData>): UseQueryOptions<Binary, Error, TData> => ({
    queryKey: treasuryQueryKeys.pendingAdmin(client?.contractAddress),
    queryFn: () => client ? client.pendingAdmin() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  params: <TData = Binary,>({
    client,
    options
  }: TreasuryParamsQuery<TData>): UseQueryOptions<Binary, Error, TData> => ({
    queryKey: treasuryQueryKeys.params(client?.contractAddress),
    queryFn: () => client ? client.params() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  })
};
export interface TreasuryReactQuery<TResponse, TData = TResponse> {
  client: TreasuryQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface TreasuryParamsQuery<TData> extends TreasuryReactQuery<Binary, TData> {}
export function useTreasuryParamsQuery<TData = Binary>({
  client,
  options
}: TreasuryParamsQuery<TData>) {
  return useQuery<Binary, Error, TData>(treasuryQueryKeys.params(client?.contractAddress), () => client ? client.params() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface TreasuryPendingAdminQuery<TData> extends TreasuryReactQuery<Binary, TData> {}
export function useTreasuryPendingAdminQuery<TData = Binary>({
  client,
  options
}: TreasuryPendingAdminQuery<TData>) {
  return useQuery<Binary, Error, TData>(treasuryQueryKeys.pendingAdmin(client?.contractAddress), () => client ? client.pendingAdmin() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface TreasuryAdminQuery<TData> extends TreasuryReactQuery<Binary, TData> {}
export function useTreasuryAdminQuery<TData = Binary>({
  client,
  options
}: TreasuryAdminQuery<TData>) {
  return useQuery<Binary, Error, TData>(treasuryQueryKeys.admin(client?.contractAddress), () => client ? client.admin() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface TreasuryFeeConfigQuery<TData> extends TreasuryReactQuery<Binary, TData> {}
export function useTreasuryFeeConfigQuery<TData = Binary>({
  client,
  options
}: TreasuryFeeConfigQuery<TData>) {
  return useQuery<Binary, Error, TData>(treasuryQueryKeys.feeConfig(client?.contractAddress), () => client ? client.feeConfig() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface TreasuryGrantConfigTypeUrlsQuery<TData> extends TreasuryReactQuery<Binary, TData> {}
export function useTreasuryGrantConfigTypeUrlsQuery<TData = Binary>({
  client,
  options
}: TreasuryGrantConfigTypeUrlsQuery<TData>) {
  return useQuery<Binary, Error, TData>(treasuryQueryKeys.grantConfigTypeUrls(client?.contractAddress), () => client ? client.grantConfigTypeUrls() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface TreasuryGrantConfigByTypeUrlQuery<TData> extends TreasuryReactQuery<Binary, TData> {
  args: {
    msgTypeUrl: string;
  };
}
export function useTreasuryGrantConfigByTypeUrlQuery<TData = Binary>({
  client,
  args,
  options
}: TreasuryGrantConfigByTypeUrlQuery<TData>) {
  return useQuery<Binary, Error, TData>(treasuryQueryKeys.grantConfigByTypeUrl(client?.contractAddress, args), () => client ? client.grantConfigByTypeUrl({
    msgTypeUrl: args.msgTypeUrl
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface TreasuryWithdrawMutation {
  client: TreasuryClient;
  msg: {
    coins: Coin[];
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useTreasuryWithdrawMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, TreasuryWithdrawMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, TreasuryWithdrawMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.withdraw(msg, fee, memo, funds), options);
}
export interface TreasuryUpdateParamsMutation {
  client: TreasuryClient;
  msg: {
    params: Params;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useTreasuryUpdateParamsMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, TreasuryUpdateParamsMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, TreasuryUpdateParamsMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateParams(msg, fee, memo, funds), options);
}
export interface TreasuryRevokeAllowanceMutation {
  client: TreasuryClient;
  msg: {
    grantee: Addr;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useTreasuryRevokeAllowanceMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, TreasuryRevokeAllowanceMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, TreasuryRevokeAllowanceMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.revokeAllowance(msg, fee, memo, funds), options);
}
export interface TreasuryDeployFeeGrantMutation {
  client: TreasuryClient;
  msg: {
    authzGrantee: Addr;
    authzGranter: Addr;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useTreasuryDeployFeeGrantMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, TreasuryDeployFeeGrantMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, TreasuryDeployFeeGrantMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.deployFeeGrant(msg, fee, memo, funds), options);
}
export interface TreasuryUpdateFeeConfigMutation {
  client: TreasuryClient;
  msg: {
    feeConfig: FeeConfig;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useTreasuryUpdateFeeConfigMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, TreasuryUpdateFeeConfigMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, TreasuryUpdateFeeConfigMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateFeeConfig(msg, fee, memo, funds), options);
}
export interface TreasuryRemoveGrantConfigMutation {
  client: TreasuryClient;
  msg: {
    msgTypeUrl: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useTreasuryRemoveGrantConfigMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, TreasuryRemoveGrantConfigMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, TreasuryRemoveGrantConfigMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.removeGrantConfig(msg, fee, memo, funds), options);
}
export interface TreasuryUpdateGrantConfigMutation {
  client: TreasuryClient;
  msg: {
    grantConfig: GrantConfig;
    msgTypeUrl: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useTreasuryUpdateGrantConfigMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, TreasuryUpdateGrantConfigMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, TreasuryUpdateGrantConfigMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateGrantConfig(msg, fee, memo, funds), options);
}
export interface TreasuryCancelProposedAdminMutation {
  client: TreasuryClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useTreasuryCancelProposedAdminMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, TreasuryCancelProposedAdminMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, TreasuryCancelProposedAdminMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.cancelProposedAdmin(fee, memo, funds), options);
}
export interface TreasuryAcceptAdminMutation {
  client: TreasuryClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useTreasuryAcceptAdminMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, TreasuryAcceptAdminMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, TreasuryAcceptAdminMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.acceptAdmin(fee, memo, funds), options);
}
export interface TreasuryProposeAdminMutation {
  client: TreasuryClient;
  msg: {
    newAdmin: Addr;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useTreasuryProposeAdminMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, TreasuryProposeAdminMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, TreasuryProposeAdminMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.proposeAdmin(msg, fee, memo, funds), options);
}