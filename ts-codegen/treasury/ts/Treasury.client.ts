/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.12.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Addr, Binary, InstantiateMsg, FeeConfig, Any, GrantConfig, ExecuteMsg, Uint128, Params, Coin, QueryMsg } from "./Treasury.types";
export interface TreasuryReadOnlyInterface {
  contractAddress: string;
  grantConfigByTypeUrl: ({
    msgTypeUrl
  }: {
    msgTypeUrl: string;
  }) => Promise<Binary>;
  grantConfigTypeUrls: () => Promise<Binary>;
  feeConfig: () => Promise<Binary>;
  admin: () => Promise<Binary>;
  pendingAdmin: () => Promise<Binary>;
  params: () => Promise<Binary>;
}
export class TreasuryQueryClient implements TreasuryReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.grantConfigByTypeUrl = this.grantConfigByTypeUrl.bind(this);
    this.grantConfigTypeUrls = this.grantConfigTypeUrls.bind(this);
    this.feeConfig = this.feeConfig.bind(this);
    this.admin = this.admin.bind(this);
    this.pendingAdmin = this.pendingAdmin.bind(this);
    this.params = this.params.bind(this);
  }
  grantConfigByTypeUrl = async ({
    msgTypeUrl
  }: {
    msgTypeUrl: string;
  }): Promise<Binary> => {
    return this.client.queryContractSmart(this.contractAddress, {
      grant_config_by_type_url: {
        msg_type_url: msgTypeUrl
      }
    });
  };
  grantConfigTypeUrls = async (): Promise<Binary> => {
    return this.client.queryContractSmart(this.contractAddress, {
      grant_config_type_urls: {}
    });
  };
  feeConfig = async (): Promise<Binary> => {
    return this.client.queryContractSmart(this.contractAddress, {
      fee_config: {}
    });
  };
  admin = async (): Promise<Binary> => {
    return this.client.queryContractSmart(this.contractAddress, {
      admin: {}
    });
  };
  pendingAdmin = async (): Promise<Binary> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pending_admin: {}
    });
  };
  params = async (): Promise<Binary> => {
    return this.client.queryContractSmart(this.contractAddress, {
      params: {}
    });
  };
}
export interface TreasuryInterface extends TreasuryReadOnlyInterface {
  contractAddress: string;
  sender: string;
  proposeAdmin: ({
    newAdmin
  }: {
    newAdmin: Addr;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  acceptAdmin: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  cancelProposedAdmin: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  updateGrantConfig: ({
    grantConfig,
    msgTypeUrl
  }: {
    grantConfig: GrantConfig;
    msgTypeUrl: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  removeGrantConfig: ({
    msgTypeUrl
  }: {
    msgTypeUrl: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  updateFeeConfig: ({
    feeConfig
  }: {
    feeConfig: FeeConfig;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  deployFeeGrant: ({
    authzGrantee,
    authzGranter
  }: {
    authzGrantee: Addr;
    authzGranter: Addr;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  revokeAllowance: ({
    grantee
  }: {
    grantee: Addr;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  updateParams: ({
    params
  }: {
    params: Params;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  withdraw: ({
    coins
  }: {
    coins: Coin[];
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
}
export class TreasuryClient extends TreasuryQueryClient implements TreasuryInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.proposeAdmin = this.proposeAdmin.bind(this);
    this.acceptAdmin = this.acceptAdmin.bind(this);
    this.cancelProposedAdmin = this.cancelProposedAdmin.bind(this);
    this.updateGrantConfig = this.updateGrantConfig.bind(this);
    this.removeGrantConfig = this.removeGrantConfig.bind(this);
    this.updateFeeConfig = this.updateFeeConfig.bind(this);
    this.deployFeeGrant = this.deployFeeGrant.bind(this);
    this.revokeAllowance = this.revokeAllowance.bind(this);
    this.updateParams = this.updateParams.bind(this);
    this.withdraw = this.withdraw.bind(this);
  }
  proposeAdmin = async ({
    newAdmin
  }: {
    newAdmin: Addr;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      propose_admin: {
        new_admin: newAdmin
      }
    }, fee_, memo_, funds_);
  };
  acceptAdmin = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      accept_admin: {}
    }, fee_, memo_, funds_);
  };
  cancelProposedAdmin = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      cancel_proposed_admin: {}
    }, fee_, memo_, funds_);
  };
  updateGrantConfig = async ({
    grantConfig,
    msgTypeUrl
  }: {
    grantConfig: GrantConfig;
    msgTypeUrl: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_grant_config: {
        grant_config: grantConfig,
        msg_type_url: msgTypeUrl
      }
    }, fee_, memo_, funds_);
  };
  removeGrantConfig = async ({
    msgTypeUrl
  }: {
    msgTypeUrl: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_grant_config: {
        msg_type_url: msgTypeUrl
      }
    }, fee_, memo_, funds_);
  };
  updateFeeConfig = async ({
    feeConfig
  }: {
    feeConfig: FeeConfig;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_fee_config: {
        fee_config: feeConfig
      }
    }, fee_, memo_, funds_);
  };
  deployFeeGrant = async ({
    authzGrantee,
    authzGranter
  }: {
    authzGrantee: Addr;
    authzGranter: Addr;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      deploy_fee_grant: {
        authz_grantee: authzGrantee,
        authz_granter: authzGranter
      }
    }, fee_, memo_, funds_);
  };
  revokeAllowance = async ({
    grantee
  }: {
    grantee: Addr;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      revoke_allowance: {
        grantee
      }
    }, fee_, memo_, funds_);
  };
  updateParams = async ({
    params
  }: {
    params: Params;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_params: {
        params
      }
    }, fee_, memo_, funds_);
  };
  withdraw = async ({
    coins
  }: {
    coins: Coin[];
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw: {
        coins
      }
    }, fee_, memo_, funds_);
  };
}