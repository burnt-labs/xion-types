// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: cosmos/staking/v1beta1/staking.proto
// Protobuf C++ Version: 5.29.4

#ifndef cosmos_2fstaking_2fv1beta1_2fstaking_2eproto_2epb_2eh
#define cosmos_2fstaking_2fv1beta1_2fstaking_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029004
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "gogoproto/gogo.pb.h"
#include "google/protobuf/any.pb.h"
#include "google/protobuf/duration.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "cosmos_proto/cosmos.pb.h"
#include "cosmos/base/v1beta1/coin.pb.h"
#include "amino/amino.pb.h"
#include "tendermint/types/types.pb.h"
#include "tendermint/abci/types.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
namespace cosmos {
namespace staking {
namespace v1beta1 {
class Commission;
struct CommissionDefaultTypeInternal;
extern CommissionDefaultTypeInternal _Commission_default_instance_;
class CommissionRates;
struct CommissionRatesDefaultTypeInternal;
extern CommissionRatesDefaultTypeInternal _CommissionRates_default_instance_;
class DVPair;
struct DVPairDefaultTypeInternal;
extern DVPairDefaultTypeInternal _DVPair_default_instance_;
class DVPairs;
struct DVPairsDefaultTypeInternal;
extern DVPairsDefaultTypeInternal _DVPairs_default_instance_;
class DVVTriplet;
struct DVVTripletDefaultTypeInternal;
extern DVVTripletDefaultTypeInternal _DVVTriplet_default_instance_;
class DVVTriplets;
struct DVVTripletsDefaultTypeInternal;
extern DVVTripletsDefaultTypeInternal _DVVTriplets_default_instance_;
class Delegation;
struct DelegationDefaultTypeInternal;
extern DelegationDefaultTypeInternal _Delegation_default_instance_;
class DelegationResponse;
struct DelegationResponseDefaultTypeInternal;
extern DelegationResponseDefaultTypeInternal _DelegationResponse_default_instance_;
class Description;
struct DescriptionDefaultTypeInternal;
extern DescriptionDefaultTypeInternal _Description_default_instance_;
class HistoricalInfo;
struct HistoricalInfoDefaultTypeInternal;
extern HistoricalInfoDefaultTypeInternal _HistoricalInfo_default_instance_;
class Params;
struct ParamsDefaultTypeInternal;
extern ParamsDefaultTypeInternal _Params_default_instance_;
class Pool;
struct PoolDefaultTypeInternal;
extern PoolDefaultTypeInternal _Pool_default_instance_;
class Redelegation;
struct RedelegationDefaultTypeInternal;
extern RedelegationDefaultTypeInternal _Redelegation_default_instance_;
class RedelegationEntry;
struct RedelegationEntryDefaultTypeInternal;
extern RedelegationEntryDefaultTypeInternal _RedelegationEntry_default_instance_;
class RedelegationEntryResponse;
struct RedelegationEntryResponseDefaultTypeInternal;
extern RedelegationEntryResponseDefaultTypeInternal _RedelegationEntryResponse_default_instance_;
class RedelegationResponse;
struct RedelegationResponseDefaultTypeInternal;
extern RedelegationResponseDefaultTypeInternal _RedelegationResponse_default_instance_;
class UnbondingDelegation;
struct UnbondingDelegationDefaultTypeInternal;
extern UnbondingDelegationDefaultTypeInternal _UnbondingDelegation_default_instance_;
class UnbondingDelegationEntry;
struct UnbondingDelegationEntryDefaultTypeInternal;
extern UnbondingDelegationEntryDefaultTypeInternal _UnbondingDelegationEntry_default_instance_;
class ValAddresses;
struct ValAddressesDefaultTypeInternal;
extern ValAddressesDefaultTypeInternal _ValAddresses_default_instance_;
class Validator;
struct ValidatorDefaultTypeInternal;
extern ValidatorDefaultTypeInternal _Validator_default_instance_;
class ValidatorUpdates;
struct ValidatorUpdatesDefaultTypeInternal;
extern ValidatorUpdatesDefaultTypeInternal _ValidatorUpdates_default_instance_;
}  // namespace v1beta1
}  // namespace staking
}  // namespace cosmos
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace cosmos {
namespace staking {
namespace v1beta1 {
enum BondStatus : int {
  BOND_STATUS_UNSPECIFIED = 0,
  BOND_STATUS_UNBONDED = 1,
  BOND_STATUS_UNBONDING = 2,
  BOND_STATUS_BONDED = 3,
  BondStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  BondStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool BondStatus_IsValid(int value);
extern const uint32_t BondStatus_internal_data_[];
constexpr BondStatus BondStatus_MIN = static_cast<BondStatus>(0);
constexpr BondStatus BondStatus_MAX = static_cast<BondStatus>(3);
constexpr int BondStatus_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
BondStatus_descriptor();
template <typename T>
const std::string& BondStatus_Name(T value) {
  static_assert(std::is_same<T, BondStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BondStatus_Name().");
  return BondStatus_Name(static_cast<BondStatus>(value));
}
template <>
inline const std::string& BondStatus_Name(BondStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BondStatus_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool BondStatus_Parse(absl::string_view name, BondStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BondStatus>(
      BondStatus_descriptor(), name, value);
}
enum Infraction : int {
  INFRACTION_UNSPECIFIED = 0,
  INFRACTION_DOUBLE_SIGN = 1,
  INFRACTION_DOWNTIME = 2,
  Infraction_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Infraction_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Infraction_IsValid(int value);
extern const uint32_t Infraction_internal_data_[];
constexpr Infraction Infraction_MIN = static_cast<Infraction>(0);
constexpr Infraction Infraction_MAX = static_cast<Infraction>(2);
constexpr int Infraction_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Infraction_descriptor();
template <typename T>
const std::string& Infraction_Name(T value) {
  static_assert(std::is_same<T, Infraction>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Infraction_Name().");
  return Infraction_Name(static_cast<Infraction>(value));
}
template <>
inline const std::string& Infraction_Name(Infraction value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Infraction_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Infraction_Parse(absl::string_view name, Infraction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Infraction>(
      Infraction_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class ValAddresses final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.ValAddresses) */ {
 public:
  inline ValAddresses() : ValAddresses(nullptr) {}
  ~ValAddresses() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ValAddresses* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ValAddresses));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ValAddresses(
      ::google::protobuf::internal::ConstantInitialized);

  inline ValAddresses(const ValAddresses& from) : ValAddresses(nullptr, from) {}
  inline ValAddresses(ValAddresses&& from) noexcept
      : ValAddresses(nullptr, std::move(from)) {}
  inline ValAddresses& operator=(const ValAddresses& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValAddresses& operator=(ValAddresses&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValAddresses& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValAddresses* internal_default_instance() {
    return reinterpret_cast<const ValAddresses*>(
        &_ValAddresses_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(ValAddresses& a, ValAddresses& b) { a.Swap(&b); }
  inline void Swap(ValAddresses* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValAddresses* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValAddresses* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ValAddresses>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ValAddresses& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ValAddresses& from) { ValAddresses::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ValAddresses* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.staking.v1beta1.ValAddresses"; }

 protected:
  explicit ValAddresses(::google::protobuf::Arena* arena);
  ValAddresses(::google::protobuf::Arena* arena, const ValAddresses& from);
  ValAddresses(::google::protobuf::Arena* arena, ValAddresses&& from) noexcept
      : ValAddresses(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAddressesFieldNumber = 1,
  };
  // repeated string addresses = 1 [json_name = "addresses", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  int addresses_size() const;
  private:
  int _internal_addresses_size() const;

  public:
  void clear_addresses() ;
  const std::string& addresses(int index) const;
  std::string* mutable_addresses(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_addresses(int index, Arg_&& value, Args_... args);
  std::string* add_addresses();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_addresses(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& addresses() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_addresses();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_addresses() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_addresses();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.ValAddresses)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      53, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ValAddresses& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> addresses_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};
// -------------------------------------------------------------------

class Pool final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.Pool) */ {
 public:
  inline Pool() : Pool(nullptr) {}
  ~Pool() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Pool* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Pool));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Pool(
      ::google::protobuf::internal::ConstantInitialized);

  inline Pool(const Pool& from) : Pool(nullptr, from) {}
  inline Pool(Pool&& from) noexcept
      : Pool(nullptr, std::move(from)) {}
  inline Pool& operator=(const Pool& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pool& operator=(Pool&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pool& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pool* internal_default_instance() {
    return reinterpret_cast<const Pool*>(
        &_Pool_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(Pool& a, Pool& b) { a.Swap(&b); }
  inline void Swap(Pool* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pool* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pool* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Pool>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Pool& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Pool& from) { Pool::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Pool* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.staking.v1beta1.Pool"; }

 protected:
  explicit Pool(::google::protobuf::Arena* arena);
  Pool(::google::protobuf::Arena* arena, const Pool& from);
  Pool(::google::protobuf::Arena* arena, Pool&& from) noexcept
      : Pool(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNotBondedTokensFieldNumber = 1,
    kBondedTokensFieldNumber = 2,
  };
  // string not_bonded_tokens = 1 [json_name = "notBondedTokens", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.Int", (.gogoproto.jsontag) = "not_bonded_tokens", (.cosmos_proto.scalar) = "cosmos.Int", (.amino.dont_omitempty) = true];
  void clear_not_bonded_tokens() ;
  const std::string& not_bonded_tokens() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_not_bonded_tokens(Arg_&& arg, Args_... args);
  std::string* mutable_not_bonded_tokens();
  PROTOBUF_NODISCARD std::string* release_not_bonded_tokens();
  void set_allocated_not_bonded_tokens(std::string* value);

  private:
  const std::string& _internal_not_bonded_tokens() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_not_bonded_tokens(
      const std::string& value);
  std::string* _internal_mutable_not_bonded_tokens();

  public:
  // string bonded_tokens = 2 [json_name = "bondedTokens", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.Int", (.gogoproto.jsontag) = "bonded_tokens", (.cosmos_proto.scalar) = "cosmos.Int", (.amino.dont_omitempty) = true];
  void clear_bonded_tokens() ;
  const std::string& bonded_tokens() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bonded_tokens(Arg_&& arg, Args_... args);
  std::string* mutable_bonded_tokens();
  PROTOBUF_NODISCARD std::string* release_bonded_tokens();
  void set_allocated_bonded_tokens(std::string* value);

  private:
  const std::string& _internal_bonded_tokens() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bonded_tokens(
      const std::string& value);
  std::string* _internal_mutable_bonded_tokens();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.Pool)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      66, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Pool& from_msg);
    ::google::protobuf::internal::ArenaStringPtr not_bonded_tokens_;
    ::google::protobuf::internal::ArenaStringPtr bonded_tokens_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};
// -------------------------------------------------------------------

class Description final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.Description) */ {
 public:
  inline Description() : Description(nullptr) {}
  ~Description() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Description* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Description));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Description(
      ::google::protobuf::internal::ConstantInitialized);

  inline Description(const Description& from) : Description(nullptr, from) {}
  inline Description(Description&& from) noexcept
      : Description(nullptr, std::move(from)) {}
  inline Description& operator=(const Description& from) {
    CopyFrom(from);
    return *this;
  }
  inline Description& operator=(Description&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Description& default_instance() {
    return *internal_default_instance();
  }
  static inline const Description* internal_default_instance() {
    return reinterpret_cast<const Description*>(
        &_Description_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Description& a, Description& b) { a.Swap(&b); }
  inline void Swap(Description* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Description* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Description* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Description>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Description& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Description& from) { Description::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Description* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.staking.v1beta1.Description"; }

 protected:
  explicit Description(::google::protobuf::Arena* arena);
  Description(::google::protobuf::Arena* arena, const Description& from);
  Description(::google::protobuf::Arena* arena, Description&& from) noexcept
      : Description(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMonikerFieldNumber = 1,
    kIdentityFieldNumber = 2,
    kWebsiteFieldNumber = 3,
    kSecurityContactFieldNumber = 4,
    kDetailsFieldNumber = 5,
  };
  // string moniker = 1 [json_name = "moniker"];
  void clear_moniker() ;
  const std::string& moniker() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_moniker(Arg_&& arg, Args_... args);
  std::string* mutable_moniker();
  PROTOBUF_NODISCARD std::string* release_moniker();
  void set_allocated_moniker(std::string* value);

  private:
  const std::string& _internal_moniker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_moniker(
      const std::string& value);
  std::string* _internal_mutable_moniker();

  public:
  // string identity = 2 [json_name = "identity"];
  void clear_identity() ;
  const std::string& identity() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_identity(Arg_&& arg, Args_... args);
  std::string* mutable_identity();
  PROTOBUF_NODISCARD std::string* release_identity();
  void set_allocated_identity(std::string* value);

  private:
  const std::string& _internal_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity(
      const std::string& value);
  std::string* _internal_mutable_identity();

  public:
  // string website = 3 [json_name = "website"];
  void clear_website() ;
  const std::string& website() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_website(Arg_&& arg, Args_... args);
  std::string* mutable_website();
  PROTOBUF_NODISCARD std::string* release_website();
  void set_allocated_website(std::string* value);

  private:
  const std::string& _internal_website() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_website(
      const std::string& value);
  std::string* _internal_mutable_website();

  public:
  // string security_contact = 4 [json_name = "securityContact"];
  void clear_security_contact() ;
  const std::string& security_contact() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_security_contact(Arg_&& arg, Args_... args);
  std::string* mutable_security_contact();
  PROTOBUF_NODISCARD std::string* release_security_contact();
  void set_allocated_security_contact(std::string* value);

  private:
  const std::string& _internal_security_contact() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_security_contact(
      const std::string& value);
  std::string* _internal_mutable_security_contact();

  public:
  // string details = 5 [json_name = "details"];
  void clear_details() ;
  const std::string& details() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_details(Arg_&& arg, Args_... args);
  std::string* mutable_details();
  PROTOBUF_NODISCARD std::string* release_details();
  void set_allocated_details(std::string* value);

  private:
  const std::string& _internal_details() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_details(
      const std::string& value);
  std::string* _internal_mutable_details();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.Description)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      88, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Description& from_msg);
    ::google::protobuf::internal::ArenaStringPtr moniker_;
    ::google::protobuf::internal::ArenaStringPtr identity_;
    ::google::protobuf::internal::ArenaStringPtr website_;
    ::google::protobuf::internal::ArenaStringPtr security_contact_;
    ::google::protobuf::internal::ArenaStringPtr details_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};
// -------------------------------------------------------------------

class Delegation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.Delegation) */ {
 public:
  inline Delegation() : Delegation(nullptr) {}
  ~Delegation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Delegation* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Delegation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Delegation(
      ::google::protobuf::internal::ConstantInitialized);

  inline Delegation(const Delegation& from) : Delegation(nullptr, from) {}
  inline Delegation(Delegation&& from) noexcept
      : Delegation(nullptr, std::move(from)) {}
  inline Delegation& operator=(const Delegation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Delegation& operator=(Delegation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Delegation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Delegation* internal_default_instance() {
    return reinterpret_cast<const Delegation*>(
        &_Delegation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(Delegation& a, Delegation& b) { a.Swap(&b); }
  inline void Swap(Delegation* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Delegation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Delegation* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Delegation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Delegation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Delegation& from) { Delegation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Delegation* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.staking.v1beta1.Delegation"; }

 protected:
  explicit Delegation(::google::protobuf::Arena* arena);
  Delegation(::google::protobuf::Arena* arena, const Delegation& from);
  Delegation(::google::protobuf::Arena* arena, Delegation&& from) noexcept
      : Delegation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDelegatorAddressFieldNumber = 1,
    kValidatorAddressFieldNumber = 2,
    kSharesFieldNumber = 3,
  };
  // string delegator_address = 1 [json_name = "delegatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_delegator_address() ;
  const std::string& delegator_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_delegator_address(Arg_&& arg, Args_... args);
  std::string* mutable_delegator_address();
  PROTOBUF_NODISCARD std::string* release_delegator_address();
  void set_allocated_delegator_address(std::string* value);

  private:
  const std::string& _internal_delegator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delegator_address(
      const std::string& value);
  std::string* _internal_mutable_delegator_address();

  public:
  // string validator_address = 2 [json_name = "validatorAddress", (.cosmos_proto.scalar) = "cosmos.ValidatorAddressString"];
  void clear_validator_address() ;
  const std::string& validator_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_validator_address(Arg_&& arg, Args_... args);
  std::string* mutable_validator_address();
  PROTOBUF_NODISCARD std::string* release_validator_address();
  void set_allocated_validator_address(std::string* value);

  private:
  const std::string& _internal_validator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validator_address(
      const std::string& value);
  std::string* _internal_mutable_validator_address();

  public:
  // string shares = 3 [json_name = "shares", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.LegacyDec", (.cosmos_proto.scalar) = "cosmos.Dec"];
  void clear_shares() ;
  const std::string& shares() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_shares(Arg_&& arg, Args_... args);
  std::string* mutable_shares();
  PROTOBUF_NODISCARD std::string* release_shares();
  void set_allocated_shares(std::string* value);

  private:
  const std::string& _internal_shares() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shares(
      const std::string& value);
  std::string* _internal_mutable_shares();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.Delegation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      82, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Delegation& from_msg);
    ::google::protobuf::internal::ArenaStringPtr delegator_address_;
    ::google::protobuf::internal::ArenaStringPtr validator_address_;
    ::google::protobuf::internal::ArenaStringPtr shares_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};
// -------------------------------------------------------------------

class DVVTriplet final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.DVVTriplet) */ {
 public:
  inline DVVTriplet() : DVVTriplet(nullptr) {}
  ~DVVTriplet() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DVVTriplet* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DVVTriplet));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DVVTriplet(
      ::google::protobuf::internal::ConstantInitialized);

  inline DVVTriplet(const DVVTriplet& from) : DVVTriplet(nullptr, from) {}
  inline DVVTriplet(DVVTriplet&& from) noexcept
      : DVVTriplet(nullptr, std::move(from)) {}
  inline DVVTriplet& operator=(const DVVTriplet& from) {
    CopyFrom(from);
    return *this;
  }
  inline DVVTriplet& operator=(DVVTriplet&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DVVTriplet& default_instance() {
    return *internal_default_instance();
  }
  static inline const DVVTriplet* internal_default_instance() {
    return reinterpret_cast<const DVVTriplet*>(
        &_DVVTriplet_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(DVVTriplet& a, DVVTriplet& b) { a.Swap(&b); }
  inline void Swap(DVVTriplet* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DVVTriplet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DVVTriplet* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DVVTriplet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DVVTriplet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DVVTriplet& from) { DVVTriplet::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DVVTriplet* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.staking.v1beta1.DVVTriplet"; }

 protected:
  explicit DVVTriplet(::google::protobuf::Arena* arena);
  DVVTriplet(::google::protobuf::Arena* arena, const DVVTriplet& from);
  DVVTriplet(::google::protobuf::Arena* arena, DVVTriplet&& from) noexcept
      : DVVTriplet(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDelegatorAddressFieldNumber = 1,
    kValidatorSrcAddressFieldNumber = 2,
    kValidatorDstAddressFieldNumber = 3,
  };
  // string delegator_address = 1 [json_name = "delegatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_delegator_address() ;
  const std::string& delegator_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_delegator_address(Arg_&& arg, Args_... args);
  std::string* mutable_delegator_address();
  PROTOBUF_NODISCARD std::string* release_delegator_address();
  void set_allocated_delegator_address(std::string* value);

  private:
  const std::string& _internal_delegator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delegator_address(
      const std::string& value);
  std::string* _internal_mutable_delegator_address();

  public:
  // string validator_src_address = 2 [json_name = "validatorSrcAddress", (.cosmos_proto.scalar) = "cosmos.ValidatorAddressString"];
  void clear_validator_src_address() ;
  const std::string& validator_src_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_validator_src_address(Arg_&& arg, Args_... args);
  std::string* mutable_validator_src_address();
  PROTOBUF_NODISCARD std::string* release_validator_src_address();
  void set_allocated_validator_src_address(std::string* value);

  private:
  const std::string& _internal_validator_src_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validator_src_address(
      const std::string& value);
  std::string* _internal_mutable_validator_src_address();

  public:
  // string validator_dst_address = 3 [json_name = "validatorDstAddress", (.cosmos_proto.scalar) = "cosmos.ValidatorAddressString"];
  void clear_validator_dst_address() ;
  const std::string& validator_dst_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_validator_dst_address(Arg_&& arg, Args_... args);
  std::string* mutable_validator_dst_address();
  PROTOBUF_NODISCARD std::string* release_validator_dst_address();
  void set_allocated_validator_dst_address(std::string* value);

  private:
  const std::string& _internal_validator_dst_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validator_dst_address(
      const std::string& value);
  std::string* _internal_mutable_validator_dst_address();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.DVVTriplet)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      101, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DVVTriplet& from_msg);
    ::google::protobuf::internal::ArenaStringPtr delegator_address_;
    ::google::protobuf::internal::ArenaStringPtr validator_src_address_;
    ::google::protobuf::internal::ArenaStringPtr validator_dst_address_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};
// -------------------------------------------------------------------

class DVPair final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.DVPair) */ {
 public:
  inline DVPair() : DVPair(nullptr) {}
  ~DVPair() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DVPair* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DVPair));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DVPair(
      ::google::protobuf::internal::ConstantInitialized);

  inline DVPair(const DVPair& from) : DVPair(nullptr, from) {}
  inline DVPair(DVPair&& from) noexcept
      : DVPair(nullptr, std::move(from)) {}
  inline DVPair& operator=(const DVPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline DVPair& operator=(DVPair&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DVPair& default_instance() {
    return *internal_default_instance();
  }
  static inline const DVPair* internal_default_instance() {
    return reinterpret_cast<const DVPair*>(
        &_DVPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(DVPair& a, DVPair& b) { a.Swap(&b); }
  inline void Swap(DVPair* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DVPair* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DVPair* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DVPair>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DVPair& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DVPair& from) { DVPair::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DVPair* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.staking.v1beta1.DVPair"; }

 protected:
  explicit DVPair(::google::protobuf::Arena* arena);
  DVPair(::google::protobuf::Arena* arena, const DVPair& from);
  DVPair(::google::protobuf::Arena* arena, DVPair&& from) noexcept
      : DVPair(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDelegatorAddressFieldNumber = 1,
    kValidatorAddressFieldNumber = 2,
  };
  // string delegator_address = 1 [json_name = "delegatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_delegator_address() ;
  const std::string& delegator_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_delegator_address(Arg_&& arg, Args_... args);
  std::string* mutable_delegator_address();
  PROTOBUF_NODISCARD std::string* release_delegator_address();
  void set_allocated_delegator_address(std::string* value);

  private:
  const std::string& _internal_delegator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delegator_address(
      const std::string& value);
  std::string* _internal_mutable_delegator_address();

  public:
  // string validator_address = 2 [json_name = "validatorAddress", (.cosmos_proto.scalar) = "cosmos.ValidatorAddressString"];
  void clear_validator_address() ;
  const std::string& validator_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_validator_address(Arg_&& arg, Args_... args);
  std::string* mutable_validator_address();
  PROTOBUF_NODISCARD std::string* release_validator_address();
  void set_allocated_validator_address(std::string* value);

  private:
  const std::string& _internal_validator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validator_address(
      const std::string& value);
  std::string* _internal_mutable_validator_address();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.DVPair)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      72, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DVPair& from_msg);
    ::google::protobuf::internal::ArenaStringPtr delegator_address_;
    ::google::protobuf::internal::ArenaStringPtr validator_address_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};
// -------------------------------------------------------------------

class CommissionRates final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.CommissionRates) */ {
 public:
  inline CommissionRates() : CommissionRates(nullptr) {}
  ~CommissionRates() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CommissionRates* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CommissionRates));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommissionRates(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommissionRates(const CommissionRates& from) : CommissionRates(nullptr, from) {}
  inline CommissionRates(CommissionRates&& from) noexcept
      : CommissionRates(nullptr, std::move(from)) {}
  inline CommissionRates& operator=(const CommissionRates& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommissionRates& operator=(CommissionRates&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommissionRates& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommissionRates* internal_default_instance() {
    return reinterpret_cast<const CommissionRates*>(
        &_CommissionRates_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(CommissionRates& a, CommissionRates& b) { a.Swap(&b); }
  inline void Swap(CommissionRates* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommissionRates* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommissionRates* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CommissionRates>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommissionRates& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommissionRates& from) { CommissionRates::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CommissionRates* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.staking.v1beta1.CommissionRates"; }

 protected:
  explicit CommissionRates(::google::protobuf::Arena* arena);
  CommissionRates(::google::protobuf::Arena* arena, const CommissionRates& from);
  CommissionRates(::google::protobuf::Arena* arena, CommissionRates&& from) noexcept
      : CommissionRates(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRateFieldNumber = 1,
    kMaxRateFieldNumber = 2,
    kMaxChangeRateFieldNumber = 3,
  };
  // string rate = 1 [json_name = "rate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.LegacyDec", (.cosmos_proto.scalar) = "cosmos.Dec", (.amino.dont_omitempty) = true];
  void clear_rate() ;
  const std::string& rate() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rate(Arg_&& arg, Args_... args);
  std::string* mutable_rate();
  PROTOBUF_NODISCARD std::string* release_rate();
  void set_allocated_rate(std::string* value);

  private:
  const std::string& _internal_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rate(
      const std::string& value);
  std::string* _internal_mutable_rate();

  public:
  // string max_rate = 2 [json_name = "maxRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.LegacyDec", (.cosmos_proto.scalar) = "cosmos.Dec", (.amino.dont_omitempty) = true];
  void clear_max_rate() ;
  const std::string& max_rate() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_max_rate(Arg_&& arg, Args_... args);
  std::string* mutable_max_rate();
  PROTOBUF_NODISCARD std::string* release_max_rate();
  void set_allocated_max_rate(std::string* value);

  private:
  const std::string& _internal_max_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_max_rate(
      const std::string& value);
  std::string* _internal_mutable_max_rate();

  public:
  // string max_change_rate = 3 [json_name = "maxChangeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.LegacyDec", (.cosmos_proto.scalar) = "cosmos.Dec", (.amino.dont_omitempty) = true];
  void clear_max_change_rate() ;
  const std::string& max_change_rate() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_max_change_rate(Arg_&& arg, Args_... args);
  std::string* mutable_max_change_rate();
  PROTOBUF_NODISCARD std::string* release_max_change_rate();
  void set_allocated_max_change_rate(std::string* value);

  private:
  const std::string& _internal_max_change_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_max_change_rate(
      const std::string& value);
  std::string* _internal_mutable_max_change_rate();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.CommissionRates)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      74, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommissionRates& from_msg);
    ::google::protobuf::internal::ArenaStringPtr rate_;
    ::google::protobuf::internal::ArenaStringPtr max_rate_;
    ::google::protobuf::internal::ArenaStringPtr max_change_rate_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};
// -------------------------------------------------------------------

class UnbondingDelegationEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.UnbondingDelegationEntry) */ {
 public:
  inline UnbondingDelegationEntry() : UnbondingDelegationEntry(nullptr) {}
  ~UnbondingDelegationEntry() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UnbondingDelegationEntry* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UnbondingDelegationEntry));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UnbondingDelegationEntry(
      ::google::protobuf::internal::ConstantInitialized);

  inline UnbondingDelegationEntry(const UnbondingDelegationEntry& from) : UnbondingDelegationEntry(nullptr, from) {}
  inline UnbondingDelegationEntry(UnbondingDelegationEntry&& from) noexcept
      : UnbondingDelegationEntry(nullptr, std::move(from)) {}
  inline UnbondingDelegationEntry& operator=(const UnbondingDelegationEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnbondingDelegationEntry& operator=(UnbondingDelegationEntry&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnbondingDelegationEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnbondingDelegationEntry* internal_default_instance() {
    return reinterpret_cast<const UnbondingDelegationEntry*>(
        &_UnbondingDelegationEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(UnbondingDelegationEntry& a, UnbondingDelegationEntry& b) { a.Swap(&b); }
  inline void Swap(UnbondingDelegationEntry* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnbondingDelegationEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnbondingDelegationEntry* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UnbondingDelegationEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UnbondingDelegationEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UnbondingDelegationEntry& from) { UnbondingDelegationEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UnbondingDelegationEntry* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.staking.v1beta1.UnbondingDelegationEntry"; }

 protected:
  explicit UnbondingDelegationEntry(::google::protobuf::Arena* arena);
  UnbondingDelegationEntry(::google::protobuf::Arena* arena, const UnbondingDelegationEntry& from);
  UnbondingDelegationEntry(::google::protobuf::Arena* arena, UnbondingDelegationEntry&& from) noexcept
      : UnbondingDelegationEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInitialBalanceFieldNumber = 3,
    kBalanceFieldNumber = 4,
    kCompletionTimeFieldNumber = 2,
    kCreationHeightFieldNumber = 1,
    kUnbondingIdFieldNumber = 5,
    kUnbondingOnHoldRefCountFieldNumber = 6,
  };
  // string initial_balance = 3 [json_name = "initialBalance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.Int", (.cosmos_proto.scalar) = "cosmos.Int"];
  void clear_initial_balance() ;
  const std::string& initial_balance() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_initial_balance(Arg_&& arg, Args_... args);
  std::string* mutable_initial_balance();
  PROTOBUF_NODISCARD std::string* release_initial_balance();
  void set_allocated_initial_balance(std::string* value);

  private:
  const std::string& _internal_initial_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initial_balance(
      const std::string& value);
  std::string* _internal_mutable_initial_balance();

  public:
  // string balance = 4 [json_name = "balance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.Int", (.cosmos_proto.scalar) = "cosmos.Int"];
  void clear_balance() ;
  const std::string& balance() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_balance(Arg_&& arg, Args_... args);
  std::string* mutable_balance();
  PROTOBUF_NODISCARD std::string* release_balance();
  void set_allocated_balance(std::string* value);

  private:
  const std::string& _internal_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_balance(
      const std::string& value);
  std::string* _internal_mutable_balance();

  public:
  // .google.protobuf.Timestamp completion_time = 2 [json_name = "completionTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true, (.amino.dont_omitempty) = true];
  bool has_completion_time() const;
  void clear_completion_time() ;
  const ::google::protobuf::Timestamp& completion_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_completion_time();
  ::google::protobuf::Timestamp* mutable_completion_time();
  void set_allocated_completion_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_completion_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_completion_time();

  private:
  const ::google::protobuf::Timestamp& _internal_completion_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_completion_time();

  public:
  // int64 creation_height = 1 [json_name = "creationHeight"];
  void clear_creation_height() ;
  ::int64_t creation_height() const;
  void set_creation_height(::int64_t value);

  private:
  ::int64_t _internal_creation_height() const;
  void _internal_set_creation_height(::int64_t value);

  public:
  // uint64 unbonding_id = 5 [json_name = "unbondingId"];
  void clear_unbonding_id() ;
  ::uint64_t unbonding_id() const;
  void set_unbonding_id(::uint64_t value);

  private:
  ::uint64_t _internal_unbonding_id() const;
  void _internal_set_unbonding_id(::uint64_t value);

  public:
  // int64 unbonding_on_hold_ref_count = 6 [json_name = "unbondingOnHoldRefCount"];
  void clear_unbonding_on_hold_ref_count() ;
  ::int64_t unbonding_on_hold_ref_count() const;
  void set_unbonding_on_hold_ref_count(::int64_t value);

  private:
  ::int64_t _internal_unbonding_on_hold_ref_count() const;
  void _internal_set_unbonding_on_hold_ref_count(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.UnbondingDelegationEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      78, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UnbondingDelegationEntry& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr initial_balance_;
    ::google::protobuf::internal::ArenaStringPtr balance_;
    ::google::protobuf::Timestamp* completion_time_;
    ::int64_t creation_height_;
    ::uint64_t unbonding_id_;
    ::int64_t unbonding_on_hold_ref_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};
// -------------------------------------------------------------------

class RedelegationEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.RedelegationEntry) */ {
 public:
  inline RedelegationEntry() : RedelegationEntry(nullptr) {}
  ~RedelegationEntry() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RedelegationEntry* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RedelegationEntry));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RedelegationEntry(
      ::google::protobuf::internal::ConstantInitialized);

  inline RedelegationEntry(const RedelegationEntry& from) : RedelegationEntry(nullptr, from) {}
  inline RedelegationEntry(RedelegationEntry&& from) noexcept
      : RedelegationEntry(nullptr, std::move(from)) {}
  inline RedelegationEntry& operator=(const RedelegationEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedelegationEntry& operator=(RedelegationEntry&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RedelegationEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const RedelegationEntry* internal_default_instance() {
    return reinterpret_cast<const RedelegationEntry*>(
        &_RedelegationEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(RedelegationEntry& a, RedelegationEntry& b) { a.Swap(&b); }
  inline void Swap(RedelegationEntry* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedelegationEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RedelegationEntry* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RedelegationEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RedelegationEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RedelegationEntry& from) { RedelegationEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RedelegationEntry* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.staking.v1beta1.RedelegationEntry"; }

 protected:
  explicit RedelegationEntry(::google::protobuf::Arena* arena);
  RedelegationEntry(::google::protobuf::Arena* arena, const RedelegationEntry& from);
  RedelegationEntry(::google::protobuf::Arena* arena, RedelegationEntry&& from) noexcept
      : RedelegationEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInitialBalanceFieldNumber = 3,
    kSharesDstFieldNumber = 4,
    kCompletionTimeFieldNumber = 2,
    kCreationHeightFieldNumber = 1,
    kUnbondingIdFieldNumber = 5,
    kUnbondingOnHoldRefCountFieldNumber = 6,
  };
  // string initial_balance = 3 [json_name = "initialBalance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.Int", (.cosmos_proto.scalar) = "cosmos.Int"];
  void clear_initial_balance() ;
  const std::string& initial_balance() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_initial_balance(Arg_&& arg, Args_... args);
  std::string* mutable_initial_balance();
  PROTOBUF_NODISCARD std::string* release_initial_balance();
  void set_allocated_initial_balance(std::string* value);

  private:
  const std::string& _internal_initial_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initial_balance(
      const std::string& value);
  std::string* _internal_mutable_initial_balance();

  public:
  // string shares_dst = 4 [json_name = "sharesDst", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.LegacyDec", (.cosmos_proto.scalar) = "cosmos.Dec"];
  void clear_shares_dst() ;
  const std::string& shares_dst() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_shares_dst(Arg_&& arg, Args_... args);
  std::string* mutable_shares_dst();
  PROTOBUF_NODISCARD std::string* release_shares_dst();
  void set_allocated_shares_dst(std::string* value);

  private:
  const std::string& _internal_shares_dst() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shares_dst(
      const std::string& value);
  std::string* _internal_mutable_shares_dst();

  public:
  // .google.protobuf.Timestamp completion_time = 2 [json_name = "completionTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true, (.amino.dont_omitempty) = true];
  bool has_completion_time() const;
  void clear_completion_time() ;
  const ::google::protobuf::Timestamp& completion_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_completion_time();
  ::google::protobuf::Timestamp* mutable_completion_time();
  void set_allocated_completion_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_completion_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_completion_time();

  private:
  const ::google::protobuf::Timestamp& _internal_completion_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_completion_time();

  public:
  // int64 creation_height = 1 [json_name = "creationHeight"];
  void clear_creation_height() ;
  ::int64_t creation_height() const;
  void set_creation_height(::int64_t value);

  private:
  ::int64_t _internal_creation_height() const;
  void _internal_set_creation_height(::int64_t value);

  public:
  // uint64 unbonding_id = 5 [json_name = "unbondingId"];
  void clear_unbonding_id() ;
  ::uint64_t unbonding_id() const;
  void set_unbonding_id(::uint64_t value);

  private:
  ::uint64_t _internal_unbonding_id() const;
  void _internal_set_unbonding_id(::uint64_t value);

  public:
  // int64 unbonding_on_hold_ref_count = 6 [json_name = "unbondingOnHoldRefCount"];
  void clear_unbonding_on_hold_ref_count() ;
  ::int64_t unbonding_on_hold_ref_count() const;
  void set_unbonding_on_hold_ref_count(::int64_t value);

  private:
  ::int64_t _internal_unbonding_on_hold_ref_count() const;
  void _internal_set_unbonding_on_hold_ref_count(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.RedelegationEntry)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      74, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RedelegationEntry& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr initial_balance_;
    ::google::protobuf::internal::ArenaStringPtr shares_dst_;
    ::google::protobuf::Timestamp* completion_time_;
    ::int64_t creation_height_;
    ::uint64_t unbonding_id_;
    ::int64_t unbonding_on_hold_ref_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};
// -------------------------------------------------------------------

class Params final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.Params) */ {
 public:
  inline Params() : Params(nullptr) {}
  ~Params() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Params* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Params));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Params(
      ::google::protobuf::internal::ConstantInitialized);

  inline Params(const Params& from) : Params(nullptr, from) {}
  inline Params(Params&& from) noexcept
      : Params(nullptr, std::move(from)) {}
  inline Params& operator=(const Params& from) {
    CopyFrom(from);
    return *this;
  }
  inline Params& operator=(Params&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Params& default_instance() {
    return *internal_default_instance();
  }
  static inline const Params* internal_default_instance() {
    return reinterpret_cast<const Params*>(
        &_Params_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(Params& a, Params& b) { a.Swap(&b); }
  inline void Swap(Params* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Params* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Params* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Params>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Params& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Params& from) { Params::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Params* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.staking.v1beta1.Params"; }

 protected:
  explicit Params(::google::protobuf::Arena* arena);
  Params(::google::protobuf::Arena* arena, const Params& from);
  Params(::google::protobuf::Arena* arena, Params&& from) noexcept
      : Params(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBondDenomFieldNumber = 5,
    kMinCommissionRateFieldNumber = 6,
    kUnbondingTimeFieldNumber = 1,
    kMaxValidatorsFieldNumber = 2,
    kMaxEntriesFieldNumber = 3,
    kHistoricalEntriesFieldNumber = 4,
  };
  // string bond_denom = 5 [json_name = "bondDenom"];
  void clear_bond_denom() ;
  const std::string& bond_denom() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bond_denom(Arg_&& arg, Args_... args);
  std::string* mutable_bond_denom();
  PROTOBUF_NODISCARD std::string* release_bond_denom();
  void set_allocated_bond_denom(std::string* value);

  private:
  const std::string& _internal_bond_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bond_denom(
      const std::string& value);
  std::string* _internal_mutable_bond_denom();

  public:
  // string min_commission_rate = 6 [json_name = "minCommissionRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.LegacyDec", (.gogoproto.moretags) = "yaml:\"min_commission_rate\"", (.cosmos_proto.scalar) = "cosmos.Dec", (.amino.dont_omitempty) = true];
  void clear_min_commission_rate() ;
  const std::string& min_commission_rate() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_commission_rate(Arg_&& arg, Args_... args);
  std::string* mutable_min_commission_rate();
  PROTOBUF_NODISCARD std::string* release_min_commission_rate();
  void set_allocated_min_commission_rate(std::string* value);

  private:
  const std::string& _internal_min_commission_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_commission_rate(
      const std::string& value);
  std::string* _internal_mutable_min_commission_rate();

  public:
  // .google.protobuf.Duration unbonding_time = 1 [json_name = "unbondingTime", (.gogoproto.nullable) = false, (.gogoproto.stdduration) = true, (.amino.dont_omitempty) = true];
  bool has_unbonding_time() const;
  void clear_unbonding_time() ;
  const ::google::protobuf::Duration& unbonding_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_unbonding_time();
  ::google::protobuf::Duration* mutable_unbonding_time();
  void set_allocated_unbonding_time(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_unbonding_time(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_unbonding_time();

  private:
  const ::google::protobuf::Duration& _internal_unbonding_time() const;
  ::google::protobuf::Duration* _internal_mutable_unbonding_time();

  public:
  // uint32 max_validators = 2 [json_name = "maxValidators"];
  void clear_max_validators() ;
  ::uint32_t max_validators() const;
  void set_max_validators(::uint32_t value);

  private:
  ::uint32_t _internal_max_validators() const;
  void _internal_set_max_validators(::uint32_t value);

  public:
  // uint32 max_entries = 3 [json_name = "maxEntries"];
  void clear_max_entries() ;
  ::uint32_t max_entries() const;
  void set_max_entries(::uint32_t value);

  private:
  ::uint32_t _internal_max_entries() const;
  void _internal_set_max_entries(::uint32_t value);

  public:
  // uint32 historical_entries = 4 [json_name = "historicalEntries"];
  void clear_historical_entries() ;
  ::uint32_t historical_entries() const;
  void set_historical_entries(::uint32_t value);

  private:
  ::uint32_t _internal_historical_entries() const;
  void _internal_set_historical_entries(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.Params)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      67, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Params& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr bond_denom_;
    ::google::protobuf::internal::ArenaStringPtr min_commission_rate_;
    ::google::protobuf::Duration* unbonding_time_;
    ::uint32_t max_validators_;
    ::uint32_t max_entries_;
    ::uint32_t historical_entries_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};
// -------------------------------------------------------------------

class DelegationResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.DelegationResponse) */ {
 public:
  inline DelegationResponse() : DelegationResponse(nullptr) {}
  ~DelegationResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DelegationResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DelegationResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DelegationResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline DelegationResponse(const DelegationResponse& from) : DelegationResponse(nullptr, from) {}
  inline DelegationResponse(DelegationResponse&& from) noexcept
      : DelegationResponse(nullptr, std::move(from)) {}
  inline DelegationResponse& operator=(const DelegationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelegationResponse& operator=(DelegationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelegationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelegationResponse* internal_default_instance() {
    return reinterpret_cast<const DelegationResponse*>(
        &_DelegationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(DelegationResponse& a, DelegationResponse& b) { a.Swap(&b); }
  inline void Swap(DelegationResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelegationResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelegationResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DelegationResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DelegationResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DelegationResponse& from) { DelegationResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DelegationResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.staking.v1beta1.DelegationResponse"; }

 protected:
  explicit DelegationResponse(::google::protobuf::Arena* arena);
  DelegationResponse(::google::protobuf::Arena* arena, const DelegationResponse& from);
  DelegationResponse(::google::protobuf::Arena* arena, DelegationResponse&& from) noexcept
      : DelegationResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDelegationFieldNumber = 1,
    kBalanceFieldNumber = 2,
  };
  // .cosmos.staking.v1beta1.Delegation delegation = 1 [json_name = "delegation", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  bool has_delegation() const;
  void clear_delegation() ;
  const ::cosmos::staking::v1beta1::Delegation& delegation() const;
  PROTOBUF_NODISCARD ::cosmos::staking::v1beta1::Delegation* release_delegation();
  ::cosmos::staking::v1beta1::Delegation* mutable_delegation();
  void set_allocated_delegation(::cosmos::staking::v1beta1::Delegation* value);
  void unsafe_arena_set_allocated_delegation(::cosmos::staking::v1beta1::Delegation* value);
  ::cosmos::staking::v1beta1::Delegation* unsafe_arena_release_delegation();

  private:
  const ::cosmos::staking::v1beta1::Delegation& _internal_delegation() const;
  ::cosmos::staking::v1beta1::Delegation* _internal_mutable_delegation();

  public:
  // .cosmos.base.v1beta1.Coin balance = 2 [json_name = "balance", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  bool has_balance() const;
  void clear_balance() ;
  const ::cosmos::base::v1beta1::Coin& balance() const;
  PROTOBUF_NODISCARD ::cosmos::base::v1beta1::Coin* release_balance();
  ::cosmos::base::v1beta1::Coin* mutable_balance();
  void set_allocated_balance(::cosmos::base::v1beta1::Coin* value);
  void unsafe_arena_set_allocated_balance(::cosmos::base::v1beta1::Coin* value);
  ::cosmos::base::v1beta1::Coin* unsafe_arena_release_balance();

  private:
  const ::cosmos::base::v1beta1::Coin& _internal_balance() const;
  ::cosmos::base::v1beta1::Coin* _internal_mutable_balance();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.DelegationResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DelegationResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::cosmos::staking::v1beta1::Delegation* delegation_;
    ::cosmos::base::v1beta1::Coin* balance_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};
// -------------------------------------------------------------------

class DVVTriplets final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.DVVTriplets) */ {
 public:
  inline DVVTriplets() : DVVTriplets(nullptr) {}
  ~DVVTriplets() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DVVTriplets* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DVVTriplets));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DVVTriplets(
      ::google::protobuf::internal::ConstantInitialized);

  inline DVVTriplets(const DVVTriplets& from) : DVVTriplets(nullptr, from) {}
  inline DVVTriplets(DVVTriplets&& from) noexcept
      : DVVTriplets(nullptr, std::move(from)) {}
  inline DVVTriplets& operator=(const DVVTriplets& from) {
    CopyFrom(from);
    return *this;
  }
  inline DVVTriplets& operator=(DVVTriplets&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DVVTriplets& default_instance() {
    return *internal_default_instance();
  }
  static inline const DVVTriplets* internal_default_instance() {
    return reinterpret_cast<const DVVTriplets*>(
        &_DVVTriplets_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(DVVTriplets& a, DVVTriplets& b) { a.Swap(&b); }
  inline void Swap(DVVTriplets* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DVVTriplets* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DVVTriplets* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DVVTriplets>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DVVTriplets& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DVVTriplets& from) { DVVTriplets::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DVVTriplets* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.staking.v1beta1.DVVTriplets"; }

 protected:
  explicit DVVTriplets(::google::protobuf::Arena* arena);
  DVVTriplets(::google::protobuf::Arena* arena, const DVVTriplets& from);
  DVVTriplets(::google::protobuf::Arena* arena, DVVTriplets&& from) noexcept
      : DVVTriplets(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTripletsFieldNumber = 1,
  };
  // repeated .cosmos.staking.v1beta1.DVVTriplet triplets = 1 [json_name = "triplets", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  int triplets_size() const;
  private:
  int _internal_triplets_size() const;

  public:
  void clear_triplets() ;
  ::cosmos::staking::v1beta1::DVVTriplet* mutable_triplets(int index);
  ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::DVVTriplet>* mutable_triplets();

  private:
  const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::DVVTriplet>& _internal_triplets() const;
  ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::DVVTriplet>* _internal_mutable_triplets();
  public:
  const ::cosmos::staking::v1beta1::DVVTriplet& triplets(int index) const;
  ::cosmos::staking::v1beta1::DVVTriplet* add_triplets();
  const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::DVVTriplet>& triplets() const;
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.DVVTriplets)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DVVTriplets& from_msg);
    ::google::protobuf::RepeatedPtrField< ::cosmos::staking::v1beta1::DVVTriplet > triplets_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};
// -------------------------------------------------------------------

class DVPairs final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.DVPairs) */ {
 public:
  inline DVPairs() : DVPairs(nullptr) {}
  ~DVPairs() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DVPairs* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DVPairs));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DVPairs(
      ::google::protobuf::internal::ConstantInitialized);

  inline DVPairs(const DVPairs& from) : DVPairs(nullptr, from) {}
  inline DVPairs(DVPairs&& from) noexcept
      : DVPairs(nullptr, std::move(from)) {}
  inline DVPairs& operator=(const DVPairs& from) {
    CopyFrom(from);
    return *this;
  }
  inline DVPairs& operator=(DVPairs&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DVPairs& default_instance() {
    return *internal_default_instance();
  }
  static inline const DVPairs* internal_default_instance() {
    return reinterpret_cast<const DVPairs*>(
        &_DVPairs_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(DVPairs& a, DVPairs& b) { a.Swap(&b); }
  inline void Swap(DVPairs* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DVPairs* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DVPairs* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DVPairs>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DVPairs& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DVPairs& from) { DVPairs::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DVPairs* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.staking.v1beta1.DVPairs"; }

 protected:
  explicit DVPairs(::google::protobuf::Arena* arena);
  DVPairs(::google::protobuf::Arena* arena, const DVPairs& from);
  DVPairs(::google::protobuf::Arena* arena, DVPairs&& from) noexcept
      : DVPairs(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPairsFieldNumber = 1,
  };
  // repeated .cosmos.staking.v1beta1.DVPair pairs = 1 [json_name = "pairs", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  int pairs_size() const;
  private:
  int _internal_pairs_size() const;

  public:
  void clear_pairs() ;
  ::cosmos::staking::v1beta1::DVPair* mutable_pairs(int index);
  ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::DVPair>* mutable_pairs();

  private:
  const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::DVPair>& _internal_pairs() const;
  ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::DVPair>* _internal_mutable_pairs();
  public:
  const ::cosmos::staking::v1beta1::DVPair& pairs(int index) const;
  ::cosmos::staking::v1beta1::DVPair* add_pairs();
  const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::DVPair>& pairs() const;
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.DVPairs)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DVPairs& from_msg);
    ::google::protobuf::RepeatedPtrField< ::cosmos::staking::v1beta1::DVPair > pairs_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};
// -------------------------------------------------------------------

class Commission final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.Commission) */ {
 public:
  inline Commission() : Commission(nullptr) {}
  ~Commission() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Commission* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Commission));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Commission(
      ::google::protobuf::internal::ConstantInitialized);

  inline Commission(const Commission& from) : Commission(nullptr, from) {}
  inline Commission(Commission&& from) noexcept
      : Commission(nullptr, std::move(from)) {}
  inline Commission& operator=(const Commission& from) {
    CopyFrom(from);
    return *this;
  }
  inline Commission& operator=(Commission&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Commission& default_instance() {
    return *internal_default_instance();
  }
  static inline const Commission* internal_default_instance() {
    return reinterpret_cast<const Commission*>(
        &_Commission_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Commission& a, Commission& b) { a.Swap(&b); }
  inline void Swap(Commission* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Commission* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Commission* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Commission>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Commission& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Commission& from) { Commission::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Commission* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.staking.v1beta1.Commission"; }

 protected:
  explicit Commission(::google::protobuf::Arena* arena);
  Commission(::google::protobuf::Arena* arena, const Commission& from);
  Commission(::google::protobuf::Arena* arena, Commission&& from) noexcept
      : Commission(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCommissionRatesFieldNumber = 1,
    kUpdateTimeFieldNumber = 2,
  };
  // .cosmos.staking.v1beta1.CommissionRates commission_rates = 1 [json_name = "commissionRates", (.gogoproto.nullable) = false, (.gogoproto.embed) = true, (.amino.dont_omitempty) = true];
  bool has_commission_rates() const;
  void clear_commission_rates() ;
  const ::cosmos::staking::v1beta1::CommissionRates& commission_rates() const;
  PROTOBUF_NODISCARD ::cosmos::staking::v1beta1::CommissionRates* release_commission_rates();
  ::cosmos::staking::v1beta1::CommissionRates* mutable_commission_rates();
  void set_allocated_commission_rates(::cosmos::staking::v1beta1::CommissionRates* value);
  void unsafe_arena_set_allocated_commission_rates(::cosmos::staking::v1beta1::CommissionRates* value);
  ::cosmos::staking::v1beta1::CommissionRates* unsafe_arena_release_commission_rates();

  private:
  const ::cosmos::staking::v1beta1::CommissionRates& _internal_commission_rates() const;
  ::cosmos::staking::v1beta1::CommissionRates* _internal_mutable_commission_rates();

  public:
  // .google.protobuf.Timestamp update_time = 2 [json_name = "updateTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true, (.amino.dont_omitempty) = true];
  bool has_update_time() const;
  void clear_update_time() ;
  const ::google::protobuf::Timestamp& update_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_update_time();
  ::google::protobuf::Timestamp* mutable_update_time();
  void set_allocated_update_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_update_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_update_time();

  private:
  const ::google::protobuf::Timestamp& _internal_update_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_update_time();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.Commission)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Commission& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::cosmos::staking::v1beta1::CommissionRates* commission_rates_;
    ::google::protobuf::Timestamp* update_time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};
// -------------------------------------------------------------------

class ValidatorUpdates final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.ValidatorUpdates) */ {
 public:
  inline ValidatorUpdates() : ValidatorUpdates(nullptr) {}
  ~ValidatorUpdates() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ValidatorUpdates* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ValidatorUpdates));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ValidatorUpdates(
      ::google::protobuf::internal::ConstantInitialized);

  inline ValidatorUpdates(const ValidatorUpdates& from) : ValidatorUpdates(nullptr, from) {}
  inline ValidatorUpdates(ValidatorUpdates&& from) noexcept
      : ValidatorUpdates(nullptr, std::move(from)) {}
  inline ValidatorUpdates& operator=(const ValidatorUpdates& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorUpdates& operator=(ValidatorUpdates&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidatorUpdates& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidatorUpdates* internal_default_instance() {
    return reinterpret_cast<const ValidatorUpdates*>(
        &_ValidatorUpdates_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(ValidatorUpdates& a, ValidatorUpdates& b) { a.Swap(&b); }
  inline void Swap(ValidatorUpdates* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidatorUpdates* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidatorUpdates* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ValidatorUpdates>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ValidatorUpdates& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ValidatorUpdates& from) { ValidatorUpdates::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ValidatorUpdates* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.staking.v1beta1.ValidatorUpdates"; }

 protected:
  explicit ValidatorUpdates(::google::protobuf::Arena* arena);
  ValidatorUpdates(::google::protobuf::Arena* arena, const ValidatorUpdates& from);
  ValidatorUpdates(::google::protobuf::Arena* arena, ValidatorUpdates&& from) noexcept
      : ValidatorUpdates(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUpdatesFieldNumber = 1,
  };
  // repeated .tendermint.abci.ValidatorUpdate updates = 1 [json_name = "updates", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  int updates_size() const;
  private:
  int _internal_updates_size() const;

  public:
  void clear_updates() ;
  ::tendermint::abci::ValidatorUpdate* mutable_updates(int index);
  ::google::protobuf::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>* mutable_updates();

  private:
  const ::google::protobuf::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>& _internal_updates() const;
  ::google::protobuf::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>* _internal_mutable_updates();
  public:
  const ::tendermint::abci::ValidatorUpdate& updates(int index) const;
  ::tendermint::abci::ValidatorUpdate* add_updates();
  const ::google::protobuf::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>& updates() const;
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.ValidatorUpdates)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ValidatorUpdates& from_msg);
    ::google::protobuf::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate > updates_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};
// -------------------------------------------------------------------

class Validator final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.Validator) */ {
 public:
  inline Validator() : Validator(nullptr) {}
  ~Validator() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Validator* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Validator));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Validator(
      ::google::protobuf::internal::ConstantInitialized);

  inline Validator(const Validator& from) : Validator(nullptr, from) {}
  inline Validator(Validator&& from) noexcept
      : Validator(nullptr, std::move(from)) {}
  inline Validator& operator=(const Validator& from) {
    CopyFrom(from);
    return *this;
  }
  inline Validator& operator=(Validator&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Validator& default_instance() {
    return *internal_default_instance();
  }
  static inline const Validator* internal_default_instance() {
    return reinterpret_cast<const Validator*>(
        &_Validator_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Validator& a, Validator& b) { a.Swap(&b); }
  inline void Swap(Validator* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Validator* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Validator* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Validator>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Validator& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Validator& from) { Validator::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Validator* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.staking.v1beta1.Validator"; }

 protected:
  explicit Validator(::google::protobuf::Arena* arena);
  Validator(::google::protobuf::Arena* arena, const Validator& from);
  Validator(::google::protobuf::Arena* arena, Validator&& from) noexcept
      : Validator(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUnbondingIdsFieldNumber = 13,
    kOperatorAddressFieldNumber = 1,
    kTokensFieldNumber = 5,
    kDelegatorSharesFieldNumber = 6,
    kMinSelfDelegationFieldNumber = 11,
    kConsensusPubkeyFieldNumber = 2,
    kDescriptionFieldNumber = 7,
    kUnbondingTimeFieldNumber = 9,
    kCommissionFieldNumber = 10,
    kJailedFieldNumber = 3,
    kStatusFieldNumber = 4,
    kUnbondingHeightFieldNumber = 8,
    kUnbondingOnHoldRefCountFieldNumber = 12,
  };
  // repeated uint64 unbonding_ids = 13 [json_name = "unbondingIds"];
  int unbonding_ids_size() const;
  private:
  int _internal_unbonding_ids_size() const;

  public:
  void clear_unbonding_ids() ;
  ::uint64_t unbonding_ids(int index) const;
  void set_unbonding_ids(int index, ::uint64_t value);
  void add_unbonding_ids(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& unbonding_ids() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_unbonding_ids();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_unbonding_ids() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_unbonding_ids();

  public:
  // string operator_address = 1 [json_name = "operatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_operator_address() ;
  const std::string& operator_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operator_address(Arg_&& arg, Args_... args);
  std::string* mutable_operator_address();
  PROTOBUF_NODISCARD std::string* release_operator_address();
  void set_allocated_operator_address(std::string* value);

  private:
  const std::string& _internal_operator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operator_address(
      const std::string& value);
  std::string* _internal_mutable_operator_address();

  public:
  // string tokens = 5 [json_name = "tokens", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.Int", (.cosmos_proto.scalar) = "cosmos.Int"];
  void clear_tokens() ;
  const std::string& tokens() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tokens(Arg_&& arg, Args_... args);
  std::string* mutable_tokens();
  PROTOBUF_NODISCARD std::string* release_tokens();
  void set_allocated_tokens(std::string* value);

  private:
  const std::string& _internal_tokens() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tokens(
      const std::string& value);
  std::string* _internal_mutable_tokens();

  public:
  // string delegator_shares = 6 [json_name = "delegatorShares", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.LegacyDec", (.cosmos_proto.scalar) = "cosmos.Dec"];
  void clear_delegator_shares() ;
  const std::string& delegator_shares() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_delegator_shares(Arg_&& arg, Args_... args);
  std::string* mutable_delegator_shares();
  PROTOBUF_NODISCARD std::string* release_delegator_shares();
  void set_allocated_delegator_shares(std::string* value);

  private:
  const std::string& _internal_delegator_shares() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delegator_shares(
      const std::string& value);
  std::string* _internal_mutable_delegator_shares();

  public:
  // string min_self_delegation = 11 [json_name = "minSelfDelegation", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.Int", (.cosmos_proto.scalar) = "cosmos.Int", (.cosmos_proto.field_added_in) = "cosmos-sdk 0.46"];
  void clear_min_self_delegation() ;
  const std::string& min_self_delegation() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_self_delegation(Arg_&& arg, Args_... args);
  std::string* mutable_min_self_delegation();
  PROTOBUF_NODISCARD std::string* release_min_self_delegation();
  void set_allocated_min_self_delegation(std::string* value);

  private:
  const std::string& _internal_min_self_delegation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_self_delegation(
      const std::string& value);
  std::string* _internal_mutable_min_self_delegation();

  public:
  // .google.protobuf.Any consensus_pubkey = 2 [json_name = "consensusPubkey", (.cosmos_proto.accepts_interface) = "cosmos.crypto.PubKey"];
  bool has_consensus_pubkey() const;
  void clear_consensus_pubkey() ;
  const ::google::protobuf::Any& consensus_pubkey() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_consensus_pubkey();
  ::google::protobuf::Any* mutable_consensus_pubkey();
  void set_allocated_consensus_pubkey(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_consensus_pubkey(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_consensus_pubkey();

  private:
  const ::google::protobuf::Any& _internal_consensus_pubkey() const;
  ::google::protobuf::Any* _internal_mutable_consensus_pubkey();

  public:
  // .cosmos.staking.v1beta1.Description description = 7 [json_name = "description", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  bool has_description() const;
  void clear_description() ;
  const ::cosmos::staking::v1beta1::Description& description() const;
  PROTOBUF_NODISCARD ::cosmos::staking::v1beta1::Description* release_description();
  ::cosmos::staking::v1beta1::Description* mutable_description();
  void set_allocated_description(::cosmos::staking::v1beta1::Description* value);
  void unsafe_arena_set_allocated_description(::cosmos::staking::v1beta1::Description* value);
  ::cosmos::staking::v1beta1::Description* unsafe_arena_release_description();

  private:
  const ::cosmos::staking::v1beta1::Description& _internal_description() const;
  ::cosmos::staking::v1beta1::Description* _internal_mutable_description();

  public:
  // .google.protobuf.Timestamp unbonding_time = 9 [json_name = "unbondingTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true, (.amino.dont_omitempty) = true];
  bool has_unbonding_time() const;
  void clear_unbonding_time() ;
  const ::google::protobuf::Timestamp& unbonding_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_unbonding_time();
  ::google::protobuf::Timestamp* mutable_unbonding_time();
  void set_allocated_unbonding_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_unbonding_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_unbonding_time();

  private:
  const ::google::protobuf::Timestamp& _internal_unbonding_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_unbonding_time();

  public:
  // .cosmos.staking.v1beta1.Commission commission = 10 [json_name = "commission", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  bool has_commission() const;
  void clear_commission() ;
  const ::cosmos::staking::v1beta1::Commission& commission() const;
  PROTOBUF_NODISCARD ::cosmos::staking::v1beta1::Commission* release_commission();
  ::cosmos::staking::v1beta1::Commission* mutable_commission();
  void set_allocated_commission(::cosmos::staking::v1beta1::Commission* value);
  void unsafe_arena_set_allocated_commission(::cosmos::staking::v1beta1::Commission* value);
  ::cosmos::staking::v1beta1::Commission* unsafe_arena_release_commission();

  private:
  const ::cosmos::staking::v1beta1::Commission& _internal_commission() const;
  ::cosmos::staking::v1beta1::Commission* _internal_mutable_commission();

  public:
  // bool jailed = 3 [json_name = "jailed"];
  void clear_jailed() ;
  bool jailed() const;
  void set_jailed(bool value);

  private:
  bool _internal_jailed() const;
  void _internal_set_jailed(bool value);

  public:
  // .cosmos.staking.v1beta1.BondStatus status = 4 [json_name = "status"];
  void clear_status() ;
  ::cosmos::staking::v1beta1::BondStatus status() const;
  void set_status(::cosmos::staking::v1beta1::BondStatus value);

  private:
  ::cosmos::staking::v1beta1::BondStatus _internal_status() const;
  void _internal_set_status(::cosmos::staking::v1beta1::BondStatus value);

  public:
  // int64 unbonding_height = 8 [json_name = "unbondingHeight"];
  void clear_unbonding_height() ;
  ::int64_t unbonding_height() const;
  void set_unbonding_height(::int64_t value);

  private:
  ::int64_t _internal_unbonding_height() const;
  void _internal_set_unbonding_height(::int64_t value);

  public:
  // int64 unbonding_on_hold_ref_count = 12 [json_name = "unbondingOnHoldRefCount"];
  void clear_unbonding_on_hold_ref_count() ;
  ::int64_t unbonding_on_hold_ref_count() const;
  void set_unbonding_on_hold_ref_count(::int64_t value);

  private:
  ::int64_t _internal_unbonding_on_hold_ref_count() const;
  void _internal_set_unbonding_on_hold_ref_count(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.Validator)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 13, 4,
      106, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Validator& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint64_t> unbonding_ids_;
    ::google::protobuf::internal::CachedSize _unbonding_ids_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr operator_address_;
    ::google::protobuf::internal::ArenaStringPtr tokens_;
    ::google::protobuf::internal::ArenaStringPtr delegator_shares_;
    ::google::protobuf::internal::ArenaStringPtr min_self_delegation_;
    ::google::protobuf::Any* consensus_pubkey_;
    ::cosmos::staking::v1beta1::Description* description_;
    ::google::protobuf::Timestamp* unbonding_time_;
    ::cosmos::staking::v1beta1::Commission* commission_;
    bool jailed_;
    int status_;
    ::int64_t unbonding_height_;
    ::int64_t unbonding_on_hold_ref_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};
// -------------------------------------------------------------------

class UnbondingDelegation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.UnbondingDelegation) */ {
 public:
  inline UnbondingDelegation() : UnbondingDelegation(nullptr) {}
  ~UnbondingDelegation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UnbondingDelegation* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UnbondingDelegation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UnbondingDelegation(
      ::google::protobuf::internal::ConstantInitialized);

  inline UnbondingDelegation(const UnbondingDelegation& from) : UnbondingDelegation(nullptr, from) {}
  inline UnbondingDelegation(UnbondingDelegation&& from) noexcept
      : UnbondingDelegation(nullptr, std::move(from)) {}
  inline UnbondingDelegation& operator=(const UnbondingDelegation& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnbondingDelegation& operator=(UnbondingDelegation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnbondingDelegation& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnbondingDelegation* internal_default_instance() {
    return reinterpret_cast<const UnbondingDelegation*>(
        &_UnbondingDelegation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(UnbondingDelegation& a, UnbondingDelegation& b) { a.Swap(&b); }
  inline void Swap(UnbondingDelegation* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnbondingDelegation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnbondingDelegation* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UnbondingDelegation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UnbondingDelegation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UnbondingDelegation& from) { UnbondingDelegation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UnbondingDelegation* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.staking.v1beta1.UnbondingDelegation"; }

 protected:
  explicit UnbondingDelegation(::google::protobuf::Arena* arena);
  UnbondingDelegation(::google::protobuf::Arena* arena, const UnbondingDelegation& from);
  UnbondingDelegation(::google::protobuf::Arena* arena, UnbondingDelegation&& from) noexcept
      : UnbondingDelegation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntriesFieldNumber = 3,
    kDelegatorAddressFieldNumber = 1,
    kValidatorAddressFieldNumber = 2,
  };
  // repeated .cosmos.staking.v1beta1.UnbondingDelegationEntry entries = 3 [json_name = "entries", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::cosmos::staking::v1beta1::UnbondingDelegationEntry* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::UnbondingDelegationEntry>* mutable_entries();

  private:
  const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::UnbondingDelegationEntry>& _internal_entries() const;
  ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::UnbondingDelegationEntry>* _internal_mutable_entries();
  public:
  const ::cosmos::staking::v1beta1::UnbondingDelegationEntry& entries(int index) const;
  ::cosmos::staking::v1beta1::UnbondingDelegationEntry* add_entries();
  const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::UnbondingDelegationEntry>& entries() const;
  // string delegator_address = 1 [json_name = "delegatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_delegator_address() ;
  const std::string& delegator_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_delegator_address(Arg_&& arg, Args_... args);
  std::string* mutable_delegator_address();
  PROTOBUF_NODISCARD std::string* release_delegator_address();
  void set_allocated_delegator_address(std::string* value);

  private:
  const std::string& _internal_delegator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delegator_address(
      const std::string& value);
  std::string* _internal_mutable_delegator_address();

  public:
  // string validator_address = 2 [json_name = "validatorAddress", (.cosmos_proto.scalar) = "cosmos.ValidatorAddressString"];
  void clear_validator_address() ;
  const std::string& validator_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_validator_address(Arg_&& arg, Args_... args);
  std::string* mutable_validator_address();
  PROTOBUF_NODISCARD std::string* release_validator_address();
  void set_allocated_validator_address(std::string* value);

  private:
  const std::string& _internal_validator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validator_address(
      const std::string& value);
  std::string* _internal_mutable_validator_address();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.UnbondingDelegation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      85, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UnbondingDelegation& from_msg);
    ::google::protobuf::RepeatedPtrField< ::cosmos::staking::v1beta1::UnbondingDelegationEntry > entries_;
    ::google::protobuf::internal::ArenaStringPtr delegator_address_;
    ::google::protobuf::internal::ArenaStringPtr validator_address_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};
// -------------------------------------------------------------------

class RedelegationEntryResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.RedelegationEntryResponse) */ {
 public:
  inline RedelegationEntryResponse() : RedelegationEntryResponse(nullptr) {}
  ~RedelegationEntryResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RedelegationEntryResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RedelegationEntryResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RedelegationEntryResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RedelegationEntryResponse(const RedelegationEntryResponse& from) : RedelegationEntryResponse(nullptr, from) {}
  inline RedelegationEntryResponse(RedelegationEntryResponse&& from) noexcept
      : RedelegationEntryResponse(nullptr, std::move(from)) {}
  inline RedelegationEntryResponse& operator=(const RedelegationEntryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedelegationEntryResponse& operator=(RedelegationEntryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RedelegationEntryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RedelegationEntryResponse* internal_default_instance() {
    return reinterpret_cast<const RedelegationEntryResponse*>(
        &_RedelegationEntryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(RedelegationEntryResponse& a, RedelegationEntryResponse& b) { a.Swap(&b); }
  inline void Swap(RedelegationEntryResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedelegationEntryResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RedelegationEntryResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RedelegationEntryResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RedelegationEntryResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RedelegationEntryResponse& from) { RedelegationEntryResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RedelegationEntryResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.staking.v1beta1.RedelegationEntryResponse"; }

 protected:
  explicit RedelegationEntryResponse(::google::protobuf::Arena* arena);
  RedelegationEntryResponse(::google::protobuf::Arena* arena, const RedelegationEntryResponse& from);
  RedelegationEntryResponse(::google::protobuf::Arena* arena, RedelegationEntryResponse&& from) noexcept
      : RedelegationEntryResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBalanceFieldNumber = 4,
    kRedelegationEntryFieldNumber = 1,
  };
  // string balance = 4 [json_name = "balance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.Int", (.cosmos_proto.scalar) = "cosmos.Int"];
  void clear_balance() ;
  const std::string& balance() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_balance(Arg_&& arg, Args_... args);
  std::string* mutable_balance();
  PROTOBUF_NODISCARD std::string* release_balance();
  void set_allocated_balance(std::string* value);

  private:
  const std::string& _internal_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_balance(
      const std::string& value);
  std::string* _internal_mutable_balance();

  public:
  // .cosmos.staking.v1beta1.RedelegationEntry redelegation_entry = 1 [json_name = "redelegationEntry", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  bool has_redelegation_entry() const;
  void clear_redelegation_entry() ;
  const ::cosmos::staking::v1beta1::RedelegationEntry& redelegation_entry() const;
  PROTOBUF_NODISCARD ::cosmos::staking::v1beta1::RedelegationEntry* release_redelegation_entry();
  ::cosmos::staking::v1beta1::RedelegationEntry* mutable_redelegation_entry();
  void set_allocated_redelegation_entry(::cosmos::staking::v1beta1::RedelegationEntry* value);
  void unsafe_arena_set_allocated_redelegation_entry(::cosmos::staking::v1beta1::RedelegationEntry* value);
  ::cosmos::staking::v1beta1::RedelegationEntry* unsafe_arena_release_redelegation_entry();

  private:
  const ::cosmos::staking::v1beta1::RedelegationEntry& _internal_redelegation_entry() const;
  ::cosmos::staking::v1beta1::RedelegationEntry* _internal_mutable_redelegation_entry();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.RedelegationEntryResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      64, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RedelegationEntryResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr balance_;
    ::cosmos::staking::v1beta1::RedelegationEntry* redelegation_entry_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};
// -------------------------------------------------------------------

class Redelegation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.Redelegation) */ {
 public:
  inline Redelegation() : Redelegation(nullptr) {}
  ~Redelegation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Redelegation* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Redelegation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Redelegation(
      ::google::protobuf::internal::ConstantInitialized);

  inline Redelegation(const Redelegation& from) : Redelegation(nullptr, from) {}
  inline Redelegation(Redelegation&& from) noexcept
      : Redelegation(nullptr, std::move(from)) {}
  inline Redelegation& operator=(const Redelegation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Redelegation& operator=(Redelegation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Redelegation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Redelegation* internal_default_instance() {
    return reinterpret_cast<const Redelegation*>(
        &_Redelegation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(Redelegation& a, Redelegation& b) { a.Swap(&b); }
  inline void Swap(Redelegation* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Redelegation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Redelegation* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Redelegation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Redelegation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Redelegation& from) { Redelegation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Redelegation* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.staking.v1beta1.Redelegation"; }

 protected:
  explicit Redelegation(::google::protobuf::Arena* arena);
  Redelegation(::google::protobuf::Arena* arena, const Redelegation& from);
  Redelegation(::google::protobuf::Arena* arena, Redelegation&& from) noexcept
      : Redelegation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntriesFieldNumber = 4,
    kDelegatorAddressFieldNumber = 1,
    kValidatorSrcAddressFieldNumber = 2,
    kValidatorDstAddressFieldNumber = 3,
  };
  // repeated .cosmos.staking.v1beta1.RedelegationEntry entries = 4 [json_name = "entries", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::cosmos::staking::v1beta1::RedelegationEntry* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntry>* mutable_entries();

  private:
  const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntry>& _internal_entries() const;
  ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntry>* _internal_mutable_entries();
  public:
  const ::cosmos::staking::v1beta1::RedelegationEntry& entries(int index) const;
  ::cosmos::staking::v1beta1::RedelegationEntry* add_entries();
  const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntry>& entries() const;
  // string delegator_address = 1 [json_name = "delegatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_delegator_address() ;
  const std::string& delegator_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_delegator_address(Arg_&& arg, Args_... args);
  std::string* mutable_delegator_address();
  PROTOBUF_NODISCARD std::string* release_delegator_address();
  void set_allocated_delegator_address(std::string* value);

  private:
  const std::string& _internal_delegator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delegator_address(
      const std::string& value);
  std::string* _internal_mutable_delegator_address();

  public:
  // string validator_src_address = 2 [json_name = "validatorSrcAddress", (.cosmos_proto.scalar) = "cosmos.ValidatorAddressString"];
  void clear_validator_src_address() ;
  const std::string& validator_src_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_validator_src_address(Arg_&& arg, Args_... args);
  std::string* mutable_validator_src_address();
  PROTOBUF_NODISCARD std::string* release_validator_src_address();
  void set_allocated_validator_src_address(std::string* value);

  private:
  const std::string& _internal_validator_src_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validator_src_address(
      const std::string& value);
  std::string* _internal_mutable_validator_src_address();

  public:
  // string validator_dst_address = 3 [json_name = "validatorDstAddress", (.cosmos_proto.scalar) = "cosmos.ValidatorAddressString"];
  void clear_validator_dst_address() ;
  const std::string& validator_dst_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_validator_dst_address(Arg_&& arg, Args_... args);
  std::string* mutable_validator_dst_address();
  PROTOBUF_NODISCARD std::string* release_validator_dst_address();
  void set_allocated_validator_dst_address(std::string* value);

  private:
  const std::string& _internal_validator_dst_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_validator_dst_address(
      const std::string& value);
  std::string* _internal_mutable_validator_dst_address();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.Redelegation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      103, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Redelegation& from_msg);
    ::google::protobuf::RepeatedPtrField< ::cosmos::staking::v1beta1::RedelegationEntry > entries_;
    ::google::protobuf::internal::ArenaStringPtr delegator_address_;
    ::google::protobuf::internal::ArenaStringPtr validator_src_address_;
    ::google::protobuf::internal::ArenaStringPtr validator_dst_address_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};
// -------------------------------------------------------------------

class RedelegationResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.RedelegationResponse) */ {
 public:
  inline RedelegationResponse() : RedelegationResponse(nullptr) {}
  ~RedelegationResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RedelegationResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RedelegationResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RedelegationResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RedelegationResponse(const RedelegationResponse& from) : RedelegationResponse(nullptr, from) {}
  inline RedelegationResponse(RedelegationResponse&& from) noexcept
      : RedelegationResponse(nullptr, std::move(from)) {}
  inline RedelegationResponse& operator=(const RedelegationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedelegationResponse& operator=(RedelegationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RedelegationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RedelegationResponse* internal_default_instance() {
    return reinterpret_cast<const RedelegationResponse*>(
        &_RedelegationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(RedelegationResponse& a, RedelegationResponse& b) { a.Swap(&b); }
  inline void Swap(RedelegationResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedelegationResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RedelegationResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RedelegationResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RedelegationResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RedelegationResponse& from) { RedelegationResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RedelegationResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.staking.v1beta1.RedelegationResponse"; }

 protected:
  explicit RedelegationResponse(::google::protobuf::Arena* arena);
  RedelegationResponse(::google::protobuf::Arena* arena, const RedelegationResponse& from);
  RedelegationResponse(::google::protobuf::Arena* arena, RedelegationResponse&& from) noexcept
      : RedelegationResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntriesFieldNumber = 2,
    kRedelegationFieldNumber = 1,
  };
  // repeated .cosmos.staking.v1beta1.RedelegationEntryResponse entries = 2 [json_name = "entries", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::cosmos::staking::v1beta1::RedelegationEntryResponse* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntryResponse>* mutable_entries();

  private:
  const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntryResponse>& _internal_entries() const;
  ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntryResponse>* _internal_mutable_entries();
  public:
  const ::cosmos::staking::v1beta1::RedelegationEntryResponse& entries(int index) const;
  ::cosmos::staking::v1beta1::RedelegationEntryResponse* add_entries();
  const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntryResponse>& entries() const;
  // .cosmos.staking.v1beta1.Redelegation redelegation = 1 [json_name = "redelegation", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  bool has_redelegation() const;
  void clear_redelegation() ;
  const ::cosmos::staking::v1beta1::Redelegation& redelegation() const;
  PROTOBUF_NODISCARD ::cosmos::staking::v1beta1::Redelegation* release_redelegation();
  ::cosmos::staking::v1beta1::Redelegation* mutable_redelegation();
  void set_allocated_redelegation(::cosmos::staking::v1beta1::Redelegation* value);
  void unsafe_arena_set_allocated_redelegation(::cosmos::staking::v1beta1::Redelegation* value);
  ::cosmos::staking::v1beta1::Redelegation* unsafe_arena_release_redelegation();

  private:
  const ::cosmos::staking::v1beta1::Redelegation& _internal_redelegation() const;
  ::cosmos::staking::v1beta1::Redelegation* _internal_mutable_redelegation();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.RedelegationResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RedelegationResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::cosmos::staking::v1beta1::RedelegationEntryResponse > entries_;
    ::cosmos::staking::v1beta1::Redelegation* redelegation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};
// -------------------------------------------------------------------

class HistoricalInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.staking.v1beta1.HistoricalInfo) */ {
 public:
  inline HistoricalInfo() : HistoricalInfo(nullptr) {}
  ~HistoricalInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HistoricalInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HistoricalInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HistoricalInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline HistoricalInfo(const HistoricalInfo& from) : HistoricalInfo(nullptr, from) {}
  inline HistoricalInfo(HistoricalInfo&& from) noexcept
      : HistoricalInfo(nullptr, std::move(from)) {}
  inline HistoricalInfo& operator=(const HistoricalInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline HistoricalInfo& operator=(HistoricalInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HistoricalInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const HistoricalInfo* internal_default_instance() {
    return reinterpret_cast<const HistoricalInfo*>(
        &_HistoricalInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(HistoricalInfo& a, HistoricalInfo& b) { a.Swap(&b); }
  inline void Swap(HistoricalInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HistoricalInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HistoricalInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HistoricalInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HistoricalInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HistoricalInfo& from) { HistoricalInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HistoricalInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.staking.v1beta1.HistoricalInfo"; }

 protected:
  explicit HistoricalInfo(::google::protobuf::Arena* arena);
  HistoricalInfo(::google::protobuf::Arena* arena, const HistoricalInfo& from);
  HistoricalInfo(::google::protobuf::Arena* arena, HistoricalInfo&& from) noexcept
      : HistoricalInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValsetFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .cosmos.staking.v1beta1.Validator valset = 2 [json_name = "valset", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  int valset_size() const;
  private:
  int _internal_valset_size() const;

  public:
  void clear_valset() ;
  ::cosmos::staking::v1beta1::Validator* mutable_valset(int index);
  ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::Validator>* mutable_valset();

  private:
  const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::Validator>& _internal_valset() const;
  ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::Validator>* _internal_mutable_valset();
  public:
  const ::cosmos::staking::v1beta1::Validator& valset(int index) const;
  ::cosmos::staking::v1beta1::Validator* add_valset();
  const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::Validator>& valset() const;
  // .tendermint.types.Header header = 1 [json_name = "header", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  bool has_header() const;
  void clear_header() ;
  const ::tendermint::types::Header& header() const;
  PROTOBUF_NODISCARD ::tendermint::types::Header* release_header();
  ::tendermint::types::Header* mutable_header();
  void set_allocated_header(::tendermint::types::Header* value);
  void unsafe_arena_set_allocated_header(::tendermint::types::Header* value);
  ::tendermint::types::Header* unsafe_arena_release_header();

  private:
  const ::tendermint::types::Header& _internal_header() const;
  ::tendermint::types::Header* _internal_mutable_header();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.staking.v1beta1.HistoricalInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HistoricalInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::cosmos::staking::v1beta1::Validator > valset_;
    ::tendermint::types::Header* header_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fstaking_2fv1beta1_2fstaking_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// HistoricalInfo

// .tendermint.types.Header header = 1 [json_name = "header", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline bool HistoricalInfo::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline const ::tendermint::types::Header& HistoricalInfo::_internal_header() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tendermint::types::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::types::Header&>(::tendermint::types::_Header_default_instance_);
}
inline const ::tendermint::types::Header& HistoricalInfo::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.HistoricalInfo.header)
  return _internal_header();
}
inline void HistoricalInfo::unsafe_arena_set_allocated_header(::tendermint::types::Header* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::tendermint::types::Header*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.HistoricalInfo.header)
}
inline ::tendermint::types::Header* HistoricalInfo::release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::types::Header* released = _impl_.header_;
  _impl_.header_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::tendermint::types::Header* HistoricalInfo::unsafe_arena_release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.HistoricalInfo.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tendermint::types::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::tendermint::types::Header* HistoricalInfo::_internal_mutable_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tendermint::types::Header>(GetArena());
    _impl_.header_ = reinterpret_cast<::tendermint::types::Header*>(p);
  }
  return _impl_.header_;
}
inline ::tendermint::types::Header* HistoricalInfo::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tendermint::types::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.HistoricalInfo.header)
  return _msg;
}
inline void HistoricalInfo::set_allocated_header(::tendermint::types::Header* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::tendermint::types::Header*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.HistoricalInfo.header)
}

// repeated .cosmos.staking.v1beta1.Validator valset = 2 [json_name = "valset", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline int HistoricalInfo::_internal_valset_size() const {
  return _internal_valset().size();
}
inline int HistoricalInfo::valset_size() const {
  return _internal_valset_size();
}
inline void HistoricalInfo::clear_valset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.valset_.Clear();
}
inline ::cosmos::staking::v1beta1::Validator* HistoricalInfo::mutable_valset(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.HistoricalInfo.valset)
  return _internal_mutable_valset()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::Validator>* HistoricalInfo::mutable_valset()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cosmos.staking.v1beta1.HistoricalInfo.valset)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_valset();
}
inline const ::cosmos::staking::v1beta1::Validator& HistoricalInfo::valset(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.HistoricalInfo.valset)
  return _internal_valset().Get(index);
}
inline ::cosmos::staking::v1beta1::Validator* HistoricalInfo::add_valset() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::cosmos::staking::v1beta1::Validator* _add = _internal_mutable_valset()->Add();
  // @@protoc_insertion_point(field_add:cosmos.staking.v1beta1.HistoricalInfo.valset)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::Validator>& HistoricalInfo::valset() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cosmos.staking.v1beta1.HistoricalInfo.valset)
  return _internal_valset();
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::Validator>&
HistoricalInfo::_internal_valset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.valset_;
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::Validator>*
HistoricalInfo::_internal_mutable_valset() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.valset_;
}

// -------------------------------------------------------------------

// CommissionRates

// string rate = 1 [json_name = "rate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.LegacyDec", (.cosmos_proto.scalar) = "cosmos.Dec", (.amino.dont_omitempty) = true];
inline void CommissionRates::clear_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rate_.ClearToEmpty();
}
inline const std::string& CommissionRates::rate() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.CommissionRates.rate)
  return _internal_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommissionRates::set_rate(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rate_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.CommissionRates.rate)
}
inline std::string* CommissionRates::mutable_rate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_rate();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.CommissionRates.rate)
  return _s;
}
inline const std::string& CommissionRates::_internal_rate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rate_.Get();
}
inline void CommissionRates::_internal_set_rate(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rate_.Set(value, GetArena());
}
inline std::string* CommissionRates::_internal_mutable_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.rate_.Mutable( GetArena());
}
inline std::string* CommissionRates::release_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.CommissionRates.rate)
  return _impl_.rate_.Release();
}
inline void CommissionRates::set_allocated_rate(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rate_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.rate_.IsDefault()) {
    _impl_.rate_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.CommissionRates.rate)
}

// string max_rate = 2 [json_name = "maxRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.LegacyDec", (.cosmos_proto.scalar) = "cosmos.Dec", (.amino.dont_omitempty) = true];
inline void CommissionRates::clear_max_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_rate_.ClearToEmpty();
}
inline const std::string& CommissionRates::max_rate() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.CommissionRates.max_rate)
  return _internal_max_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommissionRates::set_max_rate(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.CommissionRates.max_rate)
}
inline std::string* CommissionRates::mutable_max_rate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_max_rate();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.CommissionRates.max_rate)
  return _s;
}
inline const std::string& CommissionRates::_internal_max_rate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_rate_.Get();
}
inline void CommissionRates::_internal_set_max_rate(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_rate_.Set(value, GetArena());
}
inline std::string* CommissionRates::_internal_mutable_max_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.max_rate_.Mutable( GetArena());
}
inline std::string* CommissionRates::release_max_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.CommissionRates.max_rate)
  return _impl_.max_rate_.Release();
}
inline void CommissionRates::set_allocated_max_rate(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_rate_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.max_rate_.IsDefault()) {
    _impl_.max_rate_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.CommissionRates.max_rate)
}

// string max_change_rate = 3 [json_name = "maxChangeRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.LegacyDec", (.cosmos_proto.scalar) = "cosmos.Dec", (.amino.dont_omitempty) = true];
inline void CommissionRates::clear_max_change_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_change_rate_.ClearToEmpty();
}
inline const std::string& CommissionRates::max_change_rate() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.CommissionRates.max_change_rate)
  return _internal_max_change_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommissionRates::set_max_change_rate(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_change_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.CommissionRates.max_change_rate)
}
inline std::string* CommissionRates::mutable_max_change_rate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_max_change_rate();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.CommissionRates.max_change_rate)
  return _s;
}
inline const std::string& CommissionRates::_internal_max_change_rate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_change_rate_.Get();
}
inline void CommissionRates::_internal_set_max_change_rate(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_change_rate_.Set(value, GetArena());
}
inline std::string* CommissionRates::_internal_mutable_max_change_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.max_change_rate_.Mutable( GetArena());
}
inline std::string* CommissionRates::release_max_change_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.CommissionRates.max_change_rate)
  return _impl_.max_change_rate_.Release();
}
inline void CommissionRates::set_allocated_max_change_rate(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_change_rate_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.max_change_rate_.IsDefault()) {
    _impl_.max_change_rate_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.CommissionRates.max_change_rate)
}

// -------------------------------------------------------------------

// Commission

// .cosmos.staking.v1beta1.CommissionRates commission_rates = 1 [json_name = "commissionRates", (.gogoproto.nullable) = false, (.gogoproto.embed) = true, (.amino.dont_omitempty) = true];
inline bool Commission::has_commission_rates() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.commission_rates_ != nullptr);
  return value;
}
inline void Commission::clear_commission_rates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.commission_rates_ != nullptr) _impl_.commission_rates_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cosmos::staking::v1beta1::CommissionRates& Commission::_internal_commission_rates() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::cosmos::staking::v1beta1::CommissionRates* p = _impl_.commission_rates_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::staking::v1beta1::CommissionRates&>(::cosmos::staking::v1beta1::_CommissionRates_default_instance_);
}
inline const ::cosmos::staking::v1beta1::CommissionRates& Commission::commission_rates() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Commission.commission_rates)
  return _internal_commission_rates();
}
inline void Commission::unsafe_arena_set_allocated_commission_rates(::cosmos::staking::v1beta1::CommissionRates* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.commission_rates_);
  }
  _impl_.commission_rates_ = reinterpret_cast<::cosmos::staking::v1beta1::CommissionRates*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.Commission.commission_rates)
}
inline ::cosmos::staking::v1beta1::CommissionRates* Commission::release_commission_rates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::staking::v1beta1::CommissionRates* released = _impl_.commission_rates_;
  _impl_.commission_rates_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::cosmos::staking::v1beta1::CommissionRates* Commission::unsafe_arena_release_commission_rates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Commission.commission_rates)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::staking::v1beta1::CommissionRates* temp = _impl_.commission_rates_;
  _impl_.commission_rates_ = nullptr;
  return temp;
}
inline ::cosmos::staking::v1beta1::CommissionRates* Commission::_internal_mutable_commission_rates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.commission_rates_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::cosmos::staking::v1beta1::CommissionRates>(GetArena());
    _impl_.commission_rates_ = reinterpret_cast<::cosmos::staking::v1beta1::CommissionRates*>(p);
  }
  return _impl_.commission_rates_;
}
inline ::cosmos::staking::v1beta1::CommissionRates* Commission::mutable_commission_rates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::cosmos::staking::v1beta1::CommissionRates* _msg = _internal_mutable_commission_rates();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Commission.commission_rates)
  return _msg;
}
inline void Commission::set_allocated_commission_rates(::cosmos::staking::v1beta1::CommissionRates* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.commission_rates_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.commission_rates_ = reinterpret_cast<::cosmos::staking::v1beta1::CommissionRates*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Commission.commission_rates)
}

// .google.protobuf.Timestamp update_time = 2 [json_name = "updateTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true, (.amino.dont_omitempty) = true];
inline bool Commission::has_update_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.update_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Commission::_internal_update_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.update_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Commission::update_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Commission.update_time)
  return _internal_update_time();
}
inline void Commission::unsafe_arena_set_allocated_update_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_time_);
  }
  _impl_.update_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.Commission.update_time)
}
inline ::google::protobuf::Timestamp* Commission::release_update_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.update_time_;
  _impl_.update_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* Commission::unsafe_arena_release_update_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Commission.update_time)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.update_time_;
  _impl_.update_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Commission::_internal_mutable_update_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.update_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.update_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.update_time_;
}
inline ::google::protobuf::Timestamp* Commission::mutable_update_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_update_time();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Commission.update_time)
  return _msg;
}
inline void Commission::set_allocated_update_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.update_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Commission.update_time)
}

// -------------------------------------------------------------------

// Description

// string moniker = 1 [json_name = "moniker"];
inline void Description::clear_moniker() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.moniker_.ClearToEmpty();
}
inline const std::string& Description::moniker() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Description.moniker)
  return _internal_moniker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Description::set_moniker(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.moniker_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Description.moniker)
}
inline std::string* Description::mutable_moniker() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_moniker();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Description.moniker)
  return _s;
}
inline const std::string& Description::_internal_moniker() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.moniker_.Get();
}
inline void Description::_internal_set_moniker(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.moniker_.Set(value, GetArena());
}
inline std::string* Description::_internal_mutable_moniker() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.moniker_.Mutable( GetArena());
}
inline std::string* Description::release_moniker() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Description.moniker)
  return _impl_.moniker_.Release();
}
inline void Description::set_allocated_moniker(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.moniker_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.moniker_.IsDefault()) {
    _impl_.moniker_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Description.moniker)
}

// string identity = 2 [json_name = "identity"];
inline void Description::clear_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.identity_.ClearToEmpty();
}
inline const std::string& Description::identity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Description.identity)
  return _internal_identity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Description::set_identity(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.identity_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Description.identity)
}
inline std::string* Description::mutable_identity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Description.identity)
  return _s;
}
inline const std::string& Description::_internal_identity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.identity_.Get();
}
inline void Description::_internal_set_identity(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.identity_.Set(value, GetArena());
}
inline std::string* Description::_internal_mutable_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.identity_.Mutable( GetArena());
}
inline std::string* Description::release_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Description.identity)
  return _impl_.identity_.Release();
}
inline void Description::set_allocated_identity(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.identity_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.identity_.IsDefault()) {
    _impl_.identity_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Description.identity)
}

// string website = 3 [json_name = "website"];
inline void Description::clear_website() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.website_.ClearToEmpty();
}
inline const std::string& Description::website() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Description.website)
  return _internal_website();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Description::set_website(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.website_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Description.website)
}
inline std::string* Description::mutable_website() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_website();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Description.website)
  return _s;
}
inline const std::string& Description::_internal_website() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.website_.Get();
}
inline void Description::_internal_set_website(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.website_.Set(value, GetArena());
}
inline std::string* Description::_internal_mutable_website() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.website_.Mutable( GetArena());
}
inline std::string* Description::release_website() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Description.website)
  return _impl_.website_.Release();
}
inline void Description::set_allocated_website(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.website_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.website_.IsDefault()) {
    _impl_.website_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Description.website)
}

// string security_contact = 4 [json_name = "securityContact"];
inline void Description::clear_security_contact() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.security_contact_.ClearToEmpty();
}
inline const std::string& Description::security_contact() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Description.security_contact)
  return _internal_security_contact();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Description::set_security_contact(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.security_contact_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Description.security_contact)
}
inline std::string* Description::mutable_security_contact() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_security_contact();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Description.security_contact)
  return _s;
}
inline const std::string& Description::_internal_security_contact() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.security_contact_.Get();
}
inline void Description::_internal_set_security_contact(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.security_contact_.Set(value, GetArena());
}
inline std::string* Description::_internal_mutable_security_contact() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.security_contact_.Mutable( GetArena());
}
inline std::string* Description::release_security_contact() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Description.security_contact)
  return _impl_.security_contact_.Release();
}
inline void Description::set_allocated_security_contact(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.security_contact_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.security_contact_.IsDefault()) {
    _impl_.security_contact_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Description.security_contact)
}

// string details = 5 [json_name = "details"];
inline void Description::clear_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.details_.ClearToEmpty();
}
inline const std::string& Description::details() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Description.details)
  return _internal_details();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Description::set_details(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.details_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Description.details)
}
inline std::string* Description::mutable_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_details();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Description.details)
  return _s;
}
inline const std::string& Description::_internal_details() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.details_.Get();
}
inline void Description::_internal_set_details(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.details_.Set(value, GetArena());
}
inline std::string* Description::_internal_mutable_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.details_.Mutable( GetArena());
}
inline std::string* Description::release_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Description.details)
  return _impl_.details_.Release();
}
inline void Description::set_allocated_details(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.details_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.details_.IsDefault()) {
    _impl_.details_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Description.details)
}

// -------------------------------------------------------------------

// Validator

// string operator_address = 1 [json_name = "operatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void Validator::clear_operator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operator_address_.ClearToEmpty();
}
inline const std::string& Validator::operator_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.operator_address)
  return _internal_operator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Validator::set_operator_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Validator.operator_address)
}
inline std::string* Validator::mutable_operator_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_operator_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Validator.operator_address)
  return _s;
}
inline const std::string& Validator::_internal_operator_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.operator_address_.Get();
}
inline void Validator::_internal_set_operator_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operator_address_.Set(value, GetArena());
}
inline std::string* Validator::_internal_mutable_operator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.operator_address_.Mutable( GetArena());
}
inline std::string* Validator::release_operator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Validator.operator_address)
  return _impl_.operator_address_.Release();
}
inline void Validator::set_allocated_operator_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operator_address_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.operator_address_.IsDefault()) {
    _impl_.operator_address_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Validator.operator_address)
}

// .google.protobuf.Any consensus_pubkey = 2 [json_name = "consensusPubkey", (.cosmos_proto.accepts_interface) = "cosmos.crypto.PubKey"];
inline bool Validator::has_consensus_pubkey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.consensus_pubkey_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& Validator::_internal_consensus_pubkey() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Any* p = _impl_.consensus_pubkey_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& Validator::consensus_pubkey() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.consensus_pubkey)
  return _internal_consensus_pubkey();
}
inline void Validator::unsafe_arena_set_allocated_consensus_pubkey(::google::protobuf::Any* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.consensus_pubkey_);
  }
  _impl_.consensus_pubkey_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.Validator.consensus_pubkey)
}
inline ::google::protobuf::Any* Validator::release_consensus_pubkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* released = _impl_.consensus_pubkey_;
  _impl_.consensus_pubkey_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Any* Validator::unsafe_arena_release_consensus_pubkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Validator.consensus_pubkey)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* temp = _impl_.consensus_pubkey_;
  _impl_.consensus_pubkey_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* Validator::_internal_mutable_consensus_pubkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.consensus_pubkey_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Any>(GetArena());
    _impl_.consensus_pubkey_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.consensus_pubkey_;
}
inline ::google::protobuf::Any* Validator::mutable_consensus_pubkey() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Any* _msg = _internal_mutable_consensus_pubkey();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Validator.consensus_pubkey)
  return _msg;
}
inline void Validator::set_allocated_consensus_pubkey(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.consensus_pubkey_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.consensus_pubkey_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Validator.consensus_pubkey)
}

// bool jailed = 3 [json_name = "jailed"];
inline void Validator::clear_jailed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.jailed_ = false;
}
inline bool Validator::jailed() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.jailed)
  return _internal_jailed();
}
inline void Validator::set_jailed(bool value) {
  _internal_set_jailed(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Validator.jailed)
}
inline bool Validator::_internal_jailed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.jailed_;
}
inline void Validator::_internal_set_jailed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.jailed_ = value;
}

// .cosmos.staking.v1beta1.BondStatus status = 4 [json_name = "status"];
inline void Validator::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::cosmos::staking::v1beta1::BondStatus Validator::status() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.status)
  return _internal_status();
}
inline void Validator::set_status(::cosmos::staking::v1beta1::BondStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Validator.status)
}
inline ::cosmos::staking::v1beta1::BondStatus Validator::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::cosmos::staking::v1beta1::BondStatus>(_impl_.status_);
}
inline void Validator::_internal_set_status(::cosmos::staking::v1beta1::BondStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// string tokens = 5 [json_name = "tokens", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.Int", (.cosmos_proto.scalar) = "cosmos.Int"];
inline void Validator::clear_tokens() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tokens_.ClearToEmpty();
}
inline const std::string& Validator::tokens() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.tokens)
  return _internal_tokens();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Validator::set_tokens(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tokens_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Validator.tokens)
}
inline std::string* Validator::mutable_tokens() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tokens();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Validator.tokens)
  return _s;
}
inline const std::string& Validator::_internal_tokens() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tokens_.Get();
}
inline void Validator::_internal_set_tokens(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tokens_.Set(value, GetArena());
}
inline std::string* Validator::_internal_mutable_tokens() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.tokens_.Mutable( GetArena());
}
inline std::string* Validator::release_tokens() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Validator.tokens)
  return _impl_.tokens_.Release();
}
inline void Validator::set_allocated_tokens(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tokens_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.tokens_.IsDefault()) {
    _impl_.tokens_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Validator.tokens)
}

// string delegator_shares = 6 [json_name = "delegatorShares", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.LegacyDec", (.cosmos_proto.scalar) = "cosmos.Dec"];
inline void Validator::clear_delegator_shares() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_shares_.ClearToEmpty();
}
inline const std::string& Validator::delegator_shares() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.delegator_shares)
  return _internal_delegator_shares();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Validator::set_delegator_shares(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_shares_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Validator.delegator_shares)
}
inline std::string* Validator::mutable_delegator_shares() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_delegator_shares();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Validator.delegator_shares)
  return _s;
}
inline const std::string& Validator::_internal_delegator_shares() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.delegator_shares_.Get();
}
inline void Validator::_internal_set_delegator_shares(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_shares_.Set(value, GetArena());
}
inline std::string* Validator::_internal_mutable_delegator_shares() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.delegator_shares_.Mutable( GetArena());
}
inline std::string* Validator::release_delegator_shares() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Validator.delegator_shares)
  return _impl_.delegator_shares_.Release();
}
inline void Validator::set_allocated_delegator_shares(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_shares_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.delegator_shares_.IsDefault()) {
    _impl_.delegator_shares_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Validator.delegator_shares)
}

// .cosmos.staking.v1beta1.Description description = 7 [json_name = "description", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline bool Validator::has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.description_ != nullptr);
  return value;
}
inline void Validator::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.description_ != nullptr) _impl_.description_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::cosmos::staking::v1beta1::Description& Validator::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::cosmos::staking::v1beta1::Description* p = _impl_.description_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::staking::v1beta1::Description&>(::cosmos::staking::v1beta1::_Description_default_instance_);
}
inline const ::cosmos::staking::v1beta1::Description& Validator::description() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.description)
  return _internal_description();
}
inline void Validator::unsafe_arena_set_allocated_description(::cosmos::staking::v1beta1::Description* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.description_);
  }
  _impl_.description_ = reinterpret_cast<::cosmos::staking::v1beta1::Description*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.Validator.description)
}
inline ::cosmos::staking::v1beta1::Description* Validator::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::staking::v1beta1::Description* released = _impl_.description_;
  _impl_.description_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::cosmos::staking::v1beta1::Description* Validator::unsafe_arena_release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Validator.description)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::staking::v1beta1::Description* temp = _impl_.description_;
  _impl_.description_ = nullptr;
  return temp;
}
inline ::cosmos::staking::v1beta1::Description* Validator::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.description_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::cosmos::staking::v1beta1::Description>(GetArena());
    _impl_.description_ = reinterpret_cast<::cosmos::staking::v1beta1::Description*>(p);
  }
  return _impl_.description_;
}
inline ::cosmos::staking::v1beta1::Description* Validator::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::cosmos::staking::v1beta1::Description* _msg = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Validator.description)
  return _msg;
}
inline void Validator::set_allocated_description(::cosmos::staking::v1beta1::Description* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.description_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.description_ = reinterpret_cast<::cosmos::staking::v1beta1::Description*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Validator.description)
}

// int64 unbonding_height = 8 [json_name = "unbondingHeight"];
inline void Validator::clear_unbonding_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unbonding_height_ = ::int64_t{0};
}
inline ::int64_t Validator::unbonding_height() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.unbonding_height)
  return _internal_unbonding_height();
}
inline void Validator::set_unbonding_height(::int64_t value) {
  _internal_set_unbonding_height(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Validator.unbonding_height)
}
inline ::int64_t Validator::_internal_unbonding_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unbonding_height_;
}
inline void Validator::_internal_set_unbonding_height(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unbonding_height_ = value;
}

// .google.protobuf.Timestamp unbonding_time = 9 [json_name = "unbondingTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true, (.amino.dont_omitempty) = true];
inline bool Validator::has_unbonding_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unbonding_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Validator::_internal_unbonding_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.unbonding_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Validator::unbonding_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.unbonding_time)
  return _internal_unbonding_time();
}
inline void Validator::unsafe_arena_set_allocated_unbonding_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.unbonding_time_);
  }
  _impl_.unbonding_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.Validator.unbonding_time)
}
inline ::google::protobuf::Timestamp* Validator::release_unbonding_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* released = _impl_.unbonding_time_;
  _impl_.unbonding_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* Validator::unsafe_arena_release_unbonding_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Validator.unbonding_time)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* temp = _impl_.unbonding_time_;
  _impl_.unbonding_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Validator::_internal_mutable_unbonding_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.unbonding_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.unbonding_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.unbonding_time_;
}
inline ::google::protobuf::Timestamp* Validator::mutable_unbonding_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_unbonding_time();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Validator.unbonding_time)
  return _msg;
}
inline void Validator::set_allocated_unbonding_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.unbonding_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.unbonding_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Validator.unbonding_time)
}

// .cosmos.staking.v1beta1.Commission commission = 10 [json_name = "commission", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline bool Validator::has_commission() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.commission_ != nullptr);
  return value;
}
inline void Validator::clear_commission() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.commission_ != nullptr) _impl_.commission_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::cosmos::staking::v1beta1::Commission& Validator::_internal_commission() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::cosmos::staking::v1beta1::Commission* p = _impl_.commission_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::staking::v1beta1::Commission&>(::cosmos::staking::v1beta1::_Commission_default_instance_);
}
inline const ::cosmos::staking::v1beta1::Commission& Validator::commission() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.commission)
  return _internal_commission();
}
inline void Validator::unsafe_arena_set_allocated_commission(::cosmos::staking::v1beta1::Commission* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.commission_);
  }
  _impl_.commission_ = reinterpret_cast<::cosmos::staking::v1beta1::Commission*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.Validator.commission)
}
inline ::cosmos::staking::v1beta1::Commission* Validator::release_commission() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::cosmos::staking::v1beta1::Commission* released = _impl_.commission_;
  _impl_.commission_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::cosmos::staking::v1beta1::Commission* Validator::unsafe_arena_release_commission() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Validator.commission)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::cosmos::staking::v1beta1::Commission* temp = _impl_.commission_;
  _impl_.commission_ = nullptr;
  return temp;
}
inline ::cosmos::staking::v1beta1::Commission* Validator::_internal_mutable_commission() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.commission_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::cosmos::staking::v1beta1::Commission>(GetArena());
    _impl_.commission_ = reinterpret_cast<::cosmos::staking::v1beta1::Commission*>(p);
  }
  return _impl_.commission_;
}
inline ::cosmos::staking::v1beta1::Commission* Validator::mutable_commission() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::cosmos::staking::v1beta1::Commission* _msg = _internal_mutable_commission();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Validator.commission)
  return _msg;
}
inline void Validator::set_allocated_commission(::cosmos::staking::v1beta1::Commission* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.commission_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.commission_ = reinterpret_cast<::cosmos::staking::v1beta1::Commission*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Validator.commission)
}

// string min_self_delegation = 11 [json_name = "minSelfDelegation", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.Int", (.cosmos_proto.scalar) = "cosmos.Int", (.cosmos_proto.field_added_in) = "cosmos-sdk 0.46"];
inline void Validator::clear_min_self_delegation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_self_delegation_.ClearToEmpty();
}
inline const std::string& Validator::min_self_delegation() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.min_self_delegation)
  return _internal_min_self_delegation();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Validator::set_min_self_delegation(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_self_delegation_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Validator.min_self_delegation)
}
inline std::string* Validator::mutable_min_self_delegation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_min_self_delegation();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Validator.min_self_delegation)
  return _s;
}
inline const std::string& Validator::_internal_min_self_delegation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_self_delegation_.Get();
}
inline void Validator::_internal_set_min_self_delegation(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_self_delegation_.Set(value, GetArena());
}
inline std::string* Validator::_internal_mutable_min_self_delegation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.min_self_delegation_.Mutable( GetArena());
}
inline std::string* Validator::release_min_self_delegation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Validator.min_self_delegation)
  return _impl_.min_self_delegation_.Release();
}
inline void Validator::set_allocated_min_self_delegation(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_self_delegation_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.min_self_delegation_.IsDefault()) {
    _impl_.min_self_delegation_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Validator.min_self_delegation)
}

// int64 unbonding_on_hold_ref_count = 12 [json_name = "unbondingOnHoldRefCount"];
inline void Validator::clear_unbonding_on_hold_ref_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unbonding_on_hold_ref_count_ = ::int64_t{0};
}
inline ::int64_t Validator::unbonding_on_hold_ref_count() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.unbonding_on_hold_ref_count)
  return _internal_unbonding_on_hold_ref_count();
}
inline void Validator::set_unbonding_on_hold_ref_count(::int64_t value) {
  _internal_set_unbonding_on_hold_ref_count(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Validator.unbonding_on_hold_ref_count)
}
inline ::int64_t Validator::_internal_unbonding_on_hold_ref_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unbonding_on_hold_ref_count_;
}
inline void Validator::_internal_set_unbonding_on_hold_ref_count(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unbonding_on_hold_ref_count_ = value;
}

// repeated uint64 unbonding_ids = 13 [json_name = "unbondingIds"];
inline int Validator::_internal_unbonding_ids_size() const {
  return _internal_unbonding_ids().size();
}
inline int Validator::unbonding_ids_size() const {
  return _internal_unbonding_ids_size();
}
inline void Validator::clear_unbonding_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unbonding_ids_.Clear();
}
inline ::uint64_t Validator::unbonding_ids(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Validator.unbonding_ids)
  return _internal_unbonding_ids().Get(index);
}
inline void Validator::set_unbonding_ids(int index, ::uint64_t value) {
  _internal_mutable_unbonding_ids()->Set(index, value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Validator.unbonding_ids)
}
inline void Validator::add_unbonding_ids(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_unbonding_ids()->Add(value);
  // @@protoc_insertion_point(field_add:cosmos.staking.v1beta1.Validator.unbonding_ids)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& Validator::unbonding_ids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cosmos.staking.v1beta1.Validator.unbonding_ids)
  return _internal_unbonding_ids();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* Validator::mutable_unbonding_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cosmos.staking.v1beta1.Validator.unbonding_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_unbonding_ids();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>&
Validator::_internal_unbonding_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unbonding_ids_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* Validator::_internal_mutable_unbonding_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.unbonding_ids_;
}

// -------------------------------------------------------------------

// ValAddresses

// repeated string addresses = 1 [json_name = "addresses", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline int ValAddresses::_internal_addresses_size() const {
  return _internal_addresses().size();
}
inline int ValAddresses::addresses_size() const {
  return _internal_addresses_size();
}
inline void ValAddresses::clear_addresses() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.addresses_.Clear();
}
inline std::string* ValAddresses::add_addresses() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_addresses()->Add();
  // @@protoc_insertion_point(field_add_mutable:cosmos.staking.v1beta1.ValAddresses.addresses)
  return _s;
}
inline const std::string& ValAddresses::addresses(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.ValAddresses.addresses)
  return _internal_addresses().Get(index);
}
inline std::string* ValAddresses::mutable_addresses(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.ValAddresses.addresses)
  return _internal_mutable_addresses()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ValAddresses::set_addresses(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_addresses()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.ValAddresses.addresses)
}
template <typename Arg_, typename... Args_>
inline void ValAddresses::add_addresses(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_addresses(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:cosmos.staking.v1beta1.ValAddresses.addresses)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ValAddresses::addresses() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cosmos.staking.v1beta1.ValAddresses.addresses)
  return _internal_addresses();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ValAddresses::mutable_addresses() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cosmos.staking.v1beta1.ValAddresses.addresses)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_addresses();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ValAddresses::_internal_addresses() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.addresses_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ValAddresses::_internal_mutable_addresses() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.addresses_;
}

// -------------------------------------------------------------------

// DVPair

// string delegator_address = 1 [json_name = "delegatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void DVPair::clear_delegator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_address_.ClearToEmpty();
}
inline const std::string& DVPair::delegator_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.DVPair.delegator_address)
  return _internal_delegator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DVPair::set_delegator_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.DVPair.delegator_address)
}
inline std::string* DVPair::mutable_delegator_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_delegator_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.DVPair.delegator_address)
  return _s;
}
inline const std::string& DVPair::_internal_delegator_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.delegator_address_.Get();
}
inline void DVPair::_internal_set_delegator_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_address_.Set(value, GetArena());
}
inline std::string* DVPair::_internal_mutable_delegator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.delegator_address_.Mutable( GetArena());
}
inline std::string* DVPair::release_delegator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.DVPair.delegator_address)
  return _impl_.delegator_address_.Release();
}
inline void DVPair::set_allocated_delegator_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_address_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.delegator_address_.IsDefault()) {
    _impl_.delegator_address_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.DVPair.delegator_address)
}

// string validator_address = 2 [json_name = "validatorAddress", (.cosmos_proto.scalar) = "cosmos.ValidatorAddressString"];
inline void DVPair::clear_validator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_address_.ClearToEmpty();
}
inline const std::string& DVPair::validator_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.DVPair.validator_address)
  return _internal_validator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DVPair::set_validator_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.DVPair.validator_address)
}
inline std::string* DVPair::mutable_validator_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_validator_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.DVPair.validator_address)
  return _s;
}
inline const std::string& DVPair::_internal_validator_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.validator_address_.Get();
}
inline void DVPair::_internal_set_validator_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_address_.Set(value, GetArena());
}
inline std::string* DVPair::_internal_mutable_validator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.validator_address_.Mutable( GetArena());
}
inline std::string* DVPair::release_validator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.DVPair.validator_address)
  return _impl_.validator_address_.Release();
}
inline void DVPair::set_allocated_validator_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_address_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.validator_address_.IsDefault()) {
    _impl_.validator_address_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.DVPair.validator_address)
}

// -------------------------------------------------------------------

// DVPairs

// repeated .cosmos.staking.v1beta1.DVPair pairs = 1 [json_name = "pairs", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline int DVPairs::_internal_pairs_size() const {
  return _internal_pairs().size();
}
inline int DVPairs::pairs_size() const {
  return _internal_pairs_size();
}
inline void DVPairs::clear_pairs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pairs_.Clear();
}
inline ::cosmos::staking::v1beta1::DVPair* DVPairs::mutable_pairs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.DVPairs.pairs)
  return _internal_mutable_pairs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::DVPair>* DVPairs::mutable_pairs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cosmos.staking.v1beta1.DVPairs.pairs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_pairs();
}
inline const ::cosmos::staking::v1beta1::DVPair& DVPairs::pairs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.DVPairs.pairs)
  return _internal_pairs().Get(index);
}
inline ::cosmos::staking::v1beta1::DVPair* DVPairs::add_pairs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::cosmos::staking::v1beta1::DVPair* _add = _internal_mutable_pairs()->Add();
  // @@protoc_insertion_point(field_add:cosmos.staking.v1beta1.DVPairs.pairs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::DVPair>& DVPairs::pairs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cosmos.staking.v1beta1.DVPairs.pairs)
  return _internal_pairs();
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::DVPair>&
DVPairs::_internal_pairs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pairs_;
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::DVPair>*
DVPairs::_internal_mutable_pairs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.pairs_;
}

// -------------------------------------------------------------------

// DVVTriplet

// string delegator_address = 1 [json_name = "delegatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void DVVTriplet::clear_delegator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_address_.ClearToEmpty();
}
inline const std::string& DVVTriplet::delegator_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.DVVTriplet.delegator_address)
  return _internal_delegator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DVVTriplet::set_delegator_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.DVVTriplet.delegator_address)
}
inline std::string* DVVTriplet::mutable_delegator_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_delegator_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.DVVTriplet.delegator_address)
  return _s;
}
inline const std::string& DVVTriplet::_internal_delegator_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.delegator_address_.Get();
}
inline void DVVTriplet::_internal_set_delegator_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_address_.Set(value, GetArena());
}
inline std::string* DVVTriplet::_internal_mutable_delegator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.delegator_address_.Mutable( GetArena());
}
inline std::string* DVVTriplet::release_delegator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.DVVTriplet.delegator_address)
  return _impl_.delegator_address_.Release();
}
inline void DVVTriplet::set_allocated_delegator_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_address_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.delegator_address_.IsDefault()) {
    _impl_.delegator_address_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.DVVTriplet.delegator_address)
}

// string validator_src_address = 2 [json_name = "validatorSrcAddress", (.cosmos_proto.scalar) = "cosmos.ValidatorAddressString"];
inline void DVVTriplet::clear_validator_src_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_src_address_.ClearToEmpty();
}
inline const std::string& DVVTriplet::validator_src_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.DVVTriplet.validator_src_address)
  return _internal_validator_src_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DVVTriplet::set_validator_src_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_src_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.DVVTriplet.validator_src_address)
}
inline std::string* DVVTriplet::mutable_validator_src_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_validator_src_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.DVVTriplet.validator_src_address)
  return _s;
}
inline const std::string& DVVTriplet::_internal_validator_src_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.validator_src_address_.Get();
}
inline void DVVTriplet::_internal_set_validator_src_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_src_address_.Set(value, GetArena());
}
inline std::string* DVVTriplet::_internal_mutable_validator_src_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.validator_src_address_.Mutable( GetArena());
}
inline std::string* DVVTriplet::release_validator_src_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.DVVTriplet.validator_src_address)
  return _impl_.validator_src_address_.Release();
}
inline void DVVTriplet::set_allocated_validator_src_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_src_address_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.validator_src_address_.IsDefault()) {
    _impl_.validator_src_address_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.DVVTriplet.validator_src_address)
}

// string validator_dst_address = 3 [json_name = "validatorDstAddress", (.cosmos_proto.scalar) = "cosmos.ValidatorAddressString"];
inline void DVVTriplet::clear_validator_dst_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_dst_address_.ClearToEmpty();
}
inline const std::string& DVVTriplet::validator_dst_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.DVVTriplet.validator_dst_address)
  return _internal_validator_dst_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DVVTriplet::set_validator_dst_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_dst_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.DVVTriplet.validator_dst_address)
}
inline std::string* DVVTriplet::mutable_validator_dst_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_validator_dst_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.DVVTriplet.validator_dst_address)
  return _s;
}
inline const std::string& DVVTriplet::_internal_validator_dst_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.validator_dst_address_.Get();
}
inline void DVVTriplet::_internal_set_validator_dst_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_dst_address_.Set(value, GetArena());
}
inline std::string* DVVTriplet::_internal_mutable_validator_dst_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.validator_dst_address_.Mutable( GetArena());
}
inline std::string* DVVTriplet::release_validator_dst_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.DVVTriplet.validator_dst_address)
  return _impl_.validator_dst_address_.Release();
}
inline void DVVTriplet::set_allocated_validator_dst_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_dst_address_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.validator_dst_address_.IsDefault()) {
    _impl_.validator_dst_address_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.DVVTriplet.validator_dst_address)
}

// -------------------------------------------------------------------

// DVVTriplets

// repeated .cosmos.staking.v1beta1.DVVTriplet triplets = 1 [json_name = "triplets", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline int DVVTriplets::_internal_triplets_size() const {
  return _internal_triplets().size();
}
inline int DVVTriplets::triplets_size() const {
  return _internal_triplets_size();
}
inline void DVVTriplets::clear_triplets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.triplets_.Clear();
}
inline ::cosmos::staking::v1beta1::DVVTriplet* DVVTriplets::mutable_triplets(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.DVVTriplets.triplets)
  return _internal_mutable_triplets()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::DVVTriplet>* DVVTriplets::mutable_triplets()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cosmos.staking.v1beta1.DVVTriplets.triplets)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_triplets();
}
inline const ::cosmos::staking::v1beta1::DVVTriplet& DVVTriplets::triplets(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.DVVTriplets.triplets)
  return _internal_triplets().Get(index);
}
inline ::cosmos::staking::v1beta1::DVVTriplet* DVVTriplets::add_triplets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::cosmos::staking::v1beta1::DVVTriplet* _add = _internal_mutable_triplets()->Add();
  // @@protoc_insertion_point(field_add:cosmos.staking.v1beta1.DVVTriplets.triplets)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::DVVTriplet>& DVVTriplets::triplets() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cosmos.staking.v1beta1.DVVTriplets.triplets)
  return _internal_triplets();
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::DVVTriplet>&
DVVTriplets::_internal_triplets() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.triplets_;
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::DVVTriplet>*
DVVTriplets::_internal_mutable_triplets() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.triplets_;
}

// -------------------------------------------------------------------

// Delegation

// string delegator_address = 1 [json_name = "delegatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void Delegation::clear_delegator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_address_.ClearToEmpty();
}
inline const std::string& Delegation::delegator_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Delegation.delegator_address)
  return _internal_delegator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Delegation::set_delegator_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Delegation.delegator_address)
}
inline std::string* Delegation::mutable_delegator_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_delegator_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Delegation.delegator_address)
  return _s;
}
inline const std::string& Delegation::_internal_delegator_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.delegator_address_.Get();
}
inline void Delegation::_internal_set_delegator_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_address_.Set(value, GetArena());
}
inline std::string* Delegation::_internal_mutable_delegator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.delegator_address_.Mutable( GetArena());
}
inline std::string* Delegation::release_delegator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Delegation.delegator_address)
  return _impl_.delegator_address_.Release();
}
inline void Delegation::set_allocated_delegator_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_address_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.delegator_address_.IsDefault()) {
    _impl_.delegator_address_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Delegation.delegator_address)
}

// string validator_address = 2 [json_name = "validatorAddress", (.cosmos_proto.scalar) = "cosmos.ValidatorAddressString"];
inline void Delegation::clear_validator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_address_.ClearToEmpty();
}
inline const std::string& Delegation::validator_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Delegation.validator_address)
  return _internal_validator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Delegation::set_validator_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Delegation.validator_address)
}
inline std::string* Delegation::mutable_validator_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_validator_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Delegation.validator_address)
  return _s;
}
inline const std::string& Delegation::_internal_validator_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.validator_address_.Get();
}
inline void Delegation::_internal_set_validator_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_address_.Set(value, GetArena());
}
inline std::string* Delegation::_internal_mutable_validator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.validator_address_.Mutable( GetArena());
}
inline std::string* Delegation::release_validator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Delegation.validator_address)
  return _impl_.validator_address_.Release();
}
inline void Delegation::set_allocated_validator_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_address_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.validator_address_.IsDefault()) {
    _impl_.validator_address_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Delegation.validator_address)
}

// string shares = 3 [json_name = "shares", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.LegacyDec", (.cosmos_proto.scalar) = "cosmos.Dec"];
inline void Delegation::clear_shares() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shares_.ClearToEmpty();
}
inline const std::string& Delegation::shares() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Delegation.shares)
  return _internal_shares();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Delegation::set_shares(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shares_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Delegation.shares)
}
inline std::string* Delegation::mutable_shares() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_shares();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Delegation.shares)
  return _s;
}
inline const std::string& Delegation::_internal_shares() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shares_.Get();
}
inline void Delegation::_internal_set_shares(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shares_.Set(value, GetArena());
}
inline std::string* Delegation::_internal_mutable_shares() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.shares_.Mutable( GetArena());
}
inline std::string* Delegation::release_shares() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Delegation.shares)
  return _impl_.shares_.Release();
}
inline void Delegation::set_allocated_shares(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shares_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.shares_.IsDefault()) {
    _impl_.shares_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Delegation.shares)
}

// -------------------------------------------------------------------

// UnbondingDelegation

// string delegator_address = 1 [json_name = "delegatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void UnbondingDelegation::clear_delegator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_address_.ClearToEmpty();
}
inline const std::string& UnbondingDelegation::delegator_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.UnbondingDelegation.delegator_address)
  return _internal_delegator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UnbondingDelegation::set_delegator_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.UnbondingDelegation.delegator_address)
}
inline std::string* UnbondingDelegation::mutable_delegator_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_delegator_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.UnbondingDelegation.delegator_address)
  return _s;
}
inline const std::string& UnbondingDelegation::_internal_delegator_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.delegator_address_.Get();
}
inline void UnbondingDelegation::_internal_set_delegator_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_address_.Set(value, GetArena());
}
inline std::string* UnbondingDelegation::_internal_mutable_delegator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.delegator_address_.Mutable( GetArena());
}
inline std::string* UnbondingDelegation::release_delegator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.UnbondingDelegation.delegator_address)
  return _impl_.delegator_address_.Release();
}
inline void UnbondingDelegation::set_allocated_delegator_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_address_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.delegator_address_.IsDefault()) {
    _impl_.delegator_address_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.UnbondingDelegation.delegator_address)
}

// string validator_address = 2 [json_name = "validatorAddress", (.cosmos_proto.scalar) = "cosmos.ValidatorAddressString"];
inline void UnbondingDelegation::clear_validator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_address_.ClearToEmpty();
}
inline const std::string& UnbondingDelegation::validator_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.UnbondingDelegation.validator_address)
  return _internal_validator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UnbondingDelegation::set_validator_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.UnbondingDelegation.validator_address)
}
inline std::string* UnbondingDelegation::mutable_validator_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_validator_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.UnbondingDelegation.validator_address)
  return _s;
}
inline const std::string& UnbondingDelegation::_internal_validator_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.validator_address_.Get();
}
inline void UnbondingDelegation::_internal_set_validator_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_address_.Set(value, GetArena());
}
inline std::string* UnbondingDelegation::_internal_mutable_validator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.validator_address_.Mutable( GetArena());
}
inline std::string* UnbondingDelegation::release_validator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.UnbondingDelegation.validator_address)
  return _impl_.validator_address_.Release();
}
inline void UnbondingDelegation::set_allocated_validator_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_address_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.validator_address_.IsDefault()) {
    _impl_.validator_address_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.UnbondingDelegation.validator_address)
}

// repeated .cosmos.staking.v1beta1.UnbondingDelegationEntry entries = 3 [json_name = "entries", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline int UnbondingDelegation::_internal_entries_size() const {
  return _internal_entries().size();
}
inline int UnbondingDelegation::entries_size() const {
  return _internal_entries_size();
}
inline void UnbondingDelegation::clear_entries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entries_.Clear();
}
inline ::cosmos::staking::v1beta1::UnbondingDelegationEntry* UnbondingDelegation::mutable_entries(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.UnbondingDelegation.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::UnbondingDelegationEntry>* UnbondingDelegation::mutable_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cosmos.staking.v1beta1.UnbondingDelegation.entries)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entries();
}
inline const ::cosmos::staking::v1beta1::UnbondingDelegationEntry& UnbondingDelegation::entries(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.UnbondingDelegation.entries)
  return _internal_entries().Get(index);
}
inline ::cosmos::staking::v1beta1::UnbondingDelegationEntry* UnbondingDelegation::add_entries() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::cosmos::staking::v1beta1::UnbondingDelegationEntry* _add = _internal_mutable_entries()->Add();
  // @@protoc_insertion_point(field_add:cosmos.staking.v1beta1.UnbondingDelegation.entries)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::UnbondingDelegationEntry>& UnbondingDelegation::entries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cosmos.staking.v1beta1.UnbondingDelegation.entries)
  return _internal_entries();
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::UnbondingDelegationEntry>&
UnbondingDelegation::_internal_entries() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entries_;
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::UnbondingDelegationEntry>*
UnbondingDelegation::_internal_mutable_entries() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entries_;
}

// -------------------------------------------------------------------

// UnbondingDelegationEntry

// int64 creation_height = 1 [json_name = "creationHeight"];
inline void UnbondingDelegationEntry::clear_creation_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_height_ = ::int64_t{0};
}
inline ::int64_t UnbondingDelegationEntry::creation_height() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.UnbondingDelegationEntry.creation_height)
  return _internal_creation_height();
}
inline void UnbondingDelegationEntry::set_creation_height(::int64_t value) {
  _internal_set_creation_height(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.UnbondingDelegationEntry.creation_height)
}
inline ::int64_t UnbondingDelegationEntry::_internal_creation_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.creation_height_;
}
inline void UnbondingDelegationEntry::_internal_set_creation_height(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_height_ = value;
}

// .google.protobuf.Timestamp completion_time = 2 [json_name = "completionTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true, (.amino.dont_omitempty) = true];
inline bool UnbondingDelegationEntry::has_completion_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.completion_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& UnbondingDelegationEntry::_internal_completion_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.completion_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& UnbondingDelegationEntry::completion_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.UnbondingDelegationEntry.completion_time)
  return _internal_completion_time();
}
inline void UnbondingDelegationEntry::unsafe_arena_set_allocated_completion_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.completion_time_);
  }
  _impl_.completion_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.UnbondingDelegationEntry.completion_time)
}
inline ::google::protobuf::Timestamp* UnbondingDelegationEntry::release_completion_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.completion_time_;
  _impl_.completion_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* UnbondingDelegationEntry::unsafe_arena_release_completion_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.UnbondingDelegationEntry.completion_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.completion_time_;
  _impl_.completion_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* UnbondingDelegationEntry::_internal_mutable_completion_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.completion_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.completion_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.completion_time_;
}
inline ::google::protobuf::Timestamp* UnbondingDelegationEntry::mutable_completion_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_completion_time();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.UnbondingDelegationEntry.completion_time)
  return _msg;
}
inline void UnbondingDelegationEntry::set_allocated_completion_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.completion_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.completion_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.UnbondingDelegationEntry.completion_time)
}

// string initial_balance = 3 [json_name = "initialBalance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.Int", (.cosmos_proto.scalar) = "cosmos.Int"];
inline void UnbondingDelegationEntry::clear_initial_balance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initial_balance_.ClearToEmpty();
}
inline const std::string& UnbondingDelegationEntry::initial_balance() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.UnbondingDelegationEntry.initial_balance)
  return _internal_initial_balance();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UnbondingDelegationEntry::set_initial_balance(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initial_balance_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.UnbondingDelegationEntry.initial_balance)
}
inline std::string* UnbondingDelegationEntry::mutable_initial_balance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_initial_balance();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.UnbondingDelegationEntry.initial_balance)
  return _s;
}
inline const std::string& UnbondingDelegationEntry::_internal_initial_balance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.initial_balance_.Get();
}
inline void UnbondingDelegationEntry::_internal_set_initial_balance(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initial_balance_.Set(value, GetArena());
}
inline std::string* UnbondingDelegationEntry::_internal_mutable_initial_balance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.initial_balance_.Mutable( GetArena());
}
inline std::string* UnbondingDelegationEntry::release_initial_balance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.UnbondingDelegationEntry.initial_balance)
  return _impl_.initial_balance_.Release();
}
inline void UnbondingDelegationEntry::set_allocated_initial_balance(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initial_balance_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.initial_balance_.IsDefault()) {
    _impl_.initial_balance_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.UnbondingDelegationEntry.initial_balance)
}

// string balance = 4 [json_name = "balance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.Int", (.cosmos_proto.scalar) = "cosmos.Int"];
inline void UnbondingDelegationEntry::clear_balance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.balance_.ClearToEmpty();
}
inline const std::string& UnbondingDelegationEntry::balance() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.UnbondingDelegationEntry.balance)
  return _internal_balance();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UnbondingDelegationEntry::set_balance(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.balance_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.UnbondingDelegationEntry.balance)
}
inline std::string* UnbondingDelegationEntry::mutable_balance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_balance();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.UnbondingDelegationEntry.balance)
  return _s;
}
inline const std::string& UnbondingDelegationEntry::_internal_balance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.balance_.Get();
}
inline void UnbondingDelegationEntry::_internal_set_balance(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.balance_.Set(value, GetArena());
}
inline std::string* UnbondingDelegationEntry::_internal_mutable_balance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.balance_.Mutable( GetArena());
}
inline std::string* UnbondingDelegationEntry::release_balance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.UnbondingDelegationEntry.balance)
  return _impl_.balance_.Release();
}
inline void UnbondingDelegationEntry::set_allocated_balance(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.balance_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.balance_.IsDefault()) {
    _impl_.balance_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.UnbondingDelegationEntry.balance)
}

// uint64 unbonding_id = 5 [json_name = "unbondingId"];
inline void UnbondingDelegationEntry::clear_unbonding_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unbonding_id_ = ::uint64_t{0u};
}
inline ::uint64_t UnbondingDelegationEntry::unbonding_id() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.UnbondingDelegationEntry.unbonding_id)
  return _internal_unbonding_id();
}
inline void UnbondingDelegationEntry::set_unbonding_id(::uint64_t value) {
  _internal_set_unbonding_id(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.UnbondingDelegationEntry.unbonding_id)
}
inline ::uint64_t UnbondingDelegationEntry::_internal_unbonding_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unbonding_id_;
}
inline void UnbondingDelegationEntry::_internal_set_unbonding_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unbonding_id_ = value;
}

// int64 unbonding_on_hold_ref_count = 6 [json_name = "unbondingOnHoldRefCount"];
inline void UnbondingDelegationEntry::clear_unbonding_on_hold_ref_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unbonding_on_hold_ref_count_ = ::int64_t{0};
}
inline ::int64_t UnbondingDelegationEntry::unbonding_on_hold_ref_count() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.UnbondingDelegationEntry.unbonding_on_hold_ref_count)
  return _internal_unbonding_on_hold_ref_count();
}
inline void UnbondingDelegationEntry::set_unbonding_on_hold_ref_count(::int64_t value) {
  _internal_set_unbonding_on_hold_ref_count(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.UnbondingDelegationEntry.unbonding_on_hold_ref_count)
}
inline ::int64_t UnbondingDelegationEntry::_internal_unbonding_on_hold_ref_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unbonding_on_hold_ref_count_;
}
inline void UnbondingDelegationEntry::_internal_set_unbonding_on_hold_ref_count(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unbonding_on_hold_ref_count_ = value;
}

// -------------------------------------------------------------------

// RedelegationEntry

// int64 creation_height = 1 [json_name = "creationHeight"];
inline void RedelegationEntry::clear_creation_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_height_ = ::int64_t{0};
}
inline ::int64_t RedelegationEntry::creation_height() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.RedelegationEntry.creation_height)
  return _internal_creation_height();
}
inline void RedelegationEntry::set_creation_height(::int64_t value) {
  _internal_set_creation_height(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.RedelegationEntry.creation_height)
}
inline ::int64_t RedelegationEntry::_internal_creation_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.creation_height_;
}
inline void RedelegationEntry::_internal_set_creation_height(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.creation_height_ = value;
}

// .google.protobuf.Timestamp completion_time = 2 [json_name = "completionTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true, (.amino.dont_omitempty) = true];
inline bool RedelegationEntry::has_completion_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.completion_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& RedelegationEntry::_internal_completion_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.completion_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& RedelegationEntry::completion_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.RedelegationEntry.completion_time)
  return _internal_completion_time();
}
inline void RedelegationEntry::unsafe_arena_set_allocated_completion_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.completion_time_);
  }
  _impl_.completion_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.RedelegationEntry.completion_time)
}
inline ::google::protobuf::Timestamp* RedelegationEntry::release_completion_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.completion_time_;
  _impl_.completion_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* RedelegationEntry::unsafe_arena_release_completion_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.RedelegationEntry.completion_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.completion_time_;
  _impl_.completion_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* RedelegationEntry::_internal_mutable_completion_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.completion_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.completion_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.completion_time_;
}
inline ::google::protobuf::Timestamp* RedelegationEntry::mutable_completion_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_completion_time();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.RedelegationEntry.completion_time)
  return _msg;
}
inline void RedelegationEntry::set_allocated_completion_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.completion_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.completion_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.RedelegationEntry.completion_time)
}

// string initial_balance = 3 [json_name = "initialBalance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.Int", (.cosmos_proto.scalar) = "cosmos.Int"];
inline void RedelegationEntry::clear_initial_balance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initial_balance_.ClearToEmpty();
}
inline const std::string& RedelegationEntry::initial_balance() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.RedelegationEntry.initial_balance)
  return _internal_initial_balance();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RedelegationEntry::set_initial_balance(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initial_balance_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.RedelegationEntry.initial_balance)
}
inline std::string* RedelegationEntry::mutable_initial_balance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_initial_balance();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.RedelegationEntry.initial_balance)
  return _s;
}
inline const std::string& RedelegationEntry::_internal_initial_balance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.initial_balance_.Get();
}
inline void RedelegationEntry::_internal_set_initial_balance(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initial_balance_.Set(value, GetArena());
}
inline std::string* RedelegationEntry::_internal_mutable_initial_balance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.initial_balance_.Mutable( GetArena());
}
inline std::string* RedelegationEntry::release_initial_balance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.RedelegationEntry.initial_balance)
  return _impl_.initial_balance_.Release();
}
inline void RedelegationEntry::set_allocated_initial_balance(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.initial_balance_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.initial_balance_.IsDefault()) {
    _impl_.initial_balance_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.RedelegationEntry.initial_balance)
}

// string shares_dst = 4 [json_name = "sharesDst", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.LegacyDec", (.cosmos_proto.scalar) = "cosmos.Dec"];
inline void RedelegationEntry::clear_shares_dst() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shares_dst_.ClearToEmpty();
}
inline const std::string& RedelegationEntry::shares_dst() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.RedelegationEntry.shares_dst)
  return _internal_shares_dst();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RedelegationEntry::set_shares_dst(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shares_dst_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.RedelegationEntry.shares_dst)
}
inline std::string* RedelegationEntry::mutable_shares_dst() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_shares_dst();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.RedelegationEntry.shares_dst)
  return _s;
}
inline const std::string& RedelegationEntry::_internal_shares_dst() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shares_dst_.Get();
}
inline void RedelegationEntry::_internal_set_shares_dst(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shares_dst_.Set(value, GetArena());
}
inline std::string* RedelegationEntry::_internal_mutable_shares_dst() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.shares_dst_.Mutable( GetArena());
}
inline std::string* RedelegationEntry::release_shares_dst() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.RedelegationEntry.shares_dst)
  return _impl_.shares_dst_.Release();
}
inline void RedelegationEntry::set_allocated_shares_dst(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shares_dst_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.shares_dst_.IsDefault()) {
    _impl_.shares_dst_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.RedelegationEntry.shares_dst)
}

// uint64 unbonding_id = 5 [json_name = "unbondingId"];
inline void RedelegationEntry::clear_unbonding_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unbonding_id_ = ::uint64_t{0u};
}
inline ::uint64_t RedelegationEntry::unbonding_id() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.RedelegationEntry.unbonding_id)
  return _internal_unbonding_id();
}
inline void RedelegationEntry::set_unbonding_id(::uint64_t value) {
  _internal_set_unbonding_id(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.RedelegationEntry.unbonding_id)
}
inline ::uint64_t RedelegationEntry::_internal_unbonding_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unbonding_id_;
}
inline void RedelegationEntry::_internal_set_unbonding_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unbonding_id_ = value;
}

// int64 unbonding_on_hold_ref_count = 6 [json_name = "unbondingOnHoldRefCount"];
inline void RedelegationEntry::clear_unbonding_on_hold_ref_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unbonding_on_hold_ref_count_ = ::int64_t{0};
}
inline ::int64_t RedelegationEntry::unbonding_on_hold_ref_count() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.RedelegationEntry.unbonding_on_hold_ref_count)
  return _internal_unbonding_on_hold_ref_count();
}
inline void RedelegationEntry::set_unbonding_on_hold_ref_count(::int64_t value) {
  _internal_set_unbonding_on_hold_ref_count(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.RedelegationEntry.unbonding_on_hold_ref_count)
}
inline ::int64_t RedelegationEntry::_internal_unbonding_on_hold_ref_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unbonding_on_hold_ref_count_;
}
inline void RedelegationEntry::_internal_set_unbonding_on_hold_ref_count(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unbonding_on_hold_ref_count_ = value;
}

// -------------------------------------------------------------------

// Redelegation

// string delegator_address = 1 [json_name = "delegatorAddress", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void Redelegation::clear_delegator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_address_.ClearToEmpty();
}
inline const std::string& Redelegation::delegator_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Redelegation.delegator_address)
  return _internal_delegator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Redelegation::set_delegator_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Redelegation.delegator_address)
}
inline std::string* Redelegation::mutable_delegator_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_delegator_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Redelegation.delegator_address)
  return _s;
}
inline const std::string& Redelegation::_internal_delegator_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.delegator_address_.Get();
}
inline void Redelegation::_internal_set_delegator_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_address_.Set(value, GetArena());
}
inline std::string* Redelegation::_internal_mutable_delegator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.delegator_address_.Mutable( GetArena());
}
inline std::string* Redelegation::release_delegator_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Redelegation.delegator_address)
  return _impl_.delegator_address_.Release();
}
inline void Redelegation::set_allocated_delegator_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delegator_address_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.delegator_address_.IsDefault()) {
    _impl_.delegator_address_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Redelegation.delegator_address)
}

// string validator_src_address = 2 [json_name = "validatorSrcAddress", (.cosmos_proto.scalar) = "cosmos.ValidatorAddressString"];
inline void Redelegation::clear_validator_src_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_src_address_.ClearToEmpty();
}
inline const std::string& Redelegation::validator_src_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Redelegation.validator_src_address)
  return _internal_validator_src_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Redelegation::set_validator_src_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_src_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Redelegation.validator_src_address)
}
inline std::string* Redelegation::mutable_validator_src_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_validator_src_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Redelegation.validator_src_address)
  return _s;
}
inline const std::string& Redelegation::_internal_validator_src_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.validator_src_address_.Get();
}
inline void Redelegation::_internal_set_validator_src_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_src_address_.Set(value, GetArena());
}
inline std::string* Redelegation::_internal_mutable_validator_src_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.validator_src_address_.Mutable( GetArena());
}
inline std::string* Redelegation::release_validator_src_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Redelegation.validator_src_address)
  return _impl_.validator_src_address_.Release();
}
inline void Redelegation::set_allocated_validator_src_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_src_address_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.validator_src_address_.IsDefault()) {
    _impl_.validator_src_address_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Redelegation.validator_src_address)
}

// string validator_dst_address = 3 [json_name = "validatorDstAddress", (.cosmos_proto.scalar) = "cosmos.ValidatorAddressString"];
inline void Redelegation::clear_validator_dst_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_dst_address_.ClearToEmpty();
}
inline const std::string& Redelegation::validator_dst_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Redelegation.validator_dst_address)
  return _internal_validator_dst_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Redelegation::set_validator_dst_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_dst_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Redelegation.validator_dst_address)
}
inline std::string* Redelegation::mutable_validator_dst_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_validator_dst_address();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Redelegation.validator_dst_address)
  return _s;
}
inline const std::string& Redelegation::_internal_validator_dst_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.validator_dst_address_.Get();
}
inline void Redelegation::_internal_set_validator_dst_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_dst_address_.Set(value, GetArena());
}
inline std::string* Redelegation::_internal_mutable_validator_dst_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.validator_dst_address_.Mutable( GetArena());
}
inline std::string* Redelegation::release_validator_dst_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Redelegation.validator_dst_address)
  return _impl_.validator_dst_address_.Release();
}
inline void Redelegation::set_allocated_validator_dst_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.validator_dst_address_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.validator_dst_address_.IsDefault()) {
    _impl_.validator_dst_address_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Redelegation.validator_dst_address)
}

// repeated .cosmos.staking.v1beta1.RedelegationEntry entries = 4 [json_name = "entries", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline int Redelegation::_internal_entries_size() const {
  return _internal_entries().size();
}
inline int Redelegation::entries_size() const {
  return _internal_entries_size();
}
inline void Redelegation::clear_entries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entries_.Clear();
}
inline ::cosmos::staking::v1beta1::RedelegationEntry* Redelegation::mutable_entries(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Redelegation.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntry>* Redelegation::mutable_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cosmos.staking.v1beta1.Redelegation.entries)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entries();
}
inline const ::cosmos::staking::v1beta1::RedelegationEntry& Redelegation::entries(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Redelegation.entries)
  return _internal_entries().Get(index);
}
inline ::cosmos::staking::v1beta1::RedelegationEntry* Redelegation::add_entries() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::cosmos::staking::v1beta1::RedelegationEntry* _add = _internal_mutable_entries()->Add();
  // @@protoc_insertion_point(field_add:cosmos.staking.v1beta1.Redelegation.entries)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntry>& Redelegation::entries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cosmos.staking.v1beta1.Redelegation.entries)
  return _internal_entries();
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntry>&
Redelegation::_internal_entries() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entries_;
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntry>*
Redelegation::_internal_mutable_entries() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entries_;
}

// -------------------------------------------------------------------

// Params

// .google.protobuf.Duration unbonding_time = 1 [json_name = "unbondingTime", (.gogoproto.nullable) = false, (.gogoproto.stdduration) = true, (.amino.dont_omitempty) = true];
inline bool Params::has_unbonding_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unbonding_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& Params::_internal_unbonding_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Duration* p = _impl_.unbonding_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& Params::unbonding_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Params.unbonding_time)
  return _internal_unbonding_time();
}
inline void Params::unsafe_arena_set_allocated_unbonding_time(::google::protobuf::Duration* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.unbonding_time_);
  }
  _impl_.unbonding_time_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.Params.unbonding_time)
}
inline ::google::protobuf::Duration* Params::release_unbonding_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* released = _impl_.unbonding_time_;
  _impl_.unbonding_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Duration* Params::unsafe_arena_release_unbonding_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Params.unbonding_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* temp = _impl_.unbonding_time_;
  _impl_.unbonding_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* Params::_internal_mutable_unbonding_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.unbonding_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.unbonding_time_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.unbonding_time_;
}
inline ::google::protobuf::Duration* Params::mutable_unbonding_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Duration* _msg = _internal_mutable_unbonding_time();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Params.unbonding_time)
  return _msg;
}
inline void Params::set_allocated_unbonding_time(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.unbonding_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.unbonding_time_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Params.unbonding_time)
}

// uint32 max_validators = 2 [json_name = "maxValidators"];
inline void Params::clear_max_validators() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_validators_ = 0u;
}
inline ::uint32_t Params::max_validators() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Params.max_validators)
  return _internal_max_validators();
}
inline void Params::set_max_validators(::uint32_t value) {
  _internal_set_max_validators(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Params.max_validators)
}
inline ::uint32_t Params::_internal_max_validators() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_validators_;
}
inline void Params::_internal_set_max_validators(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_validators_ = value;
}

// uint32 max_entries = 3 [json_name = "maxEntries"];
inline void Params::clear_max_entries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_entries_ = 0u;
}
inline ::uint32_t Params::max_entries() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Params.max_entries)
  return _internal_max_entries();
}
inline void Params::set_max_entries(::uint32_t value) {
  _internal_set_max_entries(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Params.max_entries)
}
inline ::uint32_t Params::_internal_max_entries() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_entries_;
}
inline void Params::_internal_set_max_entries(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_entries_ = value;
}

// uint32 historical_entries = 4 [json_name = "historicalEntries"];
inline void Params::clear_historical_entries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.historical_entries_ = 0u;
}
inline ::uint32_t Params::historical_entries() const {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Params.historical_entries)
  return _internal_historical_entries();
}
inline void Params::set_historical_entries(::uint32_t value) {
  _internal_set_historical_entries(value);
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Params.historical_entries)
}
inline ::uint32_t Params::_internal_historical_entries() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.historical_entries_;
}
inline void Params::_internal_set_historical_entries(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.historical_entries_ = value;
}

// string bond_denom = 5 [json_name = "bondDenom"];
inline void Params::clear_bond_denom() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bond_denom_.ClearToEmpty();
}
inline const std::string& Params::bond_denom() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Params.bond_denom)
  return _internal_bond_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_bond_denom(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bond_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Params.bond_denom)
}
inline std::string* Params::mutable_bond_denom() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bond_denom();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Params.bond_denom)
  return _s;
}
inline const std::string& Params::_internal_bond_denom() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bond_denom_.Get();
}
inline void Params::_internal_set_bond_denom(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bond_denom_.Set(value, GetArena());
}
inline std::string* Params::_internal_mutable_bond_denom() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.bond_denom_.Mutable( GetArena());
}
inline std::string* Params::release_bond_denom() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Params.bond_denom)
  return _impl_.bond_denom_.Release();
}
inline void Params::set_allocated_bond_denom(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bond_denom_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.bond_denom_.IsDefault()) {
    _impl_.bond_denom_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Params.bond_denom)
}

// string min_commission_rate = 6 [json_name = "minCommissionRate", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.LegacyDec", (.gogoproto.moretags) = "yaml:\"min_commission_rate\"", (.cosmos_proto.scalar) = "cosmos.Dec", (.amino.dont_omitempty) = true];
inline void Params::clear_min_commission_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_commission_rate_.ClearToEmpty();
}
inline const std::string& Params::min_commission_rate() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Params.min_commission_rate)
  return _internal_min_commission_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Params::set_min_commission_rate(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_commission_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Params.min_commission_rate)
}
inline std::string* Params::mutable_min_commission_rate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_min_commission_rate();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Params.min_commission_rate)
  return _s;
}
inline const std::string& Params::_internal_min_commission_rate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_commission_rate_.Get();
}
inline void Params::_internal_set_min_commission_rate(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_commission_rate_.Set(value, GetArena());
}
inline std::string* Params::_internal_mutable_min_commission_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.min_commission_rate_.Mutable( GetArena());
}
inline std::string* Params::release_min_commission_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Params.min_commission_rate)
  return _impl_.min_commission_rate_.Release();
}
inline void Params::set_allocated_min_commission_rate(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_commission_rate_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.min_commission_rate_.IsDefault()) {
    _impl_.min_commission_rate_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Params.min_commission_rate)
}

// -------------------------------------------------------------------

// DelegationResponse

// .cosmos.staking.v1beta1.Delegation delegation = 1 [json_name = "delegation", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline bool DelegationResponse::has_delegation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.delegation_ != nullptr);
  return value;
}
inline void DelegationResponse::clear_delegation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.delegation_ != nullptr) _impl_.delegation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cosmos::staking::v1beta1::Delegation& DelegationResponse::_internal_delegation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::cosmos::staking::v1beta1::Delegation* p = _impl_.delegation_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::staking::v1beta1::Delegation&>(::cosmos::staking::v1beta1::_Delegation_default_instance_);
}
inline const ::cosmos::staking::v1beta1::Delegation& DelegationResponse::delegation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.DelegationResponse.delegation)
  return _internal_delegation();
}
inline void DelegationResponse::unsafe_arena_set_allocated_delegation(::cosmos::staking::v1beta1::Delegation* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.delegation_);
  }
  _impl_.delegation_ = reinterpret_cast<::cosmos::staking::v1beta1::Delegation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.DelegationResponse.delegation)
}
inline ::cosmos::staking::v1beta1::Delegation* DelegationResponse::release_delegation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::staking::v1beta1::Delegation* released = _impl_.delegation_;
  _impl_.delegation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::cosmos::staking::v1beta1::Delegation* DelegationResponse::unsafe_arena_release_delegation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.DelegationResponse.delegation)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::staking::v1beta1::Delegation* temp = _impl_.delegation_;
  _impl_.delegation_ = nullptr;
  return temp;
}
inline ::cosmos::staking::v1beta1::Delegation* DelegationResponse::_internal_mutable_delegation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.delegation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::cosmos::staking::v1beta1::Delegation>(GetArena());
    _impl_.delegation_ = reinterpret_cast<::cosmos::staking::v1beta1::Delegation*>(p);
  }
  return _impl_.delegation_;
}
inline ::cosmos::staking::v1beta1::Delegation* DelegationResponse::mutable_delegation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::cosmos::staking::v1beta1::Delegation* _msg = _internal_mutable_delegation();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.DelegationResponse.delegation)
  return _msg;
}
inline void DelegationResponse::set_allocated_delegation(::cosmos::staking::v1beta1::Delegation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.delegation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.delegation_ = reinterpret_cast<::cosmos::staking::v1beta1::Delegation*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.DelegationResponse.delegation)
}

// .cosmos.base.v1beta1.Coin balance = 2 [json_name = "balance", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline bool DelegationResponse::has_balance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.balance_ != nullptr);
  return value;
}
inline const ::cosmos::base::v1beta1::Coin& DelegationResponse::_internal_balance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::cosmos::base::v1beta1::Coin* p = _impl_.balance_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::base::v1beta1::Coin&>(::cosmos::base::v1beta1::_Coin_default_instance_);
}
inline const ::cosmos::base::v1beta1::Coin& DelegationResponse::balance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.DelegationResponse.balance)
  return _internal_balance();
}
inline void DelegationResponse::unsafe_arena_set_allocated_balance(::cosmos::base::v1beta1::Coin* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.balance_);
  }
  _impl_.balance_ = reinterpret_cast<::cosmos::base::v1beta1::Coin*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.DelegationResponse.balance)
}
inline ::cosmos::base::v1beta1::Coin* DelegationResponse::release_balance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::base::v1beta1::Coin* released = _impl_.balance_;
  _impl_.balance_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::cosmos::base::v1beta1::Coin* DelegationResponse::unsafe_arena_release_balance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.DelegationResponse.balance)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::base::v1beta1::Coin* temp = _impl_.balance_;
  _impl_.balance_ = nullptr;
  return temp;
}
inline ::cosmos::base::v1beta1::Coin* DelegationResponse::_internal_mutable_balance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.balance_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::cosmos::base::v1beta1::Coin>(GetArena());
    _impl_.balance_ = reinterpret_cast<::cosmos::base::v1beta1::Coin*>(p);
  }
  return _impl_.balance_;
}
inline ::cosmos::base::v1beta1::Coin* DelegationResponse::mutable_balance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::cosmos::base::v1beta1::Coin* _msg = _internal_mutable_balance();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.DelegationResponse.balance)
  return _msg;
}
inline void DelegationResponse::set_allocated_balance(::cosmos::base::v1beta1::Coin* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.balance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.balance_ = reinterpret_cast<::cosmos::base::v1beta1::Coin*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.DelegationResponse.balance)
}

// -------------------------------------------------------------------

// RedelegationEntryResponse

// .cosmos.staking.v1beta1.RedelegationEntry redelegation_entry = 1 [json_name = "redelegationEntry", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline bool RedelegationEntryResponse::has_redelegation_entry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.redelegation_entry_ != nullptr);
  return value;
}
inline void RedelegationEntryResponse::clear_redelegation_entry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.redelegation_entry_ != nullptr) _impl_.redelegation_entry_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cosmos::staking::v1beta1::RedelegationEntry& RedelegationEntryResponse::_internal_redelegation_entry() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::cosmos::staking::v1beta1::RedelegationEntry* p = _impl_.redelegation_entry_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::staking::v1beta1::RedelegationEntry&>(::cosmos::staking::v1beta1::_RedelegationEntry_default_instance_);
}
inline const ::cosmos::staking::v1beta1::RedelegationEntry& RedelegationEntryResponse::redelegation_entry() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.RedelegationEntryResponse.redelegation_entry)
  return _internal_redelegation_entry();
}
inline void RedelegationEntryResponse::unsafe_arena_set_allocated_redelegation_entry(::cosmos::staking::v1beta1::RedelegationEntry* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.redelegation_entry_);
  }
  _impl_.redelegation_entry_ = reinterpret_cast<::cosmos::staking::v1beta1::RedelegationEntry*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.RedelegationEntryResponse.redelegation_entry)
}
inline ::cosmos::staking::v1beta1::RedelegationEntry* RedelegationEntryResponse::release_redelegation_entry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::staking::v1beta1::RedelegationEntry* released = _impl_.redelegation_entry_;
  _impl_.redelegation_entry_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::cosmos::staking::v1beta1::RedelegationEntry* RedelegationEntryResponse::unsafe_arena_release_redelegation_entry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.RedelegationEntryResponse.redelegation_entry)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::staking::v1beta1::RedelegationEntry* temp = _impl_.redelegation_entry_;
  _impl_.redelegation_entry_ = nullptr;
  return temp;
}
inline ::cosmos::staking::v1beta1::RedelegationEntry* RedelegationEntryResponse::_internal_mutable_redelegation_entry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.redelegation_entry_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::cosmos::staking::v1beta1::RedelegationEntry>(GetArena());
    _impl_.redelegation_entry_ = reinterpret_cast<::cosmos::staking::v1beta1::RedelegationEntry*>(p);
  }
  return _impl_.redelegation_entry_;
}
inline ::cosmos::staking::v1beta1::RedelegationEntry* RedelegationEntryResponse::mutable_redelegation_entry() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::cosmos::staking::v1beta1::RedelegationEntry* _msg = _internal_mutable_redelegation_entry();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.RedelegationEntryResponse.redelegation_entry)
  return _msg;
}
inline void RedelegationEntryResponse::set_allocated_redelegation_entry(::cosmos::staking::v1beta1::RedelegationEntry* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.redelegation_entry_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.redelegation_entry_ = reinterpret_cast<::cosmos::staking::v1beta1::RedelegationEntry*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.RedelegationEntryResponse.redelegation_entry)
}

// string balance = 4 [json_name = "balance", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.Int", (.cosmos_proto.scalar) = "cosmos.Int"];
inline void RedelegationEntryResponse::clear_balance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.balance_.ClearToEmpty();
}
inline const std::string& RedelegationEntryResponse::balance() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.RedelegationEntryResponse.balance)
  return _internal_balance();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RedelegationEntryResponse::set_balance(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.balance_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.RedelegationEntryResponse.balance)
}
inline std::string* RedelegationEntryResponse::mutable_balance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_balance();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.RedelegationEntryResponse.balance)
  return _s;
}
inline const std::string& RedelegationEntryResponse::_internal_balance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.balance_.Get();
}
inline void RedelegationEntryResponse::_internal_set_balance(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.balance_.Set(value, GetArena());
}
inline std::string* RedelegationEntryResponse::_internal_mutable_balance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.balance_.Mutable( GetArena());
}
inline std::string* RedelegationEntryResponse::release_balance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.RedelegationEntryResponse.balance)
  return _impl_.balance_.Release();
}
inline void RedelegationEntryResponse::set_allocated_balance(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.balance_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.balance_.IsDefault()) {
    _impl_.balance_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.RedelegationEntryResponse.balance)
}

// -------------------------------------------------------------------

// RedelegationResponse

// .cosmos.staking.v1beta1.Redelegation redelegation = 1 [json_name = "redelegation", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline bool RedelegationResponse::has_redelegation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.redelegation_ != nullptr);
  return value;
}
inline void RedelegationResponse::clear_redelegation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.redelegation_ != nullptr) _impl_.redelegation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cosmos::staking::v1beta1::Redelegation& RedelegationResponse::_internal_redelegation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::cosmos::staking::v1beta1::Redelegation* p = _impl_.redelegation_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::staking::v1beta1::Redelegation&>(::cosmos::staking::v1beta1::_Redelegation_default_instance_);
}
inline const ::cosmos::staking::v1beta1::Redelegation& RedelegationResponse::redelegation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.RedelegationResponse.redelegation)
  return _internal_redelegation();
}
inline void RedelegationResponse::unsafe_arena_set_allocated_redelegation(::cosmos::staking::v1beta1::Redelegation* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.redelegation_);
  }
  _impl_.redelegation_ = reinterpret_cast<::cosmos::staking::v1beta1::Redelegation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.staking.v1beta1.RedelegationResponse.redelegation)
}
inline ::cosmos::staking::v1beta1::Redelegation* RedelegationResponse::release_redelegation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::staking::v1beta1::Redelegation* released = _impl_.redelegation_;
  _impl_.redelegation_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::cosmos::staking::v1beta1::Redelegation* RedelegationResponse::unsafe_arena_release_redelegation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.RedelegationResponse.redelegation)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::staking::v1beta1::Redelegation* temp = _impl_.redelegation_;
  _impl_.redelegation_ = nullptr;
  return temp;
}
inline ::cosmos::staking::v1beta1::Redelegation* RedelegationResponse::_internal_mutable_redelegation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.redelegation_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::cosmos::staking::v1beta1::Redelegation>(GetArena());
    _impl_.redelegation_ = reinterpret_cast<::cosmos::staking::v1beta1::Redelegation*>(p);
  }
  return _impl_.redelegation_;
}
inline ::cosmos::staking::v1beta1::Redelegation* RedelegationResponse::mutable_redelegation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::cosmos::staking::v1beta1::Redelegation* _msg = _internal_mutable_redelegation();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.RedelegationResponse.redelegation)
  return _msg;
}
inline void RedelegationResponse::set_allocated_redelegation(::cosmos::staking::v1beta1::Redelegation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.redelegation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.redelegation_ = reinterpret_cast<::cosmos::staking::v1beta1::Redelegation*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.RedelegationResponse.redelegation)
}

// repeated .cosmos.staking.v1beta1.RedelegationEntryResponse entries = 2 [json_name = "entries", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline int RedelegationResponse::_internal_entries_size() const {
  return _internal_entries().size();
}
inline int RedelegationResponse::entries_size() const {
  return _internal_entries_size();
}
inline void RedelegationResponse::clear_entries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entries_.Clear();
}
inline ::cosmos::staking::v1beta1::RedelegationEntryResponse* RedelegationResponse::mutable_entries(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.RedelegationResponse.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntryResponse>* RedelegationResponse::mutable_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cosmos.staking.v1beta1.RedelegationResponse.entries)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entries();
}
inline const ::cosmos::staking::v1beta1::RedelegationEntryResponse& RedelegationResponse::entries(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.RedelegationResponse.entries)
  return _internal_entries().Get(index);
}
inline ::cosmos::staking::v1beta1::RedelegationEntryResponse* RedelegationResponse::add_entries() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::cosmos::staking::v1beta1::RedelegationEntryResponse* _add = _internal_mutable_entries()->Add();
  // @@protoc_insertion_point(field_add:cosmos.staking.v1beta1.RedelegationResponse.entries)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntryResponse>& RedelegationResponse::entries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cosmos.staking.v1beta1.RedelegationResponse.entries)
  return _internal_entries();
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntryResponse>&
RedelegationResponse::_internal_entries() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entries_;
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::staking::v1beta1::RedelegationEntryResponse>*
RedelegationResponse::_internal_mutable_entries() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entries_;
}

// -------------------------------------------------------------------

// Pool

// string not_bonded_tokens = 1 [json_name = "notBondedTokens", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.Int", (.gogoproto.jsontag) = "not_bonded_tokens", (.cosmos_proto.scalar) = "cosmos.Int", (.amino.dont_omitempty) = true];
inline void Pool::clear_not_bonded_tokens() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_bonded_tokens_.ClearToEmpty();
}
inline const std::string& Pool::not_bonded_tokens() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Pool.not_bonded_tokens)
  return _internal_not_bonded_tokens();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Pool::set_not_bonded_tokens(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_bonded_tokens_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Pool.not_bonded_tokens)
}
inline std::string* Pool::mutable_not_bonded_tokens() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_not_bonded_tokens();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Pool.not_bonded_tokens)
  return _s;
}
inline const std::string& Pool::_internal_not_bonded_tokens() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.not_bonded_tokens_.Get();
}
inline void Pool::_internal_set_not_bonded_tokens(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_bonded_tokens_.Set(value, GetArena());
}
inline std::string* Pool::_internal_mutable_not_bonded_tokens() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.not_bonded_tokens_.Mutable( GetArena());
}
inline std::string* Pool::release_not_bonded_tokens() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Pool.not_bonded_tokens)
  return _impl_.not_bonded_tokens_.Release();
}
inline void Pool::set_allocated_not_bonded_tokens(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.not_bonded_tokens_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.not_bonded_tokens_.IsDefault()) {
    _impl_.not_bonded_tokens_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Pool.not_bonded_tokens)
}

// string bonded_tokens = 2 [json_name = "bondedTokens", (.gogoproto.nullable) = false, (.gogoproto.customtype) = "cosmossdk.io/math.Int", (.gogoproto.jsontag) = "bonded_tokens", (.cosmos_proto.scalar) = "cosmos.Int", (.amino.dont_omitempty) = true];
inline void Pool::clear_bonded_tokens() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bonded_tokens_.ClearToEmpty();
}
inline const std::string& Pool::bonded_tokens() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.Pool.bonded_tokens)
  return _internal_bonded_tokens();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Pool::set_bonded_tokens(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bonded_tokens_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.staking.v1beta1.Pool.bonded_tokens)
}
inline std::string* Pool::mutable_bonded_tokens() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bonded_tokens();
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.Pool.bonded_tokens)
  return _s;
}
inline const std::string& Pool::_internal_bonded_tokens() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bonded_tokens_.Get();
}
inline void Pool::_internal_set_bonded_tokens(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bonded_tokens_.Set(value, GetArena());
}
inline std::string* Pool::_internal_mutable_bonded_tokens() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.bonded_tokens_.Mutable( GetArena());
}
inline std::string* Pool::release_bonded_tokens() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.staking.v1beta1.Pool.bonded_tokens)
  return _impl_.bonded_tokens_.Release();
}
inline void Pool::set_allocated_bonded_tokens(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bonded_tokens_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.bonded_tokens_.IsDefault()) {
    _impl_.bonded_tokens_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.staking.v1beta1.Pool.bonded_tokens)
}

// -------------------------------------------------------------------

// ValidatorUpdates

// repeated .tendermint.abci.ValidatorUpdate updates = 1 [json_name = "updates", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline int ValidatorUpdates::_internal_updates_size() const {
  return _internal_updates().size();
}
inline int ValidatorUpdates::updates_size() const {
  return _internal_updates_size();
}
inline ::tendermint::abci::ValidatorUpdate* ValidatorUpdates::mutable_updates(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cosmos.staking.v1beta1.ValidatorUpdates.updates)
  return _internal_mutable_updates()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>* ValidatorUpdates::mutable_updates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cosmos.staking.v1beta1.ValidatorUpdates.updates)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_updates();
}
inline const ::tendermint::abci::ValidatorUpdate& ValidatorUpdates::updates(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.staking.v1beta1.ValidatorUpdates.updates)
  return _internal_updates().Get(index);
}
inline ::tendermint::abci::ValidatorUpdate* ValidatorUpdates::add_updates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::tendermint::abci::ValidatorUpdate* _add = _internal_mutable_updates()->Add();
  // @@protoc_insertion_point(field_add:cosmos.staking.v1beta1.ValidatorUpdates.updates)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>& ValidatorUpdates::updates() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cosmos.staking.v1beta1.ValidatorUpdates.updates)
  return _internal_updates();
}
inline const ::google::protobuf::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>&
ValidatorUpdates::_internal_updates() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.updates_;
}
inline ::google::protobuf::RepeatedPtrField<::tendermint::abci::ValidatorUpdate>*
ValidatorUpdates::_internal_mutable_updates() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.updates_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1beta1
}  // namespace staking
}  // namespace cosmos


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::cosmos::staking::v1beta1::BondStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cosmos::staking::v1beta1::BondStatus>() {
  return ::cosmos::staking::v1beta1::BondStatus_descriptor();
}
template <>
struct is_proto_enum<::cosmos::staking::v1beta1::Infraction> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cosmos::staking::v1beta1::Infraction>() {
  return ::cosmos::staking::v1beta1::Infraction_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // cosmos_2fstaking_2fv1beta1_2fstaking_2eproto_2epb_2eh
