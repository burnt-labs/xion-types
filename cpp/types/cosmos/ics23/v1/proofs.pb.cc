// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: cosmos/ics23/v1/proofs.proto
// Protobuf C++ Version: 5.29.4

#include "cosmos/ics23/v1/proofs.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace cosmos {
namespace ics23 {
namespace v1 {

inline constexpr LeafOp::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : prefix_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        hash_{static_cast< ::cosmos::ics23::v1::HashOp >(0)},
        prehash_key_{static_cast< ::cosmos::ics23::v1::HashOp >(0)},
        prehash_value_{static_cast< ::cosmos::ics23::v1::HashOp >(0)},
        length_{static_cast< ::cosmos::ics23::v1::LengthOp >(0)},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR LeafOp::LeafOp(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LeafOpDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LeafOpDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LeafOpDefaultTypeInternal() {}
  union {
    LeafOp _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeafOpDefaultTypeInternal _LeafOp_default_instance_;

inline constexpr InnerSpec::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : child_order_{},
        _child_order_cached_byte_size_{0},
        empty_child_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        child_size_{0},
        min_prefix_length_{0},
        max_prefix_length_{0},
        hash_{static_cast< ::cosmos::ics23::v1::HashOp >(0)},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR InnerSpec::InnerSpec(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct InnerSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InnerSpecDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InnerSpecDefaultTypeInternal() {}
  union {
    InnerSpec _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InnerSpecDefaultTypeInternal _InnerSpec_default_instance_;

inline constexpr InnerOp::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : prefix_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        suffix_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        hash_{static_cast< ::cosmos::ics23::v1::HashOp >(0)},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR InnerOp::InnerOp(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct InnerOpDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InnerOpDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InnerOpDefaultTypeInternal() {}
  union {
    InnerOp _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InnerOpDefaultTypeInternal _InnerOp_default_instance_;

inline constexpr ProofSpec::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        leaf_spec_{nullptr},
        inner_spec_{nullptr},
        max_depth_{0},
        min_depth_{0} {}

template <typename>
PROTOBUF_CONSTEXPR ProofSpec::ProofSpec(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ProofSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProofSpecDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProofSpecDefaultTypeInternal() {}
  union {
    ProofSpec _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProofSpecDefaultTypeInternal _ProofSpec_default_instance_;

inline constexpr ExistenceProof::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        path_{},
        key_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        value_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        leaf_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR ExistenceProof::ExistenceProof(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ExistenceProofDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExistenceProofDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExistenceProofDefaultTypeInternal() {}
  union {
    ExistenceProof _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExistenceProofDefaultTypeInternal _ExistenceProof_default_instance_;

inline constexpr CompressedExistenceProof::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        path_{},
        _path_cached_byte_size_{0},
        key_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        value_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        leaf_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR CompressedExistenceProof::CompressedExistenceProof(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CompressedExistenceProofDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CompressedExistenceProofDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CompressedExistenceProofDefaultTypeInternal() {}
  union {
    CompressedExistenceProof _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CompressedExistenceProofDefaultTypeInternal _CompressedExistenceProof_default_instance_;

inline constexpr NonExistenceProof::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        key_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        left_{nullptr},
        right_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR NonExistenceProof::NonExistenceProof(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct NonExistenceProofDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NonExistenceProofDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~NonExistenceProofDefaultTypeInternal() {}
  union {
    NonExistenceProof _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NonExistenceProofDefaultTypeInternal _NonExistenceProof_default_instance_;

inline constexpr CompressedNonExistenceProof::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        key_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        left_{nullptr},
        right_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR CompressedNonExistenceProof::CompressedNonExistenceProof(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CompressedNonExistenceProofDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CompressedNonExistenceProofDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CompressedNonExistenceProofDefaultTypeInternal() {}
  union {
    CompressedNonExistenceProof _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CompressedNonExistenceProofDefaultTypeInternal _CompressedNonExistenceProof_default_instance_;

inline constexpr CompressedBatchEntry::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : proof_{},
        _cached_size_{0},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR CompressedBatchEntry::CompressedBatchEntry(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CompressedBatchEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CompressedBatchEntryDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CompressedBatchEntryDefaultTypeInternal() {}
  union {
    CompressedBatchEntry _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CompressedBatchEntryDefaultTypeInternal _CompressedBatchEntry_default_instance_;

inline constexpr BatchEntry::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : proof_{},
        _cached_size_{0},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR BatchEntry::BatchEntry(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BatchEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchEntryDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchEntryDefaultTypeInternal() {}
  union {
    BatchEntry _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchEntryDefaultTypeInternal _BatchEntry_default_instance_;

inline constexpr CompressedBatchProof::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : entries_{},
        lookup_inners_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR CompressedBatchProof::CompressedBatchProof(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CompressedBatchProofDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CompressedBatchProofDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CompressedBatchProofDefaultTypeInternal() {}
  union {
    CompressedBatchProof _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CompressedBatchProofDefaultTypeInternal _CompressedBatchProof_default_instance_;

inline constexpr BatchProof::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : entries_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR BatchProof::BatchProof(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BatchProofDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchProofDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchProofDefaultTypeInternal() {}
  union {
    BatchProof _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchProofDefaultTypeInternal _BatchProof_default_instance_;

inline constexpr CommitmentProof::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : proof_{},
        _cached_size_{0},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR CommitmentProof::CommitmentProof(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CommitmentProofDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommitmentProofDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommitmentProofDefaultTypeInternal() {}
  union {
    CommitmentProof _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommitmentProofDefaultTypeInternal _CommitmentProof_default_instance_;
}  // namespace v1
}  // namespace ics23
}  // namespace cosmos
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_cosmos_2fics23_2fv1_2fproofs_2eproto[2];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_cosmos_2fics23_2fv1_2fproofs_2eproto = nullptr;
const ::uint32_t
    TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto::offsets[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        protodesc_cold) = {
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ExistenceProof, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ExistenceProof, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ExistenceProof, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ExistenceProof, _impl_.value_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ExistenceProof, _impl_.leaf_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ExistenceProof, _impl_.path_),
        ~0u,
        ~0u,
        0,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::NonExistenceProof, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::NonExistenceProof, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::NonExistenceProof, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::NonExistenceProof, _impl_.left_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::NonExistenceProof, _impl_.right_),
        ~0u,
        0,
        1,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CommitmentProof, _internal_metadata_),
        ~0u,  // no _extensions_
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CommitmentProof, _impl_._oneof_case_[0]),
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CommitmentProof, _impl_.proof_),
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::LeafOp, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::LeafOp, _impl_.hash_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::LeafOp, _impl_.prehash_key_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::LeafOp, _impl_.prehash_value_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::LeafOp, _impl_.length_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::LeafOp, _impl_.prefix_),
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::InnerOp, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::InnerOp, _impl_.hash_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::InnerOp, _impl_.prefix_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::InnerOp, _impl_.suffix_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ProofSpec, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ProofSpec, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ProofSpec, _impl_.leaf_spec_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ProofSpec, _impl_.inner_spec_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ProofSpec, _impl_.max_depth_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::ProofSpec, _impl_.min_depth_),
        0,
        1,
        ~0u,
        ~0u,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::InnerSpec, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::InnerSpec, _impl_.child_order_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::InnerSpec, _impl_.child_size_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::InnerSpec, _impl_.min_prefix_length_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::InnerSpec, _impl_.max_prefix_length_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::InnerSpec, _impl_.empty_child_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::InnerSpec, _impl_.hash_),
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::BatchProof, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::BatchProof, _impl_.entries_),
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::BatchEntry, _internal_metadata_),
        ~0u,  // no _extensions_
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::BatchEntry, _impl_._oneof_case_[0]),
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::BatchEntry, _impl_.proof_),
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedBatchProof, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedBatchProof, _impl_.entries_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedBatchProof, _impl_.lookup_inners_),
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedBatchEntry, _internal_metadata_),
        ~0u,  // no _extensions_
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedBatchEntry, _impl_._oneof_case_[0]),
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedBatchEntry, _impl_.proof_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedExistenceProof, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedExistenceProof, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedExistenceProof, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedExistenceProof, _impl_.value_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedExistenceProof, _impl_.leaf_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedExistenceProof, _impl_.path_),
        ~0u,
        ~0u,
        0,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedNonExistenceProof, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedNonExistenceProof, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedNonExistenceProof, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedNonExistenceProof, _impl_.left_),
        PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedNonExistenceProof, _impl_.right_),
        ~0u,
        0,
        1,
};

static const ::_pbi::MigrationSchema
    schemas[] ABSL_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
        {0, 12, -1, sizeof(::cosmos::ics23::v1::ExistenceProof)},
        {16, 27, -1, sizeof(::cosmos::ics23::v1::NonExistenceProof)},
        {30, -1, -1, sizeof(::cosmos::ics23::v1::CommitmentProof)},
        {43, -1, -1, sizeof(::cosmos::ics23::v1::LeafOp)},
        {56, -1, -1, sizeof(::cosmos::ics23::v1::InnerOp)},
        {67, 79, -1, sizeof(::cosmos::ics23::v1::ProofSpec)},
        {83, -1, -1, sizeof(::cosmos::ics23::v1::InnerSpec)},
        {97, -1, -1, sizeof(::cosmos::ics23::v1::BatchProof)},
        {106, -1, -1, sizeof(::cosmos::ics23::v1::BatchEntry)},
        {117, -1, -1, sizeof(::cosmos::ics23::v1::CompressedBatchProof)},
        {127, -1, -1, sizeof(::cosmos::ics23::v1::CompressedBatchEntry)},
        {138, 150, -1, sizeof(::cosmos::ics23::v1::CompressedExistenceProof)},
        {154, 165, -1, sizeof(::cosmos::ics23::v1::CompressedNonExistenceProof)},
};
static const ::_pb::Message* const file_default_instances[] = {
    &::cosmos::ics23::v1::_ExistenceProof_default_instance_._instance,
    &::cosmos::ics23::v1::_NonExistenceProof_default_instance_._instance,
    &::cosmos::ics23::v1::_CommitmentProof_default_instance_._instance,
    &::cosmos::ics23::v1::_LeafOp_default_instance_._instance,
    &::cosmos::ics23::v1::_InnerOp_default_instance_._instance,
    &::cosmos::ics23::v1::_ProofSpec_default_instance_._instance,
    &::cosmos::ics23::v1::_InnerSpec_default_instance_._instance,
    &::cosmos::ics23::v1::_BatchProof_default_instance_._instance,
    &::cosmos::ics23::v1::_BatchEntry_default_instance_._instance,
    &::cosmos::ics23::v1::_CompressedBatchProof_default_instance_._instance,
    &::cosmos::ics23::v1::_CompressedBatchEntry_default_instance_._instance,
    &::cosmos::ics23::v1::_CompressedExistenceProof_default_instance_._instance,
    &::cosmos::ics23::v1::_CompressedNonExistenceProof_default_instance_._instance,
};
const char descriptor_table_protodef_cosmos_2fics23_2fv1_2fproofs_2eproto[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
    protodesc_cold) = {
    "\n\034cosmos/ics23/v1/proofs.proto\022\017cosmos.i"
    "cs23.v1\"\223\001\n\016ExistenceProof\022\020\n\003key\030\001 \001(\014R"
    "\003key\022\024\n\005value\030\002 \001(\014R\005value\022+\n\004leaf\030\003 \001(\013"
    "2\027.cosmos.ics23.v1.LeafOpR\004leaf\022,\n\004path\030"
    "\004 \003(\0132\030.cosmos.ics23.v1.InnerOpR\004path\"\221\001"
    "\n\021NonExistenceProof\022\020\n\003key\030\001 \001(\014R\003key\0223\n"
    "\004left\030\002 \001(\0132\037.cosmos.ics23.v1.ExistenceP"
    "roofR\004left\0225\n\005right\030\003 \001(\0132\037.cosmos.ics23"
    ".v1.ExistenceProofR\005right\"\223\002\n\017Commitment"
    "Proof\0227\n\005exist\030\001 \001(\0132\037.cosmos.ics23.v1.E"
    "xistenceProofH\000R\005exist\022@\n\010nonexist\030\002 \001(\013"
    "2\".cosmos.ics23.v1.NonExistenceProofH\000R\010"
    "nonexist\0223\n\005batch\030\003 \001(\0132\033.cosmos.ics23.v"
    "1.BatchProofH\000R\005batch\022G\n\ncompressed\030\004 \001("
    "\0132%.cosmos.ics23.v1.CompressedBatchProof"
    "H\000R\ncompressedB\007\n\005proof\"\370\001\n\006LeafOp\022+\n\004ha"
    "sh\030\001 \001(\0162\027.cosmos.ics23.v1.HashOpR\004hash\022"
    "8\n\013prehash_key\030\002 \001(\0162\027.cosmos.ics23.v1.H"
    "ashOpR\nprehashKey\022<\n\rprehash_value\030\003 \001(\016"
    "2\027.cosmos.ics23.v1.HashOpR\014prehashValue\022"
    "1\n\006length\030\004 \001(\0162\031.cosmos.ics23.v1.Length"
    "OpR\006length\022\026\n\006prefix\030\005 \001(\014R\006prefix\"f\n\007In"
    "nerOp\022+\n\004hash\030\001 \001(\0162\027.cosmos.ics23.v1.Ha"
    "shOpR\004hash\022\026\n\006prefix\030\002 \001(\014R\006prefix\022\026\n\006su"
    "ffix\030\003 \001(\014R\006suffix\"\266\001\n\tProofSpec\0224\n\tleaf"
    "_spec\030\001 \001(\0132\027.cosmos.ics23.v1.LeafOpR\010le"
    "afSpec\0229\n\ninner_spec\030\002 \001(\0132\032.cosmos.ics2"
    "3.v1.InnerSpecR\tinnerSpec\022\033\n\tmax_depth\030\003"
    " \001(\005R\010maxDepth\022\033\n\tmin_depth\030\004 \001(\005R\010minDe"
    "pth\"\361\001\n\tInnerSpec\022\037\n\013child_order\030\001 \003(\005R\n"
    "childOrder\022\035\n\nchild_size\030\002 \001(\005R\tchildSiz"
    "e\022*\n\021min_prefix_length\030\003 \001(\005R\017minPrefixL"
    "ength\022*\n\021max_prefix_length\030\004 \001(\005R\017maxPre"
    "fixLength\022\037\n\013empty_child\030\005 \001(\014R\nemptyChi"
    "ld\022+\n\004hash\030\006 \001(\0162\027.cosmos.ics23.v1.HashO"
    "pR\004hash\"C\n\nBatchProof\0225\n\007entries\030\001 \003(\0132\033"
    ".cosmos.ics23.v1.BatchEntryR\007entries\"\220\001\n"
    "\nBatchEntry\0227\n\005exist\030\001 \001(\0132\037.cosmos.ics2"
    "3.v1.ExistenceProofH\000R\005exist\022@\n\010nonexist"
    "\030\002 \001(\0132\".cosmos.ics23.v1.NonExistencePro"
    "ofH\000R\010nonexistB\007\n\005proof\"\226\001\n\024CompressedBa"
    "tchProof\022\?\n\007entries\030\001 \003(\0132%.cosmos.ics23"
    ".v1.CompressedBatchEntryR\007entries\022=\n\rloo"
    "kup_inners\030\002 \003(\0132\030.cosmos.ics23.v1.Inner"
    "OpR\014lookupInners\"\256\001\n\024CompressedBatchEntr"
    "y\022A\n\005exist\030\001 \001(\0132).cosmos.ics23.v1.Compr"
    "essedExistenceProofH\000R\005exist\022J\n\010nonexist"
    "\030\002 \001(\0132,.cosmos.ics23.v1.CompressedNonEx"
    "istenceProofH\000R\010nonexistB\007\n\005proof\"\203\001\n\030Co"
    "mpressedExistenceProof\022\020\n\003key\030\001 \001(\014R\003key"
    "\022\024\n\005value\030\002 \001(\014R\005value\022+\n\004leaf\030\003 \001(\0132\027.c"
    "osmos.ics23.v1.LeafOpR\004leaf\022\022\n\004path\030\004 \003("
    "\005R\004path\"\257\001\n\033CompressedNonExistenceProof\022"
    "\020\n\003key\030\001 \001(\014R\003key\022=\n\004left\030\002 \001(\0132).cosmos"
    ".ics23.v1.CompressedExistenceProofR\004left"
    "\022\?\n\005right\030\003 \001(\0132).cosmos.ics23.v1.Compre"
    "ssedExistenceProofR\005right*e\n\006HashOp\022\013\n\007N"
    "O_HASH\020\000\022\n\n\006SHA256\020\001\022\n\n\006SHA512\020\002\022\n\n\006KECC"
    "AK\020\003\022\r\n\tRIPEMD160\020\004\022\013\n\007BITCOIN\020\005\022\016\n\nSHA5"
    "12_256\020\006*\253\001\n\010LengthOp\022\r\n\tNO_PREFIX\020\000\022\r\n\t"
    "VAR_PROTO\020\001\022\013\n\007VAR_RLP\020\002\022\017\n\013FIXED32_BIG\020"
    "\003\022\022\n\016FIXED32_LITTLE\020\004\022\017\n\013FIXED64_BIG\020\005\022\022"
    "\n\016FIXED64_LITTLE\020\006\022\024\n\020REQUIRE_32_BYTES\020\007"
    "\022\024\n\020REQUIRE_64_BYTES\020\010B\"Z github.com/cos"
    "mos/ics23/go;ics23b\006proto3"
};
static ::absl::once_flag descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_once;
PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto = {
    false,
    false,
    2586,
    descriptor_table_protodef_cosmos_2fics23_2fv1_2fproofs_2eproto,
    "cosmos/ics23/v1/proofs.proto",
    &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto_once,
    nullptr,
    0,
    13,
    schemas,
    file_default_instances,
    TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto::offsets,
    file_level_enum_descriptors_cosmos_2fics23_2fv1_2fproofs_2eproto,
    file_level_service_descriptors_cosmos_2fics23_2fv1_2fproofs_2eproto,
};
namespace cosmos {
namespace ics23 {
namespace v1 {
const ::google::protobuf::EnumDescriptor* HashOp_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto);
  return file_level_enum_descriptors_cosmos_2fics23_2fv1_2fproofs_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t HashOp_internal_data_[] = {
    458752u, 0u, };
bool HashOp_IsValid(int value) {
  return 0 <= value && value <= 6;
}
const ::google::protobuf::EnumDescriptor* LengthOp_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto);
  return file_level_enum_descriptors_cosmos_2fics23_2fv1_2fproofs_2eproto[1];
}
PROTOBUF_CONSTINIT const uint32_t LengthOp_internal_data_[] = {
    589824u, 0u, };
bool LengthOp_IsValid(int value) {
  return 0 <= value && value <= 8;
}
// ===================================================================

class ExistenceProof::_Internal {
 public:
  using HasBits =
      decltype(std::declval<ExistenceProof>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ExistenceProof, _impl_._has_bits_);
};

ExistenceProof::ExistenceProof(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.ExistenceProof)
}
inline PROTOBUF_NDEBUG_INLINE ExistenceProof::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::cosmos::ics23::v1::ExistenceProof& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        path_{visibility, arena, from.path_},
        key_(arena, from.key_),
        value_(arena, from.value_) {}

ExistenceProof::ExistenceProof(
    ::google::protobuf::Arena* arena,
    const ExistenceProof& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ExistenceProof* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.leaf_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::LeafOp>(
                              arena, *from._impl_.leaf_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.ExistenceProof)
}
inline PROTOBUF_NDEBUG_INLINE ExistenceProof::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        path_{visibility, arena},
        key_(arena),
        value_(arena) {}

inline void ExistenceProof::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.leaf_ = {};
}
ExistenceProof::~ExistenceProof() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.ExistenceProof)
  SharedDtor(*this);
}
inline void ExistenceProof::SharedDtor(MessageLite& self) {
  ExistenceProof& this_ = static_cast<ExistenceProof&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.key_.Destroy();
  this_._impl_.value_.Destroy();
  delete this_._impl_.leaf_;
  this_._impl_.~Impl_();
}

inline void* ExistenceProof::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) ExistenceProof(arena);
}
constexpr auto ExistenceProof::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(ExistenceProof, _impl_.path_) +
          decltype(ExistenceProof::_impl_.path_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(ExistenceProof), alignof(ExistenceProof), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&ExistenceProof::PlacementNew_,
                                 sizeof(ExistenceProof),
                                 alignof(ExistenceProof));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull ExistenceProof::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_ExistenceProof_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &ExistenceProof::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<ExistenceProof>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &ExistenceProof::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<ExistenceProof>(), &ExistenceProof::ByteSizeLong,
            &ExistenceProof::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(ExistenceProof, _impl_._cached_size_),
        false,
    },
    &ExistenceProof::kDescriptorMethods,
    &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* ExistenceProof::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 2, 0, 2> ExistenceProof::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ExistenceProof, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::cosmos::ics23::v1::ExistenceProof>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .cosmos.ics23.v1.InnerOp path = 4 [json_name = "path"];
    {::_pbi::TcParser::FastMtR1,
     {34, 63, 1, PROTOBUF_FIELD_OFFSET(ExistenceProof, _impl_.path_)}},
    // bytes key = 1 [json_name = "key"];
    {::_pbi::TcParser::FastBS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(ExistenceProof, _impl_.key_)}},
    // bytes value = 2 [json_name = "value"];
    {::_pbi::TcParser::FastBS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(ExistenceProof, _impl_.value_)}},
    // .cosmos.ics23.v1.LeafOp leaf = 3 [json_name = "leaf"];
    {::_pbi::TcParser::FastMtS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(ExistenceProof, _impl_.leaf_)}},
  }}, {{
    65535, 65535
  }}, {{
    // bytes key = 1 [json_name = "key"];
    {PROTOBUF_FIELD_OFFSET(ExistenceProof, _impl_.key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBytes | ::_fl::kRepAString)},
    // bytes value = 2 [json_name = "value"];
    {PROTOBUF_FIELD_OFFSET(ExistenceProof, _impl_.value_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBytes | ::_fl::kRepAString)},
    // .cosmos.ics23.v1.LeafOp leaf = 3 [json_name = "leaf"];
    {PROTOBUF_FIELD_OFFSET(ExistenceProof, _impl_.leaf_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .cosmos.ics23.v1.InnerOp path = 4 [json_name = "path"];
    {PROTOBUF_FIELD_OFFSET(ExistenceProof, _impl_.path_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::cosmos::ics23::v1::LeafOp>()},
    {::_pbi::TcParser::GetTable<::cosmos::ics23::v1::InnerOp>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void ExistenceProof::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.ExistenceProof)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.path_.Clear();
  _impl_.key_.ClearToEmpty();
  _impl_.value_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.leaf_ != nullptr);
    _impl_.leaf_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* ExistenceProof::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const ExistenceProof& this_ = static_cast<const ExistenceProof&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* ExistenceProof::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const ExistenceProof& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.ExistenceProof)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // bytes key = 1 [json_name = "key"];
          if (!this_._internal_key().empty()) {
            const std::string& _s = this_._internal_key();
            target = stream->WriteBytesMaybeAliased(1, _s, target);
          }

          // bytes value = 2 [json_name = "value"];
          if (!this_._internal_value().empty()) {
            const std::string& _s = this_._internal_value();
            target = stream->WriteBytesMaybeAliased(2, _s, target);
          }

          cached_has_bits = this_._impl_._has_bits_[0];
          // .cosmos.ics23.v1.LeafOp leaf = 3 [json_name = "leaf"];
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                3, *this_._impl_.leaf_, this_._impl_.leaf_->GetCachedSize(), target,
                stream);
          }

          // repeated .cosmos.ics23.v1.InnerOp path = 4 [json_name = "path"];
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_path_size());
               i < n; i++) {
            const auto& repfield = this_._internal_path().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    4, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.ExistenceProof)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t ExistenceProof::ByteSizeLong(const MessageLite& base) {
          const ExistenceProof& this_ = static_cast<const ExistenceProof&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t ExistenceProof::ByteSizeLong() const {
          const ExistenceProof& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.ExistenceProof)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .cosmos.ics23.v1.InnerOp path = 4 [json_name = "path"];
            {
              total_size += 1UL * this_._internal_path_size();
              for (const auto& msg : this_._internal_path()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
           {
            // bytes key = 1 [json_name = "key"];
            if (!this_._internal_key().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                              this_._internal_key());
            }
            // bytes value = 2 [json_name = "value"];
            if (!this_._internal_value().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                              this_._internal_value());
            }
          }
           {
            // .cosmos.ics23.v1.LeafOp leaf = 3 [json_name = "leaf"];
            cached_has_bits = this_._impl_._has_bits_[0];
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.leaf_);
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void ExistenceProof::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ExistenceProof*>(&to_msg);
  auto& from = static_cast<const ExistenceProof&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.ExistenceProof)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_path()->MergeFrom(
      from._internal_path());
  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(from._impl_.leaf_ != nullptr);
    if (_this->_impl_.leaf_ == nullptr) {
      _this->_impl_.leaf_ =
          ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::LeafOp>(arena, *from._impl_.leaf_);
    } else {
      _this->_impl_.leaf_->MergeFrom(*from._impl_.leaf_);
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ExistenceProof::CopyFrom(const ExistenceProof& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.ExistenceProof)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ExistenceProof::InternalSwap(ExistenceProof* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.path_.InternalSwap(&other->_impl_.path_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_, &other->_impl_.key_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.value_, &other->_impl_.value_, arena);
  swap(_impl_.leaf_, other->_impl_.leaf_);
}

::google::protobuf::Metadata ExistenceProof::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class NonExistenceProof::_Internal {
 public:
  using HasBits =
      decltype(std::declval<NonExistenceProof>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(NonExistenceProof, _impl_._has_bits_);
};

NonExistenceProof::NonExistenceProof(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.NonExistenceProof)
}
inline PROTOBUF_NDEBUG_INLINE NonExistenceProof::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::cosmos::ics23::v1::NonExistenceProof& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        key_(arena, from.key_) {}

NonExistenceProof::NonExistenceProof(
    ::google::protobuf::Arena* arena,
    const NonExistenceProof& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  NonExistenceProof* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.left_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::ExistenceProof>(
                              arena, *from._impl_.left_)
                        : nullptr;
  _impl_.right_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::ExistenceProof>(
                              arena, *from._impl_.right_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.NonExistenceProof)
}
inline PROTOBUF_NDEBUG_INLINE NonExistenceProof::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        key_(arena) {}

inline void NonExistenceProof::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, left_),
           0,
           offsetof(Impl_, right_) -
               offsetof(Impl_, left_) +
               sizeof(Impl_::right_));
}
NonExistenceProof::~NonExistenceProof() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.NonExistenceProof)
  SharedDtor(*this);
}
inline void NonExistenceProof::SharedDtor(MessageLite& self) {
  NonExistenceProof& this_ = static_cast<NonExistenceProof&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.key_.Destroy();
  delete this_._impl_.left_;
  delete this_._impl_.right_;
  this_._impl_.~Impl_();
}

inline void* NonExistenceProof::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) NonExistenceProof(arena);
}
constexpr auto NonExistenceProof::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(NonExistenceProof),
                                            alignof(NonExistenceProof));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull NonExistenceProof::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_NonExistenceProof_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &NonExistenceProof::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<NonExistenceProof>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &NonExistenceProof::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<NonExistenceProof>(), &NonExistenceProof::ByteSizeLong,
            &NonExistenceProof::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(NonExistenceProof, _impl_._cached_size_),
        false,
    },
    &NonExistenceProof::kDescriptorMethods,
    &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* NonExistenceProof::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 2, 0, 2> NonExistenceProof::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(NonExistenceProof, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::cosmos::ics23::v1::NonExistenceProof>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // bytes key = 1 [json_name = "key"];
    {::_pbi::TcParser::FastBS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(NonExistenceProof, _impl_.key_)}},
    // .cosmos.ics23.v1.ExistenceProof left = 2 [json_name = "left"];
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(NonExistenceProof, _impl_.left_)}},
    // .cosmos.ics23.v1.ExistenceProof right = 3 [json_name = "right"];
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 1, PROTOBUF_FIELD_OFFSET(NonExistenceProof, _impl_.right_)}},
  }}, {{
    65535, 65535
  }}, {{
    // bytes key = 1 [json_name = "key"];
    {PROTOBUF_FIELD_OFFSET(NonExistenceProof, _impl_.key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBytes | ::_fl::kRepAString)},
    // .cosmos.ics23.v1.ExistenceProof left = 2 [json_name = "left"];
    {PROTOBUF_FIELD_OFFSET(NonExistenceProof, _impl_.left_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .cosmos.ics23.v1.ExistenceProof right = 3 [json_name = "right"];
    {PROTOBUF_FIELD_OFFSET(NonExistenceProof, _impl_.right_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::cosmos::ics23::v1::ExistenceProof>()},
    {::_pbi::TcParser::GetTable<::cosmos::ics23::v1::ExistenceProof>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void NonExistenceProof::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.NonExistenceProof)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.left_ != nullptr);
      _impl_.left_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.right_ != nullptr);
      _impl_.right_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* NonExistenceProof::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const NonExistenceProof& this_ = static_cast<const NonExistenceProof&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* NonExistenceProof::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const NonExistenceProof& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.NonExistenceProof)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // bytes key = 1 [json_name = "key"];
          if (!this_._internal_key().empty()) {
            const std::string& _s = this_._internal_key();
            target = stream->WriteBytesMaybeAliased(1, _s, target);
          }

          cached_has_bits = this_._impl_._has_bits_[0];
          // .cosmos.ics23.v1.ExistenceProof left = 2 [json_name = "left"];
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                2, *this_._impl_.left_, this_._impl_.left_->GetCachedSize(), target,
                stream);
          }

          // .cosmos.ics23.v1.ExistenceProof right = 3 [json_name = "right"];
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                3, *this_._impl_.right_, this_._impl_.right_->GetCachedSize(), target,
                stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.NonExistenceProof)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t NonExistenceProof::ByteSizeLong(const MessageLite& base) {
          const NonExistenceProof& this_ = static_cast<const NonExistenceProof&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t NonExistenceProof::ByteSizeLong() const {
          const NonExistenceProof& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.NonExistenceProof)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // bytes key = 1 [json_name = "key"];
            if (!this_._internal_key().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                              this_._internal_key());
            }
          }
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000003u) {
            // .cosmos.ics23.v1.ExistenceProof left = 2 [json_name = "left"];
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.left_);
            }
            // .cosmos.ics23.v1.ExistenceProof right = 3 [json_name = "right"];
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.right_);
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void NonExistenceProof::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<NonExistenceProof*>(&to_msg);
  auto& from = static_cast<const NonExistenceProof&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.NonExistenceProof)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.left_ != nullptr);
      if (_this->_impl_.left_ == nullptr) {
        _this->_impl_.left_ =
            ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::ExistenceProof>(arena, *from._impl_.left_);
      } else {
        _this->_impl_.left_->MergeFrom(*from._impl_.left_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.right_ != nullptr);
      if (_this->_impl_.right_ == nullptr) {
        _this->_impl_.right_ =
            ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::ExistenceProof>(arena, *from._impl_.right_);
      } else {
        _this->_impl_.right_->MergeFrom(*from._impl_.right_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void NonExistenceProof::CopyFrom(const NonExistenceProof& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.NonExistenceProof)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void NonExistenceProof::InternalSwap(NonExistenceProof* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_, &other->_impl_.key_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NonExistenceProof, _impl_.right_)
      + sizeof(NonExistenceProof::_impl_.right_)
      - PROTOBUF_FIELD_OFFSET(NonExistenceProof, _impl_.left_)>(
          reinterpret_cast<char*>(&_impl_.left_),
          reinterpret_cast<char*>(&other->_impl_.left_));
}

::google::protobuf::Metadata NonExistenceProof::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CommitmentProof::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CommitmentProof, _impl_._oneof_case_);
};

void CommitmentProof::set_allocated_exist(::cosmos::ics23::v1::ExistenceProof* exist) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_proof();
  if (exist) {
    ::google::protobuf::Arena* submessage_arena = exist->GetArena();
    if (message_arena != submessage_arena) {
      exist = ::google::protobuf::internal::GetOwnedMessage(message_arena, exist, submessage_arena);
    }
    set_has_exist();
    _impl_.proof_.exist_ = exist;
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CommitmentProof.exist)
}
void CommitmentProof::set_allocated_nonexist(::cosmos::ics23::v1::NonExistenceProof* nonexist) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_proof();
  if (nonexist) {
    ::google::protobuf::Arena* submessage_arena = nonexist->GetArena();
    if (message_arena != submessage_arena) {
      nonexist = ::google::protobuf::internal::GetOwnedMessage(message_arena, nonexist, submessage_arena);
    }
    set_has_nonexist();
    _impl_.proof_.nonexist_ = nonexist;
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CommitmentProof.nonexist)
}
void CommitmentProof::set_allocated_batch(::cosmos::ics23::v1::BatchProof* batch) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_proof();
  if (batch) {
    ::google::protobuf::Arena* submessage_arena = batch->GetArena();
    if (message_arena != submessage_arena) {
      batch = ::google::protobuf::internal::GetOwnedMessage(message_arena, batch, submessage_arena);
    }
    set_has_batch();
    _impl_.proof_.batch_ = batch;
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CommitmentProof.batch)
}
void CommitmentProof::set_allocated_compressed(::cosmos::ics23::v1::CompressedBatchProof* compressed) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_proof();
  if (compressed) {
    ::google::protobuf::Arena* submessage_arena = compressed->GetArena();
    if (message_arena != submessage_arena) {
      compressed = ::google::protobuf::internal::GetOwnedMessage(message_arena, compressed, submessage_arena);
    }
    set_has_compressed();
    _impl_.proof_.compressed_ = compressed;
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CommitmentProof.compressed)
}
CommitmentProof::CommitmentProof(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.CommitmentProof)
}
inline PROTOBUF_NDEBUG_INLINE CommitmentProof::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::cosmos::ics23::v1::CommitmentProof& from_msg)
      : proof_{},
        _cached_size_{0},
        _oneof_case_{from._oneof_case_[0]} {}

CommitmentProof::CommitmentProof(
    ::google::protobuf::Arena* arena,
    const CommitmentProof& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CommitmentProof* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  switch (proof_case()) {
    case PROOF_NOT_SET:
      break;
      case kExist:
        _impl_.proof_.exist_ = ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::ExistenceProof>(arena, *from._impl_.proof_.exist_);
        break;
      case kNonexist:
        _impl_.proof_.nonexist_ = ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::NonExistenceProof>(arena, *from._impl_.proof_.nonexist_);
        break;
      case kBatch:
        _impl_.proof_.batch_ = ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::BatchProof>(arena, *from._impl_.proof_.batch_);
        break;
      case kCompressed:
        _impl_.proof_.compressed_ = ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::CompressedBatchProof>(arena, *from._impl_.proof_.compressed_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.CommitmentProof)
}
inline PROTOBUF_NDEBUG_INLINE CommitmentProof::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : proof_{},
        _cached_size_{0},
        _oneof_case_{} {}

inline void CommitmentProof::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
CommitmentProof::~CommitmentProof() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.CommitmentProof)
  SharedDtor(*this);
}
inline void CommitmentProof::SharedDtor(MessageLite& self) {
  CommitmentProof& this_ = static_cast<CommitmentProof&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  if (this_.has_proof()) {
    this_.clear_proof();
  }
  this_._impl_.~Impl_();
}

void CommitmentProof::clear_proof() {
// @@protoc_insertion_point(one_of_clear_start:cosmos.ics23.v1.CommitmentProof)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (proof_case()) {
    case kExist: {
      if (GetArena() == nullptr) {
        delete _impl_.proof_.exist_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.proof_.exist_);
      }
      break;
    }
    case kNonexist: {
      if (GetArena() == nullptr) {
        delete _impl_.proof_.nonexist_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.proof_.nonexist_);
      }
      break;
    }
    case kBatch: {
      if (GetArena() == nullptr) {
        delete _impl_.proof_.batch_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.proof_.batch_);
      }
      break;
    }
    case kCompressed: {
      if (GetArena() == nullptr) {
        delete _impl_.proof_.compressed_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.proof_.compressed_);
      }
      break;
    }
    case PROOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PROOF_NOT_SET;
}


inline void* CommitmentProof::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) CommitmentProof(arena);
}
constexpr auto CommitmentProof::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(CommitmentProof),
                                            alignof(CommitmentProof));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull CommitmentProof::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_CommitmentProof_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &CommitmentProof::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<CommitmentProof>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &CommitmentProof::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<CommitmentProof>(), &CommitmentProof::ByteSizeLong,
            &CommitmentProof::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(CommitmentProof, _impl_._cached_size_),
        false,
    },
    &CommitmentProof::kDescriptorMethods,
    &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* CommitmentProof::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 4, 4, 0, 2> CommitmentProof::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::cosmos::ics23::v1::CommitmentProof>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .cosmos.ics23.v1.ExistenceProof exist = 1 [json_name = "exist"];
    {PROTOBUF_FIELD_OFFSET(CommitmentProof, _impl_.proof_.exist_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .cosmos.ics23.v1.NonExistenceProof nonexist = 2 [json_name = "nonexist"];
    {PROTOBUF_FIELD_OFFSET(CommitmentProof, _impl_.proof_.nonexist_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .cosmos.ics23.v1.BatchProof batch = 3 [json_name = "batch"];
    {PROTOBUF_FIELD_OFFSET(CommitmentProof, _impl_.proof_.batch_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .cosmos.ics23.v1.CompressedBatchProof compressed = 4 [json_name = "compressed"];
    {PROTOBUF_FIELD_OFFSET(CommitmentProof, _impl_.proof_.compressed_), _Internal::kOneofCaseOffset + 0, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::cosmos::ics23::v1::ExistenceProof>()},
    {::_pbi::TcParser::GetTable<::cosmos::ics23::v1::NonExistenceProof>()},
    {::_pbi::TcParser::GetTable<::cosmos::ics23::v1::BatchProof>()},
    {::_pbi::TcParser::GetTable<::cosmos::ics23::v1::CompressedBatchProof>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void CommitmentProof::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.CommitmentProof)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_proof();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* CommitmentProof::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const CommitmentProof& this_ = static_cast<const CommitmentProof&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* CommitmentProof::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const CommitmentProof& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.CommitmentProof)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          switch (this_.proof_case()) {
            case kExist: {
              target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                  1, *this_._impl_.proof_.exist_, this_._impl_.proof_.exist_->GetCachedSize(), target,
                  stream);
              break;
            }
            case kNonexist: {
              target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                  2, *this_._impl_.proof_.nonexist_, this_._impl_.proof_.nonexist_->GetCachedSize(), target,
                  stream);
              break;
            }
            case kBatch: {
              target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                  3, *this_._impl_.proof_.batch_, this_._impl_.proof_.batch_->GetCachedSize(), target,
                  stream);
              break;
            }
            case kCompressed: {
              target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                  4, *this_._impl_.proof_.compressed_, this_._impl_.proof_.compressed_->GetCachedSize(), target,
                  stream);
              break;
            }
            default:
              break;
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.CommitmentProof)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t CommitmentProof::ByteSizeLong(const MessageLite& base) {
          const CommitmentProof& this_ = static_cast<const CommitmentProof&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t CommitmentProof::ByteSizeLong() const {
          const CommitmentProof& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.CommitmentProof)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          switch (this_.proof_case()) {
            // .cosmos.ics23.v1.ExistenceProof exist = 1 [json_name = "exist"];
            case kExist: {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.proof_.exist_);
              break;
            }
            // .cosmos.ics23.v1.NonExistenceProof nonexist = 2 [json_name = "nonexist"];
            case kNonexist: {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.proof_.nonexist_);
              break;
            }
            // .cosmos.ics23.v1.BatchProof batch = 3 [json_name = "batch"];
            case kBatch: {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.proof_.batch_);
              break;
            }
            // .cosmos.ics23.v1.CompressedBatchProof compressed = 4 [json_name = "compressed"];
            case kCompressed: {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.proof_.compressed_);
              break;
            }
            case PROOF_NOT_SET: {
              break;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void CommitmentProof::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<CommitmentProof*>(&to_msg);
  auto& from = static_cast<const CommitmentProof&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.CommitmentProof)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_proof();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kExist: {
        if (oneof_needs_init) {
          _this->_impl_.proof_.exist_ =
              ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::ExistenceProof>(arena, *from._impl_.proof_.exist_);
        } else {
          _this->_impl_.proof_.exist_->MergeFrom(from._internal_exist());
        }
        break;
      }
      case kNonexist: {
        if (oneof_needs_init) {
          _this->_impl_.proof_.nonexist_ =
              ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::NonExistenceProof>(arena, *from._impl_.proof_.nonexist_);
        } else {
          _this->_impl_.proof_.nonexist_->MergeFrom(from._internal_nonexist());
        }
        break;
      }
      case kBatch: {
        if (oneof_needs_init) {
          _this->_impl_.proof_.batch_ =
              ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::BatchProof>(arena, *from._impl_.proof_.batch_);
        } else {
          _this->_impl_.proof_.batch_->MergeFrom(from._internal_batch());
        }
        break;
      }
      case kCompressed: {
        if (oneof_needs_init) {
          _this->_impl_.proof_.compressed_ =
              ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::CompressedBatchProof>(arena, *from._impl_.proof_.compressed_);
        } else {
          _this->_impl_.proof_.compressed_->MergeFrom(from._internal_compressed());
        }
        break;
      }
      case PROOF_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CommitmentProof::CopyFrom(const CommitmentProof& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.CommitmentProof)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CommitmentProof::InternalSwap(CommitmentProof* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.proof_, other->_impl_.proof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata CommitmentProof::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class LeafOp::_Internal {
 public:
};

LeafOp::LeafOp(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.LeafOp)
}
inline PROTOBUF_NDEBUG_INLINE LeafOp::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::cosmos::ics23::v1::LeafOp& from_msg)
      : prefix_(arena, from.prefix_),
        _cached_size_{0} {}

LeafOp::LeafOp(
    ::google::protobuf::Arena* arena,
    const LeafOp& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LeafOp* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, hash_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, hash_),
           offsetof(Impl_, length_) -
               offsetof(Impl_, hash_) +
               sizeof(Impl_::length_));

  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.LeafOp)
}
inline PROTOBUF_NDEBUG_INLINE LeafOp::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : prefix_(arena),
        _cached_size_{0} {}

inline void LeafOp::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, hash_),
           0,
           offsetof(Impl_, length_) -
               offsetof(Impl_, hash_) +
               sizeof(Impl_::length_));
}
LeafOp::~LeafOp() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.LeafOp)
  SharedDtor(*this);
}
inline void LeafOp::SharedDtor(MessageLite& self) {
  LeafOp& this_ = static_cast<LeafOp&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.prefix_.Destroy();
  this_._impl_.~Impl_();
}

inline void* LeafOp::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) LeafOp(arena);
}
constexpr auto LeafOp::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(LeafOp),
                                            alignof(LeafOp));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull LeafOp::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_LeafOp_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &LeafOp::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<LeafOp>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &LeafOp::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<LeafOp>(), &LeafOp::ByteSizeLong,
            &LeafOp::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(LeafOp, _impl_._cached_size_),
        false,
    },
    &LeafOp::kDescriptorMethods,
    &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* LeafOp::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 2> LeafOp::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::cosmos::ics23::v1::LeafOp>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .cosmos.ics23.v1.HashOp hash = 1 [json_name = "hash"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(LeafOp, _impl_.hash_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(LeafOp, _impl_.hash_)}},
    // .cosmos.ics23.v1.HashOp prehash_key = 2 [json_name = "prehashKey"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(LeafOp, _impl_.prehash_key_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(LeafOp, _impl_.prehash_key_)}},
    // .cosmos.ics23.v1.HashOp prehash_value = 3 [json_name = "prehashValue"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(LeafOp, _impl_.prehash_value_), 63>(),
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(LeafOp, _impl_.prehash_value_)}},
    // .cosmos.ics23.v1.LengthOp length = 4 [json_name = "length"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(LeafOp, _impl_.length_), 63>(),
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(LeafOp, _impl_.length_)}},
    // bytes prefix = 5 [json_name = "prefix"];
    {::_pbi::TcParser::FastBS1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(LeafOp, _impl_.prefix_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .cosmos.ics23.v1.HashOp hash = 1 [json_name = "hash"];
    {PROTOBUF_FIELD_OFFSET(LeafOp, _impl_.hash_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .cosmos.ics23.v1.HashOp prehash_key = 2 [json_name = "prehashKey"];
    {PROTOBUF_FIELD_OFFSET(LeafOp, _impl_.prehash_key_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .cosmos.ics23.v1.HashOp prehash_value = 3 [json_name = "prehashValue"];
    {PROTOBUF_FIELD_OFFSET(LeafOp, _impl_.prehash_value_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .cosmos.ics23.v1.LengthOp length = 4 [json_name = "length"];
    {PROTOBUF_FIELD_OFFSET(LeafOp, _impl_.length_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // bytes prefix = 5 [json_name = "prefix"];
    {PROTOBUF_FIELD_OFFSET(LeafOp, _impl_.prefix_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void LeafOp::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.LeafOp)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.prefix_.ClearToEmpty();
  ::memset(&_impl_.hash_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.length_) -
      reinterpret_cast<char*>(&_impl_.hash_)) + sizeof(_impl_.length_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* LeafOp::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const LeafOp& this_ = static_cast<const LeafOp&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* LeafOp::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const LeafOp& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.LeafOp)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // .cosmos.ics23.v1.HashOp hash = 1 [json_name = "hash"];
          if (this_._internal_hash() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                1, this_._internal_hash(), target);
          }

          // .cosmos.ics23.v1.HashOp prehash_key = 2 [json_name = "prehashKey"];
          if (this_._internal_prehash_key() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                2, this_._internal_prehash_key(), target);
          }

          // .cosmos.ics23.v1.HashOp prehash_value = 3 [json_name = "prehashValue"];
          if (this_._internal_prehash_value() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                3, this_._internal_prehash_value(), target);
          }

          // .cosmos.ics23.v1.LengthOp length = 4 [json_name = "length"];
          if (this_._internal_length() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                4, this_._internal_length(), target);
          }

          // bytes prefix = 5 [json_name = "prefix"];
          if (!this_._internal_prefix().empty()) {
            const std::string& _s = this_._internal_prefix();
            target = stream->WriteBytesMaybeAliased(5, _s, target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.LeafOp)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t LeafOp::ByteSizeLong(const MessageLite& base) {
          const LeafOp& this_ = static_cast<const LeafOp&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t LeafOp::ByteSizeLong() const {
          const LeafOp& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.LeafOp)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // bytes prefix = 5 [json_name = "prefix"];
            if (!this_._internal_prefix().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                              this_._internal_prefix());
            }
            // .cosmos.ics23.v1.HashOp hash = 1 [json_name = "hash"];
            if (this_._internal_hash() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_hash());
            }
            // .cosmos.ics23.v1.HashOp prehash_key = 2 [json_name = "prehashKey"];
            if (this_._internal_prehash_key() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_prehash_key());
            }
            // .cosmos.ics23.v1.HashOp prehash_value = 3 [json_name = "prehashValue"];
            if (this_._internal_prehash_value() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_prehash_value());
            }
            // .cosmos.ics23.v1.LengthOp length = 4 [json_name = "length"];
            if (this_._internal_length() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_length());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void LeafOp::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<LeafOp*>(&to_msg);
  auto& from = static_cast<const LeafOp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.LeafOp)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_prefix().empty()) {
    _this->_internal_set_prefix(from._internal_prefix());
  }
  if (from._internal_hash() != 0) {
    _this->_impl_.hash_ = from._impl_.hash_;
  }
  if (from._internal_prehash_key() != 0) {
    _this->_impl_.prehash_key_ = from._impl_.prehash_key_;
  }
  if (from._internal_prehash_value() != 0) {
    _this->_impl_.prehash_value_ = from._impl_.prehash_value_;
  }
  if (from._internal_length() != 0) {
    _this->_impl_.length_ = from._impl_.length_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LeafOp::CopyFrom(const LeafOp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.LeafOp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LeafOp::InternalSwap(LeafOp* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.prefix_, &other->_impl_.prefix_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LeafOp, _impl_.length_)
      + sizeof(LeafOp::_impl_.length_)
      - PROTOBUF_FIELD_OFFSET(LeafOp, _impl_.hash_)>(
          reinterpret_cast<char*>(&_impl_.hash_),
          reinterpret_cast<char*>(&other->_impl_.hash_));
}

::google::protobuf::Metadata LeafOp::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class InnerOp::_Internal {
 public:
};

InnerOp::InnerOp(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.InnerOp)
}
inline PROTOBUF_NDEBUG_INLINE InnerOp::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::cosmos::ics23::v1::InnerOp& from_msg)
      : prefix_(arena, from.prefix_),
        suffix_(arena, from.suffix_),
        _cached_size_{0} {}

InnerOp::InnerOp(
    ::google::protobuf::Arena* arena,
    const InnerOp& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  InnerOp* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.hash_ = from._impl_.hash_;

  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.InnerOp)
}
inline PROTOBUF_NDEBUG_INLINE InnerOp::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : prefix_(arena),
        suffix_(arena),
        _cached_size_{0} {}

inline void InnerOp::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.hash_ = {};
}
InnerOp::~InnerOp() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.InnerOp)
  SharedDtor(*this);
}
inline void InnerOp::SharedDtor(MessageLite& self) {
  InnerOp& this_ = static_cast<InnerOp&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.prefix_.Destroy();
  this_._impl_.suffix_.Destroy();
  this_._impl_.~Impl_();
}

inline void* InnerOp::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) InnerOp(arena);
}
constexpr auto InnerOp::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(InnerOp),
                                            alignof(InnerOp));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull InnerOp::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_InnerOp_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &InnerOp::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<InnerOp>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &InnerOp::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<InnerOp>(), &InnerOp::ByteSizeLong,
            &InnerOp::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(InnerOp, _impl_._cached_size_),
        false,
    },
    &InnerOp::kDescriptorMethods,
    &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* InnerOp::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> InnerOp::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::cosmos::ics23::v1::InnerOp>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .cosmos.ics23.v1.HashOp hash = 1 [json_name = "hash"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(InnerOp, _impl_.hash_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(InnerOp, _impl_.hash_)}},
    // bytes prefix = 2 [json_name = "prefix"];
    {::_pbi::TcParser::FastBS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(InnerOp, _impl_.prefix_)}},
    // bytes suffix = 3 [json_name = "suffix"];
    {::_pbi::TcParser::FastBS1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(InnerOp, _impl_.suffix_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .cosmos.ics23.v1.HashOp hash = 1 [json_name = "hash"];
    {PROTOBUF_FIELD_OFFSET(InnerOp, _impl_.hash_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // bytes prefix = 2 [json_name = "prefix"];
    {PROTOBUF_FIELD_OFFSET(InnerOp, _impl_.prefix_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBytes | ::_fl::kRepAString)},
    // bytes suffix = 3 [json_name = "suffix"];
    {PROTOBUF_FIELD_OFFSET(InnerOp, _impl_.suffix_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void InnerOp::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.InnerOp)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.prefix_.ClearToEmpty();
  _impl_.suffix_.ClearToEmpty();
  _impl_.hash_ = 0;
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* InnerOp::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const InnerOp& this_ = static_cast<const InnerOp&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* InnerOp::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const InnerOp& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.InnerOp)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // .cosmos.ics23.v1.HashOp hash = 1 [json_name = "hash"];
          if (this_._internal_hash() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                1, this_._internal_hash(), target);
          }

          // bytes prefix = 2 [json_name = "prefix"];
          if (!this_._internal_prefix().empty()) {
            const std::string& _s = this_._internal_prefix();
            target = stream->WriteBytesMaybeAliased(2, _s, target);
          }

          // bytes suffix = 3 [json_name = "suffix"];
          if (!this_._internal_suffix().empty()) {
            const std::string& _s = this_._internal_suffix();
            target = stream->WriteBytesMaybeAliased(3, _s, target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.InnerOp)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t InnerOp::ByteSizeLong(const MessageLite& base) {
          const InnerOp& this_ = static_cast<const InnerOp&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t InnerOp::ByteSizeLong() const {
          const InnerOp& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.InnerOp)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // bytes prefix = 2 [json_name = "prefix"];
            if (!this_._internal_prefix().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                              this_._internal_prefix());
            }
            // bytes suffix = 3 [json_name = "suffix"];
            if (!this_._internal_suffix().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                              this_._internal_suffix());
            }
            // .cosmos.ics23.v1.HashOp hash = 1 [json_name = "hash"];
            if (this_._internal_hash() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_hash());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void InnerOp::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<InnerOp*>(&to_msg);
  auto& from = static_cast<const InnerOp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.InnerOp)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_prefix().empty()) {
    _this->_internal_set_prefix(from._internal_prefix());
  }
  if (!from._internal_suffix().empty()) {
    _this->_internal_set_suffix(from._internal_suffix());
  }
  if (from._internal_hash() != 0) {
    _this->_impl_.hash_ = from._impl_.hash_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void InnerOp::CopyFrom(const InnerOp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.InnerOp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void InnerOp::InternalSwap(InnerOp* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.prefix_, &other->_impl_.prefix_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.suffix_, &other->_impl_.suffix_, arena);
  swap(_impl_.hash_, other->_impl_.hash_);
}

::google::protobuf::Metadata InnerOp::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ProofSpec::_Internal {
 public:
  using HasBits =
      decltype(std::declval<ProofSpec>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ProofSpec, _impl_._has_bits_);
};

ProofSpec::ProofSpec(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.ProofSpec)
}
inline PROTOBUF_NDEBUG_INLINE ProofSpec::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::cosmos::ics23::v1::ProofSpec& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

ProofSpec::ProofSpec(
    ::google::protobuf::Arena* arena,
    const ProofSpec& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ProofSpec* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.leaf_spec_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::LeafOp>(
                              arena, *from._impl_.leaf_spec_)
                        : nullptr;
  _impl_.inner_spec_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::InnerSpec>(
                              arena, *from._impl_.inner_spec_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, max_depth_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, max_depth_),
           offsetof(Impl_, min_depth_) -
               offsetof(Impl_, max_depth_) +
               sizeof(Impl_::min_depth_));

  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.ProofSpec)
}
inline PROTOBUF_NDEBUG_INLINE ProofSpec::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void ProofSpec::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, leaf_spec_),
           0,
           offsetof(Impl_, min_depth_) -
               offsetof(Impl_, leaf_spec_) +
               sizeof(Impl_::min_depth_));
}
ProofSpec::~ProofSpec() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.ProofSpec)
  SharedDtor(*this);
}
inline void ProofSpec::SharedDtor(MessageLite& self) {
  ProofSpec& this_ = static_cast<ProofSpec&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.leaf_spec_;
  delete this_._impl_.inner_spec_;
  this_._impl_.~Impl_();
}

inline void* ProofSpec::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) ProofSpec(arena);
}
constexpr auto ProofSpec::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(ProofSpec),
                                            alignof(ProofSpec));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull ProofSpec::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_ProofSpec_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &ProofSpec::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<ProofSpec>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &ProofSpec::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<ProofSpec>(), &ProofSpec::ByteSizeLong,
            &ProofSpec::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(ProofSpec, _impl_._cached_size_),
        false,
    },
    &ProofSpec::kDescriptorMethods,
    &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* ProofSpec::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 2, 0, 2> ProofSpec::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ProofSpec, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::cosmos::ics23::v1::ProofSpec>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // int32 min_depth = 4 [json_name = "minDepth"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ProofSpec, _impl_.min_depth_), 63>(),
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(ProofSpec, _impl_.min_depth_)}},
    // .cosmos.ics23.v1.LeafOp leaf_spec = 1 [json_name = "leafSpec"];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(ProofSpec, _impl_.leaf_spec_)}},
    // .cosmos.ics23.v1.InnerSpec inner_spec = 2 [json_name = "innerSpec"];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(ProofSpec, _impl_.inner_spec_)}},
    // int32 max_depth = 3 [json_name = "maxDepth"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ProofSpec, _impl_.max_depth_), 63>(),
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(ProofSpec, _impl_.max_depth_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .cosmos.ics23.v1.LeafOp leaf_spec = 1 [json_name = "leafSpec"];
    {PROTOBUF_FIELD_OFFSET(ProofSpec, _impl_.leaf_spec_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .cosmos.ics23.v1.InnerSpec inner_spec = 2 [json_name = "innerSpec"];
    {PROTOBUF_FIELD_OFFSET(ProofSpec, _impl_.inner_spec_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // int32 max_depth = 3 [json_name = "maxDepth"];
    {PROTOBUF_FIELD_OFFSET(ProofSpec, _impl_.max_depth_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // int32 min_depth = 4 [json_name = "minDepth"];
    {PROTOBUF_FIELD_OFFSET(ProofSpec, _impl_.min_depth_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::cosmos::ics23::v1::LeafOp>()},
    {::_pbi::TcParser::GetTable<::cosmos::ics23::v1::InnerSpec>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void ProofSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.ProofSpec)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.leaf_spec_ != nullptr);
      _impl_.leaf_spec_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.inner_spec_ != nullptr);
      _impl_.inner_spec_->Clear();
    }
  }
  ::memset(&_impl_.max_depth_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.min_depth_) -
      reinterpret_cast<char*>(&_impl_.max_depth_)) + sizeof(_impl_.min_depth_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* ProofSpec::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const ProofSpec& this_ = static_cast<const ProofSpec&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* ProofSpec::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const ProofSpec& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.ProofSpec)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // .cosmos.ics23.v1.LeafOp leaf_spec = 1 [json_name = "leafSpec"];
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.leaf_spec_, this_._impl_.leaf_spec_->GetCachedSize(), target,
                stream);
          }

          // .cosmos.ics23.v1.InnerSpec inner_spec = 2 [json_name = "innerSpec"];
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                2, *this_._impl_.inner_spec_, this_._impl_.inner_spec_->GetCachedSize(), target,
                stream);
          }

          // int32 max_depth = 3 [json_name = "maxDepth"];
          if (this_._internal_max_depth() != 0) {
            target = ::google::protobuf::internal::WireFormatLite::
                WriteInt32ToArrayWithField<3>(
                    stream, this_._internal_max_depth(), target);
          }

          // int32 min_depth = 4 [json_name = "minDepth"];
          if (this_._internal_min_depth() != 0) {
            target = ::google::protobuf::internal::WireFormatLite::
                WriteInt32ToArrayWithField<4>(
                    stream, this_._internal_min_depth(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.ProofSpec)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t ProofSpec::ByteSizeLong(const MessageLite& base) {
          const ProofSpec& this_ = static_cast<const ProofSpec&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t ProofSpec::ByteSizeLong() const {
          const ProofSpec& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.ProofSpec)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000003u) {
            // .cosmos.ics23.v1.LeafOp leaf_spec = 1 [json_name = "leafSpec"];
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.leaf_spec_);
            }
            // .cosmos.ics23.v1.InnerSpec inner_spec = 2 [json_name = "innerSpec"];
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.inner_spec_);
            }
          }
           {
            // int32 max_depth = 3 [json_name = "maxDepth"];
            if (this_._internal_max_depth() != 0) {
              total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
                  this_._internal_max_depth());
            }
            // int32 min_depth = 4 [json_name = "minDepth"];
            if (this_._internal_min_depth() != 0) {
              total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
                  this_._internal_min_depth());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void ProofSpec::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ProofSpec*>(&to_msg);
  auto& from = static_cast<const ProofSpec&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.ProofSpec)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.leaf_spec_ != nullptr);
      if (_this->_impl_.leaf_spec_ == nullptr) {
        _this->_impl_.leaf_spec_ =
            ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::LeafOp>(arena, *from._impl_.leaf_spec_);
      } else {
        _this->_impl_.leaf_spec_->MergeFrom(*from._impl_.leaf_spec_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.inner_spec_ != nullptr);
      if (_this->_impl_.inner_spec_ == nullptr) {
        _this->_impl_.inner_spec_ =
            ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::InnerSpec>(arena, *from._impl_.inner_spec_);
      } else {
        _this->_impl_.inner_spec_->MergeFrom(*from._impl_.inner_spec_);
      }
    }
  }
  if (from._internal_max_depth() != 0) {
    _this->_impl_.max_depth_ = from._impl_.max_depth_;
  }
  if (from._internal_min_depth() != 0) {
    _this->_impl_.min_depth_ = from._impl_.min_depth_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ProofSpec::CopyFrom(const ProofSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.ProofSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ProofSpec::InternalSwap(ProofSpec* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProofSpec, _impl_.min_depth_)
      + sizeof(ProofSpec::_impl_.min_depth_)
      - PROTOBUF_FIELD_OFFSET(ProofSpec, _impl_.leaf_spec_)>(
          reinterpret_cast<char*>(&_impl_.leaf_spec_),
          reinterpret_cast<char*>(&other->_impl_.leaf_spec_));
}

::google::protobuf::Metadata ProofSpec::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class InnerSpec::_Internal {
 public:
};

InnerSpec::InnerSpec(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.InnerSpec)
}
inline PROTOBUF_NDEBUG_INLINE InnerSpec::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::cosmos::ics23::v1::InnerSpec& from_msg)
      : child_order_{visibility, arena, from.child_order_},
        _child_order_cached_byte_size_{0},
        empty_child_(arena, from.empty_child_),
        _cached_size_{0} {}

InnerSpec::InnerSpec(
    ::google::protobuf::Arena* arena,
    const InnerSpec& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  InnerSpec* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, child_size_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, child_size_),
           offsetof(Impl_, hash_) -
               offsetof(Impl_, child_size_) +
               sizeof(Impl_::hash_));

  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.InnerSpec)
}
inline PROTOBUF_NDEBUG_INLINE InnerSpec::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : child_order_{visibility, arena},
        _child_order_cached_byte_size_{0},
        empty_child_(arena),
        _cached_size_{0} {}

inline void InnerSpec::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, child_size_),
           0,
           offsetof(Impl_, hash_) -
               offsetof(Impl_, child_size_) +
               sizeof(Impl_::hash_));
}
InnerSpec::~InnerSpec() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.InnerSpec)
  SharedDtor(*this);
}
inline void InnerSpec::SharedDtor(MessageLite& self) {
  InnerSpec& this_ = static_cast<InnerSpec&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.empty_child_.Destroy();
  this_._impl_.~Impl_();
}

inline void* InnerSpec::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) InnerSpec(arena);
}
constexpr auto InnerSpec::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(InnerSpec, _impl_.child_order_) +
          decltype(InnerSpec::_impl_.child_order_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(InnerSpec), alignof(InnerSpec), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&InnerSpec::PlacementNew_,
                                 sizeof(InnerSpec),
                                 alignof(InnerSpec));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull InnerSpec::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_InnerSpec_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &InnerSpec::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<InnerSpec>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &InnerSpec::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<InnerSpec>(), &InnerSpec::ByteSizeLong,
            &InnerSpec::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(InnerSpec, _impl_._cached_size_),
        false,
    },
    &InnerSpec::kDescriptorMethods,
    &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* InnerSpec::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 0, 0, 2> InnerSpec::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::cosmos::ics23::v1::InnerSpec>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated int32 child_order = 1 [json_name = "childOrder"];
    {::_pbi::TcParser::FastV32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(InnerSpec, _impl_.child_order_)}},
    // int32 child_size = 2 [json_name = "childSize"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(InnerSpec, _impl_.child_size_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(InnerSpec, _impl_.child_size_)}},
    // int32 min_prefix_length = 3 [json_name = "minPrefixLength"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(InnerSpec, _impl_.min_prefix_length_), 63>(),
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(InnerSpec, _impl_.min_prefix_length_)}},
    // int32 max_prefix_length = 4 [json_name = "maxPrefixLength"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(InnerSpec, _impl_.max_prefix_length_), 63>(),
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(InnerSpec, _impl_.max_prefix_length_)}},
    // bytes empty_child = 5 [json_name = "emptyChild"];
    {::_pbi::TcParser::FastBS1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(InnerSpec, _impl_.empty_child_)}},
    // .cosmos.ics23.v1.HashOp hash = 6 [json_name = "hash"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(InnerSpec, _impl_.hash_), 63>(),
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(InnerSpec, _impl_.hash_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated int32 child_order = 1 [json_name = "childOrder"];
    {PROTOBUF_FIELD_OFFSET(InnerSpec, _impl_.child_order_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // int32 child_size = 2 [json_name = "childSize"];
    {PROTOBUF_FIELD_OFFSET(InnerSpec, _impl_.child_size_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // int32 min_prefix_length = 3 [json_name = "minPrefixLength"];
    {PROTOBUF_FIELD_OFFSET(InnerSpec, _impl_.min_prefix_length_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // int32 max_prefix_length = 4 [json_name = "maxPrefixLength"];
    {PROTOBUF_FIELD_OFFSET(InnerSpec, _impl_.max_prefix_length_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // bytes empty_child = 5 [json_name = "emptyChild"];
    {PROTOBUF_FIELD_OFFSET(InnerSpec, _impl_.empty_child_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBytes | ::_fl::kRepAString)},
    // .cosmos.ics23.v1.HashOp hash = 6 [json_name = "hash"];
    {PROTOBUF_FIELD_OFFSET(InnerSpec, _impl_.hash_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void InnerSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.InnerSpec)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.child_order_.Clear();
  _impl_.empty_child_.ClearToEmpty();
  ::memset(&_impl_.child_size_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.hash_) -
      reinterpret_cast<char*>(&_impl_.child_size_)) + sizeof(_impl_.hash_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* InnerSpec::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const InnerSpec& this_ = static_cast<const InnerSpec&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* InnerSpec::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const InnerSpec& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.InnerSpec)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // repeated int32 child_order = 1 [json_name = "childOrder"];
          {
            int byte_size = this_._impl_._child_order_cached_byte_size_.Get();
            if (byte_size > 0) {
              target = stream->WriteInt32Packed(
                  1, this_._internal_child_order(), byte_size, target);
            }
          }

          // int32 child_size = 2 [json_name = "childSize"];
          if (this_._internal_child_size() != 0) {
            target = ::google::protobuf::internal::WireFormatLite::
                WriteInt32ToArrayWithField<2>(
                    stream, this_._internal_child_size(), target);
          }

          // int32 min_prefix_length = 3 [json_name = "minPrefixLength"];
          if (this_._internal_min_prefix_length() != 0) {
            target = ::google::protobuf::internal::WireFormatLite::
                WriteInt32ToArrayWithField<3>(
                    stream, this_._internal_min_prefix_length(), target);
          }

          // int32 max_prefix_length = 4 [json_name = "maxPrefixLength"];
          if (this_._internal_max_prefix_length() != 0) {
            target = ::google::protobuf::internal::WireFormatLite::
                WriteInt32ToArrayWithField<4>(
                    stream, this_._internal_max_prefix_length(), target);
          }

          // bytes empty_child = 5 [json_name = "emptyChild"];
          if (!this_._internal_empty_child().empty()) {
            const std::string& _s = this_._internal_empty_child();
            target = stream->WriteBytesMaybeAliased(5, _s, target);
          }

          // .cosmos.ics23.v1.HashOp hash = 6 [json_name = "hash"];
          if (this_._internal_hash() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                6, this_._internal_hash(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.InnerSpec)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t InnerSpec::ByteSizeLong(const MessageLite& base) {
          const InnerSpec& this_ = static_cast<const InnerSpec&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t InnerSpec::ByteSizeLong() const {
          const InnerSpec& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.InnerSpec)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated int32 child_order = 1 [json_name = "childOrder"];
            {
              total_size +=
                  ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
                      this_._internal_child_order(), 1,
                      this_._impl_._child_order_cached_byte_size_);
            }
          }
           {
            // bytes empty_child = 5 [json_name = "emptyChild"];
            if (!this_._internal_empty_child().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                              this_._internal_empty_child());
            }
            // int32 child_size = 2 [json_name = "childSize"];
            if (this_._internal_child_size() != 0) {
              total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
                  this_._internal_child_size());
            }
            // int32 min_prefix_length = 3 [json_name = "minPrefixLength"];
            if (this_._internal_min_prefix_length() != 0) {
              total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
                  this_._internal_min_prefix_length());
            }
            // int32 max_prefix_length = 4 [json_name = "maxPrefixLength"];
            if (this_._internal_max_prefix_length() != 0) {
              total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
                  this_._internal_max_prefix_length());
            }
            // .cosmos.ics23.v1.HashOp hash = 6 [json_name = "hash"];
            if (this_._internal_hash() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_hash());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void InnerSpec::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<InnerSpec*>(&to_msg);
  auto& from = static_cast<const InnerSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.InnerSpec)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_child_order()->MergeFrom(from._internal_child_order());
  if (!from._internal_empty_child().empty()) {
    _this->_internal_set_empty_child(from._internal_empty_child());
  }
  if (from._internal_child_size() != 0) {
    _this->_impl_.child_size_ = from._impl_.child_size_;
  }
  if (from._internal_min_prefix_length() != 0) {
    _this->_impl_.min_prefix_length_ = from._impl_.min_prefix_length_;
  }
  if (from._internal_max_prefix_length() != 0) {
    _this->_impl_.max_prefix_length_ = from._impl_.max_prefix_length_;
  }
  if (from._internal_hash() != 0) {
    _this->_impl_.hash_ = from._impl_.hash_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void InnerSpec::CopyFrom(const InnerSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.InnerSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void InnerSpec::InternalSwap(InnerSpec* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.child_order_.InternalSwap(&other->_impl_.child_order_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.empty_child_, &other->_impl_.empty_child_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InnerSpec, _impl_.hash_)
      + sizeof(InnerSpec::_impl_.hash_)
      - PROTOBUF_FIELD_OFFSET(InnerSpec, _impl_.child_size_)>(
          reinterpret_cast<char*>(&_impl_.child_size_),
          reinterpret_cast<char*>(&other->_impl_.child_size_));
}

::google::protobuf::Metadata InnerSpec::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class BatchProof::_Internal {
 public:
};

BatchProof::BatchProof(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.BatchProof)
}
inline PROTOBUF_NDEBUG_INLINE BatchProof::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::cosmos::ics23::v1::BatchProof& from_msg)
      : entries_{visibility, arena, from.entries_},
        _cached_size_{0} {}

BatchProof::BatchProof(
    ::google::protobuf::Arena* arena,
    const BatchProof& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  BatchProof* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.BatchProof)
}
inline PROTOBUF_NDEBUG_INLINE BatchProof::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : entries_{visibility, arena},
        _cached_size_{0} {}

inline void BatchProof::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
BatchProof::~BatchProof() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.BatchProof)
  SharedDtor(*this);
}
inline void BatchProof::SharedDtor(MessageLite& self) {
  BatchProof& this_ = static_cast<BatchProof&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* BatchProof::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) BatchProof(arena);
}
constexpr auto BatchProof::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(BatchProof, _impl_.entries_) +
          decltype(BatchProof::_impl_.entries_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(BatchProof), alignof(BatchProof), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&BatchProof::PlacementNew_,
                                 sizeof(BatchProof),
                                 alignof(BatchProof));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull BatchProof::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_BatchProof_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &BatchProof::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<BatchProof>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &BatchProof::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<BatchProof>(), &BatchProof::ByteSizeLong,
            &BatchProof::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(BatchProof, _impl_._cached_size_),
        false,
    },
    &BatchProof::kDescriptorMethods,
    &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* BatchProof::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2> BatchProof::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::cosmos::ics23::v1::BatchProof>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .cosmos.ics23.v1.BatchEntry entries = 1 [json_name = "entries"];
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(BatchProof, _impl_.entries_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .cosmos.ics23.v1.BatchEntry entries = 1 [json_name = "entries"];
    {PROTOBUF_FIELD_OFFSET(BatchProof, _impl_.entries_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::cosmos::ics23::v1::BatchEntry>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void BatchProof::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.BatchProof)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entries_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* BatchProof::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const BatchProof& this_ = static_cast<const BatchProof&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* BatchProof::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const BatchProof& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.BatchProof)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // repeated .cosmos.ics23.v1.BatchEntry entries = 1 [json_name = "entries"];
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_entries_size());
               i < n; i++) {
            const auto& repfield = this_._internal_entries().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    1, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.BatchProof)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t BatchProof::ByteSizeLong(const MessageLite& base) {
          const BatchProof& this_ = static_cast<const BatchProof&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t BatchProof::ByteSizeLong() const {
          const BatchProof& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.BatchProof)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .cosmos.ics23.v1.BatchEntry entries = 1 [json_name = "entries"];
            {
              total_size += 1UL * this_._internal_entries_size();
              for (const auto& msg : this_._internal_entries()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void BatchProof::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<BatchProof*>(&to_msg);
  auto& from = static_cast<const BatchProof&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.BatchProof)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_entries()->MergeFrom(
      from._internal_entries());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void BatchProof::CopyFrom(const BatchProof& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.BatchProof)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void BatchProof::InternalSwap(BatchProof* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.entries_.InternalSwap(&other->_impl_.entries_);
}

::google::protobuf::Metadata BatchProof::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class BatchEntry::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::BatchEntry, _impl_._oneof_case_);
};

void BatchEntry::set_allocated_exist(::cosmos::ics23::v1::ExistenceProof* exist) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_proof();
  if (exist) {
    ::google::protobuf::Arena* submessage_arena = exist->GetArena();
    if (message_arena != submessage_arena) {
      exist = ::google::protobuf::internal::GetOwnedMessage(message_arena, exist, submessage_arena);
    }
    set_has_exist();
    _impl_.proof_.exist_ = exist;
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.BatchEntry.exist)
}
void BatchEntry::set_allocated_nonexist(::cosmos::ics23::v1::NonExistenceProof* nonexist) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_proof();
  if (nonexist) {
    ::google::protobuf::Arena* submessage_arena = nonexist->GetArena();
    if (message_arena != submessage_arena) {
      nonexist = ::google::protobuf::internal::GetOwnedMessage(message_arena, nonexist, submessage_arena);
    }
    set_has_nonexist();
    _impl_.proof_.nonexist_ = nonexist;
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.BatchEntry.nonexist)
}
BatchEntry::BatchEntry(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.BatchEntry)
}
inline PROTOBUF_NDEBUG_INLINE BatchEntry::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::cosmos::ics23::v1::BatchEntry& from_msg)
      : proof_{},
        _cached_size_{0},
        _oneof_case_{from._oneof_case_[0]} {}

BatchEntry::BatchEntry(
    ::google::protobuf::Arena* arena,
    const BatchEntry& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  BatchEntry* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  switch (proof_case()) {
    case PROOF_NOT_SET:
      break;
      case kExist:
        _impl_.proof_.exist_ = ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::ExistenceProof>(arena, *from._impl_.proof_.exist_);
        break;
      case kNonexist:
        _impl_.proof_.nonexist_ = ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::NonExistenceProof>(arena, *from._impl_.proof_.nonexist_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.BatchEntry)
}
inline PROTOBUF_NDEBUG_INLINE BatchEntry::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : proof_{},
        _cached_size_{0},
        _oneof_case_{} {}

inline void BatchEntry::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
BatchEntry::~BatchEntry() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.BatchEntry)
  SharedDtor(*this);
}
inline void BatchEntry::SharedDtor(MessageLite& self) {
  BatchEntry& this_ = static_cast<BatchEntry&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  if (this_.has_proof()) {
    this_.clear_proof();
  }
  this_._impl_.~Impl_();
}

void BatchEntry::clear_proof() {
// @@protoc_insertion_point(one_of_clear_start:cosmos.ics23.v1.BatchEntry)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (proof_case()) {
    case kExist: {
      if (GetArena() == nullptr) {
        delete _impl_.proof_.exist_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.proof_.exist_);
      }
      break;
    }
    case kNonexist: {
      if (GetArena() == nullptr) {
        delete _impl_.proof_.nonexist_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.proof_.nonexist_);
      }
      break;
    }
    case PROOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PROOF_NOT_SET;
}


inline void* BatchEntry::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) BatchEntry(arena);
}
constexpr auto BatchEntry::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(BatchEntry),
                                            alignof(BatchEntry));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull BatchEntry::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_BatchEntry_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &BatchEntry::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<BatchEntry>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &BatchEntry::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<BatchEntry>(), &BatchEntry::ByteSizeLong,
            &BatchEntry::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(BatchEntry, _impl_._cached_size_),
        false,
    },
    &BatchEntry::kDescriptorMethods,
    &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* BatchEntry::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 2, 2, 0, 2> BatchEntry::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::cosmos::ics23::v1::BatchEntry>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .cosmos.ics23.v1.ExistenceProof exist = 1 [json_name = "exist"];
    {PROTOBUF_FIELD_OFFSET(BatchEntry, _impl_.proof_.exist_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .cosmos.ics23.v1.NonExistenceProof nonexist = 2 [json_name = "nonexist"];
    {PROTOBUF_FIELD_OFFSET(BatchEntry, _impl_.proof_.nonexist_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::cosmos::ics23::v1::ExistenceProof>()},
    {::_pbi::TcParser::GetTable<::cosmos::ics23::v1::NonExistenceProof>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void BatchEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.BatchEntry)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_proof();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* BatchEntry::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const BatchEntry& this_ = static_cast<const BatchEntry&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* BatchEntry::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const BatchEntry& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.BatchEntry)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          switch (this_.proof_case()) {
            case kExist: {
              target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                  1, *this_._impl_.proof_.exist_, this_._impl_.proof_.exist_->GetCachedSize(), target,
                  stream);
              break;
            }
            case kNonexist: {
              target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                  2, *this_._impl_.proof_.nonexist_, this_._impl_.proof_.nonexist_->GetCachedSize(), target,
                  stream);
              break;
            }
            default:
              break;
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.BatchEntry)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t BatchEntry::ByteSizeLong(const MessageLite& base) {
          const BatchEntry& this_ = static_cast<const BatchEntry&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t BatchEntry::ByteSizeLong() const {
          const BatchEntry& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.BatchEntry)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          switch (this_.proof_case()) {
            // .cosmos.ics23.v1.ExistenceProof exist = 1 [json_name = "exist"];
            case kExist: {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.proof_.exist_);
              break;
            }
            // .cosmos.ics23.v1.NonExistenceProof nonexist = 2 [json_name = "nonexist"];
            case kNonexist: {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.proof_.nonexist_);
              break;
            }
            case PROOF_NOT_SET: {
              break;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void BatchEntry::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<BatchEntry*>(&to_msg);
  auto& from = static_cast<const BatchEntry&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.BatchEntry)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_proof();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kExist: {
        if (oneof_needs_init) {
          _this->_impl_.proof_.exist_ =
              ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::ExistenceProof>(arena, *from._impl_.proof_.exist_);
        } else {
          _this->_impl_.proof_.exist_->MergeFrom(from._internal_exist());
        }
        break;
      }
      case kNonexist: {
        if (oneof_needs_init) {
          _this->_impl_.proof_.nonexist_ =
              ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::NonExistenceProof>(arena, *from._impl_.proof_.nonexist_);
        } else {
          _this->_impl_.proof_.nonexist_->MergeFrom(from._internal_nonexist());
        }
        break;
      }
      case PROOF_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void BatchEntry::CopyFrom(const BatchEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.BatchEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void BatchEntry::InternalSwap(BatchEntry* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.proof_, other->_impl_.proof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata BatchEntry::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CompressedBatchProof::_Internal {
 public:
};

CompressedBatchProof::CompressedBatchProof(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.CompressedBatchProof)
}
inline PROTOBUF_NDEBUG_INLINE CompressedBatchProof::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::cosmos::ics23::v1::CompressedBatchProof& from_msg)
      : entries_{visibility, arena, from.entries_},
        lookup_inners_{visibility, arena, from.lookup_inners_},
        _cached_size_{0} {}

CompressedBatchProof::CompressedBatchProof(
    ::google::protobuf::Arena* arena,
    const CompressedBatchProof& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CompressedBatchProof* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.CompressedBatchProof)
}
inline PROTOBUF_NDEBUG_INLINE CompressedBatchProof::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : entries_{visibility, arena},
        lookup_inners_{visibility, arena},
        _cached_size_{0} {}

inline void CompressedBatchProof::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
CompressedBatchProof::~CompressedBatchProof() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.CompressedBatchProof)
  SharedDtor(*this);
}
inline void CompressedBatchProof::SharedDtor(MessageLite& self) {
  CompressedBatchProof& this_ = static_cast<CompressedBatchProof&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* CompressedBatchProof::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) CompressedBatchProof(arena);
}
constexpr auto CompressedBatchProof::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(CompressedBatchProof, _impl_.entries_) +
          decltype(CompressedBatchProof::_impl_.entries_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(CompressedBatchProof, _impl_.lookup_inners_) +
          decltype(CompressedBatchProof::_impl_.lookup_inners_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(CompressedBatchProof), alignof(CompressedBatchProof), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&CompressedBatchProof::PlacementNew_,
                                 sizeof(CompressedBatchProof),
                                 alignof(CompressedBatchProof));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull CompressedBatchProof::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_CompressedBatchProof_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &CompressedBatchProof::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<CompressedBatchProof>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &CompressedBatchProof::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<CompressedBatchProof>(), &CompressedBatchProof::ByteSizeLong,
            &CompressedBatchProof::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(CompressedBatchProof, _impl_._cached_size_),
        false,
    },
    &CompressedBatchProof::kDescriptorMethods,
    &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* CompressedBatchProof::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 2, 0, 2> CompressedBatchProof::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::cosmos::ics23::v1::CompressedBatchProof>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .cosmos.ics23.v1.InnerOp lookup_inners = 2 [json_name = "lookupInners"];
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 1, PROTOBUF_FIELD_OFFSET(CompressedBatchProof, _impl_.lookup_inners_)}},
    // repeated .cosmos.ics23.v1.CompressedBatchEntry entries = 1 [json_name = "entries"];
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(CompressedBatchProof, _impl_.entries_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .cosmos.ics23.v1.CompressedBatchEntry entries = 1 [json_name = "entries"];
    {PROTOBUF_FIELD_OFFSET(CompressedBatchProof, _impl_.entries_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .cosmos.ics23.v1.InnerOp lookup_inners = 2 [json_name = "lookupInners"];
    {PROTOBUF_FIELD_OFFSET(CompressedBatchProof, _impl_.lookup_inners_), 0, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::cosmos::ics23::v1::CompressedBatchEntry>()},
    {::_pbi::TcParser::GetTable<::cosmos::ics23::v1::InnerOp>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void CompressedBatchProof::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.CompressedBatchProof)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entries_.Clear();
  _impl_.lookup_inners_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* CompressedBatchProof::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const CompressedBatchProof& this_ = static_cast<const CompressedBatchProof&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* CompressedBatchProof::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const CompressedBatchProof& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.CompressedBatchProof)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // repeated .cosmos.ics23.v1.CompressedBatchEntry entries = 1 [json_name = "entries"];
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_entries_size());
               i < n; i++) {
            const auto& repfield = this_._internal_entries().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    1, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .cosmos.ics23.v1.InnerOp lookup_inners = 2 [json_name = "lookupInners"];
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_lookup_inners_size());
               i < n; i++) {
            const auto& repfield = this_._internal_lookup_inners().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    2, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.CompressedBatchProof)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t CompressedBatchProof::ByteSizeLong(const MessageLite& base) {
          const CompressedBatchProof& this_ = static_cast<const CompressedBatchProof&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t CompressedBatchProof::ByteSizeLong() const {
          const CompressedBatchProof& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.CompressedBatchProof)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .cosmos.ics23.v1.CompressedBatchEntry entries = 1 [json_name = "entries"];
            {
              total_size += 1UL * this_._internal_entries_size();
              for (const auto& msg : this_._internal_entries()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .cosmos.ics23.v1.InnerOp lookup_inners = 2 [json_name = "lookupInners"];
            {
              total_size += 1UL * this_._internal_lookup_inners_size();
              for (const auto& msg : this_._internal_lookup_inners()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void CompressedBatchProof::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<CompressedBatchProof*>(&to_msg);
  auto& from = static_cast<const CompressedBatchProof&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.CompressedBatchProof)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_entries()->MergeFrom(
      from._internal_entries());
  _this->_internal_mutable_lookup_inners()->MergeFrom(
      from._internal_lookup_inners());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CompressedBatchProof::CopyFrom(const CompressedBatchProof& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.CompressedBatchProof)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CompressedBatchProof::InternalSwap(CompressedBatchProof* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.entries_.InternalSwap(&other->_impl_.entries_);
  _impl_.lookup_inners_.InternalSwap(&other->_impl_.lookup_inners_);
}

::google::protobuf::Metadata CompressedBatchProof::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CompressedBatchEntry::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::cosmos::ics23::v1::CompressedBatchEntry, _impl_._oneof_case_);
};

void CompressedBatchEntry::set_allocated_exist(::cosmos::ics23::v1::CompressedExistenceProof* exist) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_proof();
  if (exist) {
    ::google::protobuf::Arena* submessage_arena = exist->GetArena();
    if (message_arena != submessage_arena) {
      exist = ::google::protobuf::internal::GetOwnedMessage(message_arena, exist, submessage_arena);
    }
    set_has_exist();
    _impl_.proof_.exist_ = exist;
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CompressedBatchEntry.exist)
}
void CompressedBatchEntry::set_allocated_nonexist(::cosmos::ics23::v1::CompressedNonExistenceProof* nonexist) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_proof();
  if (nonexist) {
    ::google::protobuf::Arena* submessage_arena = nonexist->GetArena();
    if (message_arena != submessage_arena) {
      nonexist = ::google::protobuf::internal::GetOwnedMessage(message_arena, nonexist, submessage_arena);
    }
    set_has_nonexist();
    _impl_.proof_.nonexist_ = nonexist;
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CompressedBatchEntry.nonexist)
}
CompressedBatchEntry::CompressedBatchEntry(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.CompressedBatchEntry)
}
inline PROTOBUF_NDEBUG_INLINE CompressedBatchEntry::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::cosmos::ics23::v1::CompressedBatchEntry& from_msg)
      : proof_{},
        _cached_size_{0},
        _oneof_case_{from._oneof_case_[0]} {}

CompressedBatchEntry::CompressedBatchEntry(
    ::google::protobuf::Arena* arena,
    const CompressedBatchEntry& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CompressedBatchEntry* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  switch (proof_case()) {
    case PROOF_NOT_SET:
      break;
      case kExist:
        _impl_.proof_.exist_ = ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::CompressedExistenceProof>(arena, *from._impl_.proof_.exist_);
        break;
      case kNonexist:
        _impl_.proof_.nonexist_ = ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::CompressedNonExistenceProof>(arena, *from._impl_.proof_.nonexist_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.CompressedBatchEntry)
}
inline PROTOBUF_NDEBUG_INLINE CompressedBatchEntry::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : proof_{},
        _cached_size_{0},
        _oneof_case_{} {}

inline void CompressedBatchEntry::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
CompressedBatchEntry::~CompressedBatchEntry() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.CompressedBatchEntry)
  SharedDtor(*this);
}
inline void CompressedBatchEntry::SharedDtor(MessageLite& self) {
  CompressedBatchEntry& this_ = static_cast<CompressedBatchEntry&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  if (this_.has_proof()) {
    this_.clear_proof();
  }
  this_._impl_.~Impl_();
}

void CompressedBatchEntry::clear_proof() {
// @@protoc_insertion_point(one_of_clear_start:cosmos.ics23.v1.CompressedBatchEntry)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (proof_case()) {
    case kExist: {
      if (GetArena() == nullptr) {
        delete _impl_.proof_.exist_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.proof_.exist_);
      }
      break;
    }
    case kNonexist: {
      if (GetArena() == nullptr) {
        delete _impl_.proof_.nonexist_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.proof_.nonexist_);
      }
      break;
    }
    case PROOF_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PROOF_NOT_SET;
}


inline void* CompressedBatchEntry::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) CompressedBatchEntry(arena);
}
constexpr auto CompressedBatchEntry::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(CompressedBatchEntry),
                                            alignof(CompressedBatchEntry));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull CompressedBatchEntry::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_CompressedBatchEntry_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &CompressedBatchEntry::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<CompressedBatchEntry>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &CompressedBatchEntry::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<CompressedBatchEntry>(), &CompressedBatchEntry::ByteSizeLong,
            &CompressedBatchEntry::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(CompressedBatchEntry, _impl_._cached_size_),
        false,
    },
    &CompressedBatchEntry::kDescriptorMethods,
    &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* CompressedBatchEntry::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 2, 2, 0, 2> CompressedBatchEntry::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::cosmos::ics23::v1::CompressedBatchEntry>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .cosmos.ics23.v1.CompressedExistenceProof exist = 1 [json_name = "exist"];
    {PROTOBUF_FIELD_OFFSET(CompressedBatchEntry, _impl_.proof_.exist_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .cosmos.ics23.v1.CompressedNonExistenceProof nonexist = 2 [json_name = "nonexist"];
    {PROTOBUF_FIELD_OFFSET(CompressedBatchEntry, _impl_.proof_.nonexist_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::cosmos::ics23::v1::CompressedExistenceProof>()},
    {::_pbi::TcParser::GetTable<::cosmos::ics23::v1::CompressedNonExistenceProof>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void CompressedBatchEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.CompressedBatchEntry)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_proof();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* CompressedBatchEntry::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const CompressedBatchEntry& this_ = static_cast<const CompressedBatchEntry&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* CompressedBatchEntry::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const CompressedBatchEntry& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.CompressedBatchEntry)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          switch (this_.proof_case()) {
            case kExist: {
              target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                  1, *this_._impl_.proof_.exist_, this_._impl_.proof_.exist_->GetCachedSize(), target,
                  stream);
              break;
            }
            case kNonexist: {
              target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                  2, *this_._impl_.proof_.nonexist_, this_._impl_.proof_.nonexist_->GetCachedSize(), target,
                  stream);
              break;
            }
            default:
              break;
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.CompressedBatchEntry)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t CompressedBatchEntry::ByteSizeLong(const MessageLite& base) {
          const CompressedBatchEntry& this_ = static_cast<const CompressedBatchEntry&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t CompressedBatchEntry::ByteSizeLong() const {
          const CompressedBatchEntry& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.CompressedBatchEntry)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          switch (this_.proof_case()) {
            // .cosmos.ics23.v1.CompressedExistenceProof exist = 1 [json_name = "exist"];
            case kExist: {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.proof_.exist_);
              break;
            }
            // .cosmos.ics23.v1.CompressedNonExistenceProof nonexist = 2 [json_name = "nonexist"];
            case kNonexist: {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.proof_.nonexist_);
              break;
            }
            case PROOF_NOT_SET: {
              break;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void CompressedBatchEntry::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<CompressedBatchEntry*>(&to_msg);
  auto& from = static_cast<const CompressedBatchEntry&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.CompressedBatchEntry)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_proof();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kExist: {
        if (oneof_needs_init) {
          _this->_impl_.proof_.exist_ =
              ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::CompressedExistenceProof>(arena, *from._impl_.proof_.exist_);
        } else {
          _this->_impl_.proof_.exist_->MergeFrom(from._internal_exist());
        }
        break;
      }
      case kNonexist: {
        if (oneof_needs_init) {
          _this->_impl_.proof_.nonexist_ =
              ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::CompressedNonExistenceProof>(arena, *from._impl_.proof_.nonexist_);
        } else {
          _this->_impl_.proof_.nonexist_->MergeFrom(from._internal_nonexist());
        }
        break;
      }
      case PROOF_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CompressedBatchEntry::CopyFrom(const CompressedBatchEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.CompressedBatchEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CompressedBatchEntry::InternalSwap(CompressedBatchEntry* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.proof_, other->_impl_.proof_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata CompressedBatchEntry::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CompressedExistenceProof::_Internal {
 public:
  using HasBits =
      decltype(std::declval<CompressedExistenceProof>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CompressedExistenceProof, _impl_._has_bits_);
};

CompressedExistenceProof::CompressedExistenceProof(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.CompressedExistenceProof)
}
inline PROTOBUF_NDEBUG_INLINE CompressedExistenceProof::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::cosmos::ics23::v1::CompressedExistenceProof& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        path_{visibility, arena, from.path_},
        _path_cached_byte_size_{0},
        key_(arena, from.key_),
        value_(arena, from.value_) {}

CompressedExistenceProof::CompressedExistenceProof(
    ::google::protobuf::Arena* arena,
    const CompressedExistenceProof& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CompressedExistenceProof* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.leaf_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::LeafOp>(
                              arena, *from._impl_.leaf_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.CompressedExistenceProof)
}
inline PROTOBUF_NDEBUG_INLINE CompressedExistenceProof::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        path_{visibility, arena},
        _path_cached_byte_size_{0},
        key_(arena),
        value_(arena) {}

inline void CompressedExistenceProof::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.leaf_ = {};
}
CompressedExistenceProof::~CompressedExistenceProof() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.CompressedExistenceProof)
  SharedDtor(*this);
}
inline void CompressedExistenceProof::SharedDtor(MessageLite& self) {
  CompressedExistenceProof& this_ = static_cast<CompressedExistenceProof&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.key_.Destroy();
  this_._impl_.value_.Destroy();
  delete this_._impl_.leaf_;
  this_._impl_.~Impl_();
}

inline void* CompressedExistenceProof::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) CompressedExistenceProof(arena);
}
constexpr auto CompressedExistenceProof::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(CompressedExistenceProof, _impl_.path_) +
          decltype(CompressedExistenceProof::_impl_.path_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(CompressedExistenceProof), alignof(CompressedExistenceProof), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&CompressedExistenceProof::PlacementNew_,
                                 sizeof(CompressedExistenceProof),
                                 alignof(CompressedExistenceProof));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull CompressedExistenceProof::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_CompressedExistenceProof_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &CompressedExistenceProof::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<CompressedExistenceProof>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &CompressedExistenceProof::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<CompressedExistenceProof>(), &CompressedExistenceProof::ByteSizeLong,
            &CompressedExistenceProof::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(CompressedExistenceProof, _impl_._cached_size_),
        false,
    },
    &CompressedExistenceProof::kDescriptorMethods,
    &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* CompressedExistenceProof::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 0, 2> CompressedExistenceProof::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CompressedExistenceProof, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::cosmos::ics23::v1::CompressedExistenceProof>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated int32 path = 4 [json_name = "path"];
    {::_pbi::TcParser::FastV32P1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(CompressedExistenceProof, _impl_.path_)}},
    // bytes key = 1 [json_name = "key"];
    {::_pbi::TcParser::FastBS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(CompressedExistenceProof, _impl_.key_)}},
    // bytes value = 2 [json_name = "value"];
    {::_pbi::TcParser::FastBS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(CompressedExistenceProof, _impl_.value_)}},
    // .cosmos.ics23.v1.LeafOp leaf = 3 [json_name = "leaf"];
    {::_pbi::TcParser::FastMtS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(CompressedExistenceProof, _impl_.leaf_)}},
  }}, {{
    65535, 65535
  }}, {{
    // bytes key = 1 [json_name = "key"];
    {PROTOBUF_FIELD_OFFSET(CompressedExistenceProof, _impl_.key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBytes | ::_fl::kRepAString)},
    // bytes value = 2 [json_name = "value"];
    {PROTOBUF_FIELD_OFFSET(CompressedExistenceProof, _impl_.value_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBytes | ::_fl::kRepAString)},
    // .cosmos.ics23.v1.LeafOp leaf = 3 [json_name = "leaf"];
    {PROTOBUF_FIELD_OFFSET(CompressedExistenceProof, _impl_.leaf_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated int32 path = 4 [json_name = "path"];
    {PROTOBUF_FIELD_OFFSET(CompressedExistenceProof, _impl_.path_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::cosmos::ics23::v1::LeafOp>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void CompressedExistenceProof::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.CompressedExistenceProof)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.path_.Clear();
  _impl_.key_.ClearToEmpty();
  _impl_.value_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.leaf_ != nullptr);
    _impl_.leaf_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* CompressedExistenceProof::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const CompressedExistenceProof& this_ = static_cast<const CompressedExistenceProof&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* CompressedExistenceProof::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const CompressedExistenceProof& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.CompressedExistenceProof)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // bytes key = 1 [json_name = "key"];
          if (!this_._internal_key().empty()) {
            const std::string& _s = this_._internal_key();
            target = stream->WriteBytesMaybeAliased(1, _s, target);
          }

          // bytes value = 2 [json_name = "value"];
          if (!this_._internal_value().empty()) {
            const std::string& _s = this_._internal_value();
            target = stream->WriteBytesMaybeAliased(2, _s, target);
          }

          cached_has_bits = this_._impl_._has_bits_[0];
          // .cosmos.ics23.v1.LeafOp leaf = 3 [json_name = "leaf"];
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                3, *this_._impl_.leaf_, this_._impl_.leaf_->GetCachedSize(), target,
                stream);
          }

          // repeated int32 path = 4 [json_name = "path"];
          {
            int byte_size = this_._impl_._path_cached_byte_size_.Get();
            if (byte_size > 0) {
              target = stream->WriteInt32Packed(
                  4, this_._internal_path(), byte_size, target);
            }
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.CompressedExistenceProof)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t CompressedExistenceProof::ByteSizeLong(const MessageLite& base) {
          const CompressedExistenceProof& this_ = static_cast<const CompressedExistenceProof&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t CompressedExistenceProof::ByteSizeLong() const {
          const CompressedExistenceProof& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.CompressedExistenceProof)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated int32 path = 4 [json_name = "path"];
            {
              total_size +=
                  ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
                      this_._internal_path(), 1,
                      this_._impl_._path_cached_byte_size_);
            }
          }
           {
            // bytes key = 1 [json_name = "key"];
            if (!this_._internal_key().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                              this_._internal_key());
            }
            // bytes value = 2 [json_name = "value"];
            if (!this_._internal_value().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                              this_._internal_value());
            }
          }
           {
            // .cosmos.ics23.v1.LeafOp leaf = 3 [json_name = "leaf"];
            cached_has_bits = this_._impl_._has_bits_[0];
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.leaf_);
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void CompressedExistenceProof::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<CompressedExistenceProof*>(&to_msg);
  auto& from = static_cast<const CompressedExistenceProof&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.CompressedExistenceProof)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_path()->MergeFrom(from._internal_path());
  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(from._impl_.leaf_ != nullptr);
    if (_this->_impl_.leaf_ == nullptr) {
      _this->_impl_.leaf_ =
          ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::LeafOp>(arena, *from._impl_.leaf_);
    } else {
      _this->_impl_.leaf_->MergeFrom(*from._impl_.leaf_);
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CompressedExistenceProof::CopyFrom(const CompressedExistenceProof& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.CompressedExistenceProof)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CompressedExistenceProof::InternalSwap(CompressedExistenceProof* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.path_.InternalSwap(&other->_impl_.path_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_, &other->_impl_.key_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.value_, &other->_impl_.value_, arena);
  swap(_impl_.leaf_, other->_impl_.leaf_);
}

::google::protobuf::Metadata CompressedExistenceProof::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CompressedNonExistenceProof::_Internal {
 public:
  using HasBits =
      decltype(std::declval<CompressedNonExistenceProof>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CompressedNonExistenceProof, _impl_._has_bits_);
};

CompressedNonExistenceProof::CompressedNonExistenceProof(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:cosmos.ics23.v1.CompressedNonExistenceProof)
}
inline PROTOBUF_NDEBUG_INLINE CompressedNonExistenceProof::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::cosmos::ics23::v1::CompressedNonExistenceProof& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        key_(arena, from.key_) {}

CompressedNonExistenceProof::CompressedNonExistenceProof(
    ::google::protobuf::Arena* arena,
    const CompressedNonExistenceProof& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CompressedNonExistenceProof* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.left_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::CompressedExistenceProof>(
                              arena, *from._impl_.left_)
                        : nullptr;
  _impl_.right_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::CompressedExistenceProof>(
                              arena, *from._impl_.right_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:cosmos.ics23.v1.CompressedNonExistenceProof)
}
inline PROTOBUF_NDEBUG_INLINE CompressedNonExistenceProof::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        key_(arena) {}

inline void CompressedNonExistenceProof::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, left_),
           0,
           offsetof(Impl_, right_) -
               offsetof(Impl_, left_) +
               sizeof(Impl_::right_));
}
CompressedNonExistenceProof::~CompressedNonExistenceProof() {
  // @@protoc_insertion_point(destructor:cosmos.ics23.v1.CompressedNonExistenceProof)
  SharedDtor(*this);
}
inline void CompressedNonExistenceProof::SharedDtor(MessageLite& self) {
  CompressedNonExistenceProof& this_ = static_cast<CompressedNonExistenceProof&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.key_.Destroy();
  delete this_._impl_.left_;
  delete this_._impl_.right_;
  this_._impl_.~Impl_();
}

inline void* CompressedNonExistenceProof::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) CompressedNonExistenceProof(arena);
}
constexpr auto CompressedNonExistenceProof::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(CompressedNonExistenceProof),
                                            alignof(CompressedNonExistenceProof));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull CompressedNonExistenceProof::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_CompressedNonExistenceProof_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &CompressedNonExistenceProof::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<CompressedNonExistenceProof>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &CompressedNonExistenceProof::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<CompressedNonExistenceProof>(), &CompressedNonExistenceProof::ByteSizeLong,
            &CompressedNonExistenceProof::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(CompressedNonExistenceProof, _impl_._cached_size_),
        false,
    },
    &CompressedNonExistenceProof::kDescriptorMethods,
    &descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* CompressedNonExistenceProof::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 2, 0, 2> CompressedNonExistenceProof::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CompressedNonExistenceProof, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::cosmos::ics23::v1::CompressedNonExistenceProof>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // bytes key = 1 [json_name = "key"];
    {::_pbi::TcParser::FastBS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(CompressedNonExistenceProof, _impl_.key_)}},
    // .cosmos.ics23.v1.CompressedExistenceProof left = 2 [json_name = "left"];
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(CompressedNonExistenceProof, _impl_.left_)}},
    // .cosmos.ics23.v1.CompressedExistenceProof right = 3 [json_name = "right"];
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 1, PROTOBUF_FIELD_OFFSET(CompressedNonExistenceProof, _impl_.right_)}},
  }}, {{
    65535, 65535
  }}, {{
    // bytes key = 1 [json_name = "key"];
    {PROTOBUF_FIELD_OFFSET(CompressedNonExistenceProof, _impl_.key_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBytes | ::_fl::kRepAString)},
    // .cosmos.ics23.v1.CompressedExistenceProof left = 2 [json_name = "left"];
    {PROTOBUF_FIELD_OFFSET(CompressedNonExistenceProof, _impl_.left_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .cosmos.ics23.v1.CompressedExistenceProof right = 3 [json_name = "right"];
    {PROTOBUF_FIELD_OFFSET(CompressedNonExistenceProof, _impl_.right_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::cosmos::ics23::v1::CompressedExistenceProof>()},
    {::_pbi::TcParser::GetTable<::cosmos::ics23::v1::CompressedExistenceProof>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void CompressedNonExistenceProof::Clear() {
// @@protoc_insertion_point(message_clear_start:cosmos.ics23.v1.CompressedNonExistenceProof)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.left_ != nullptr);
      _impl_.left_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.right_ != nullptr);
      _impl_.right_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* CompressedNonExistenceProof::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const CompressedNonExistenceProof& this_ = static_cast<const CompressedNonExistenceProof&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* CompressedNonExistenceProof::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const CompressedNonExistenceProof& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:cosmos.ics23.v1.CompressedNonExistenceProof)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // bytes key = 1 [json_name = "key"];
          if (!this_._internal_key().empty()) {
            const std::string& _s = this_._internal_key();
            target = stream->WriteBytesMaybeAliased(1, _s, target);
          }

          cached_has_bits = this_._impl_._has_bits_[0];
          // .cosmos.ics23.v1.CompressedExistenceProof left = 2 [json_name = "left"];
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                2, *this_._impl_.left_, this_._impl_.left_->GetCachedSize(), target,
                stream);
          }

          // .cosmos.ics23.v1.CompressedExistenceProof right = 3 [json_name = "right"];
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                3, *this_._impl_.right_, this_._impl_.right_->GetCachedSize(), target,
                stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:cosmos.ics23.v1.CompressedNonExistenceProof)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t CompressedNonExistenceProof::ByteSizeLong(const MessageLite& base) {
          const CompressedNonExistenceProof& this_ = static_cast<const CompressedNonExistenceProof&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t CompressedNonExistenceProof::ByteSizeLong() const {
          const CompressedNonExistenceProof& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:cosmos.ics23.v1.CompressedNonExistenceProof)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // bytes key = 1 [json_name = "key"];
            if (!this_._internal_key().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                              this_._internal_key());
            }
          }
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000003u) {
            // .cosmos.ics23.v1.CompressedExistenceProof left = 2 [json_name = "left"];
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.left_);
            }
            // .cosmos.ics23.v1.CompressedExistenceProof right = 3 [json_name = "right"];
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.right_);
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void CompressedNonExistenceProof::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<CompressedNonExistenceProof*>(&to_msg);
  auto& from = static_cast<const CompressedNonExistenceProof&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:cosmos.ics23.v1.CompressedNonExistenceProof)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.left_ != nullptr);
      if (_this->_impl_.left_ == nullptr) {
        _this->_impl_.left_ =
            ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::CompressedExistenceProof>(arena, *from._impl_.left_);
      } else {
        _this->_impl_.left_->MergeFrom(*from._impl_.left_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.right_ != nullptr);
      if (_this->_impl_.right_ == nullptr) {
        _this->_impl_.right_ =
            ::google::protobuf::Message::CopyConstruct<::cosmos::ics23::v1::CompressedExistenceProof>(arena, *from._impl_.right_);
      } else {
        _this->_impl_.right_->MergeFrom(*from._impl_.right_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CompressedNonExistenceProof::CopyFrom(const CompressedNonExistenceProof& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cosmos.ics23.v1.CompressedNonExistenceProof)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CompressedNonExistenceProof::InternalSwap(CompressedNonExistenceProof* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_, &other->_impl_.key_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CompressedNonExistenceProof, _impl_.right_)
      + sizeof(CompressedNonExistenceProof::_impl_.right_)
      - PROTOBUF_FIELD_OFFSET(CompressedNonExistenceProof, _impl_.left_)>(
          reinterpret_cast<char*>(&_impl_.left_),
          reinterpret_cast<char*>(&other->_impl_.left_));
}

::google::protobuf::Metadata CompressedNonExistenceProof::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace ics23
}  // namespace cosmos
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::std::false_type
    _static_init2_ PROTOBUF_UNUSED =
        (::_pbi::AddDescriptors(&descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto),
         ::std::false_type{});
#include "google/protobuf/port_undef.inc"
