// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: cosmos/ics23/v1/proofs.proto
// Protobuf C++ Version: 5.29.4

#ifndef cosmos_2fics23_2fv1_2fproofs_2eproto_2epb_2eh
#define cosmos_2fics23_2fv1_2fproofs_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029004
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_cosmos_2fics23_2fv1_2fproofs_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_cosmos_2fics23_2fv1_2fproofs_2eproto;
namespace cosmos {
namespace ics23 {
namespace v1 {
class BatchEntry;
struct BatchEntryDefaultTypeInternal;
extern BatchEntryDefaultTypeInternal _BatchEntry_default_instance_;
class BatchProof;
struct BatchProofDefaultTypeInternal;
extern BatchProofDefaultTypeInternal _BatchProof_default_instance_;
class CommitmentProof;
struct CommitmentProofDefaultTypeInternal;
extern CommitmentProofDefaultTypeInternal _CommitmentProof_default_instance_;
class CompressedBatchEntry;
struct CompressedBatchEntryDefaultTypeInternal;
extern CompressedBatchEntryDefaultTypeInternal _CompressedBatchEntry_default_instance_;
class CompressedBatchProof;
struct CompressedBatchProofDefaultTypeInternal;
extern CompressedBatchProofDefaultTypeInternal _CompressedBatchProof_default_instance_;
class CompressedExistenceProof;
struct CompressedExistenceProofDefaultTypeInternal;
extern CompressedExistenceProofDefaultTypeInternal _CompressedExistenceProof_default_instance_;
class CompressedNonExistenceProof;
struct CompressedNonExistenceProofDefaultTypeInternal;
extern CompressedNonExistenceProofDefaultTypeInternal _CompressedNonExistenceProof_default_instance_;
class ExistenceProof;
struct ExistenceProofDefaultTypeInternal;
extern ExistenceProofDefaultTypeInternal _ExistenceProof_default_instance_;
class InnerOp;
struct InnerOpDefaultTypeInternal;
extern InnerOpDefaultTypeInternal _InnerOp_default_instance_;
class InnerSpec;
struct InnerSpecDefaultTypeInternal;
extern InnerSpecDefaultTypeInternal _InnerSpec_default_instance_;
class LeafOp;
struct LeafOpDefaultTypeInternal;
extern LeafOpDefaultTypeInternal _LeafOp_default_instance_;
class NonExistenceProof;
struct NonExistenceProofDefaultTypeInternal;
extern NonExistenceProofDefaultTypeInternal _NonExistenceProof_default_instance_;
class ProofSpec;
struct ProofSpecDefaultTypeInternal;
extern ProofSpecDefaultTypeInternal _ProofSpec_default_instance_;
}  // namespace v1
}  // namespace ics23
}  // namespace cosmos
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace cosmos {
namespace ics23 {
namespace v1 {
enum HashOp : int {
  NO_HASH = 0,
  SHA256 = 1,
  SHA512 = 2,
  KECCAK = 3,
  RIPEMD160 = 4,
  BITCOIN = 5,
  SHA512_256 = 6,
  HashOp_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  HashOp_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool HashOp_IsValid(int value);
extern const uint32_t HashOp_internal_data_[];
constexpr HashOp HashOp_MIN = static_cast<HashOp>(0);
constexpr HashOp HashOp_MAX = static_cast<HashOp>(6);
constexpr int HashOp_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
HashOp_descriptor();
template <typename T>
const std::string& HashOp_Name(T value) {
  static_assert(std::is_same<T, HashOp>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to HashOp_Name().");
  return HashOp_Name(static_cast<HashOp>(value));
}
template <>
inline const std::string& HashOp_Name(HashOp value) {
  return ::google::protobuf::internal::NameOfDenseEnum<HashOp_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool HashOp_Parse(absl::string_view name, HashOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HashOp>(
      HashOp_descriptor(), name, value);
}
enum LengthOp : int {
  NO_PREFIX = 0,
  VAR_PROTO = 1,
  VAR_RLP = 2,
  FIXED32_BIG = 3,
  FIXED32_LITTLE = 4,
  FIXED64_BIG = 5,
  FIXED64_LITTLE = 6,
  REQUIRE_32_BYTES = 7,
  REQUIRE_64_BYTES = 8,
  LengthOp_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LengthOp_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LengthOp_IsValid(int value);
extern const uint32_t LengthOp_internal_data_[];
constexpr LengthOp LengthOp_MIN = static_cast<LengthOp>(0);
constexpr LengthOp LengthOp_MAX = static_cast<LengthOp>(8);
constexpr int LengthOp_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
LengthOp_descriptor();
template <typename T>
const std::string& LengthOp_Name(T value) {
  static_assert(std::is_same<T, LengthOp>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LengthOp_Name().");
  return LengthOp_Name(static_cast<LengthOp>(value));
}
template <>
inline const std::string& LengthOp_Name(LengthOp value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LengthOp_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool LengthOp_Parse(absl::string_view name, LengthOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LengthOp>(
      LengthOp_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class LeafOp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.LeafOp) */ {
 public:
  inline LeafOp() : LeafOp(nullptr) {}
  ~LeafOp() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LeafOp* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LeafOp));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LeafOp(
      ::google::protobuf::internal::ConstantInitialized);

  inline LeafOp(const LeafOp& from) : LeafOp(nullptr, from) {}
  inline LeafOp(LeafOp&& from) noexcept
      : LeafOp(nullptr, std::move(from)) {}
  inline LeafOp& operator=(const LeafOp& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeafOp& operator=(LeafOp&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeafOp& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeafOp* internal_default_instance() {
    return reinterpret_cast<const LeafOp*>(
        &_LeafOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(LeafOp& a, LeafOp& b) { a.Swap(&b); }
  inline void Swap(LeafOp* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeafOp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeafOp* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LeafOp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LeafOp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LeafOp& from) { LeafOp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LeafOp* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.ics23.v1.LeafOp"; }

 protected:
  explicit LeafOp(::google::protobuf::Arena* arena);
  LeafOp(::google::protobuf::Arena* arena, const LeafOp& from);
  LeafOp(::google::protobuf::Arena* arena, LeafOp&& from) noexcept
      : LeafOp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPrefixFieldNumber = 5,
    kHashFieldNumber = 1,
    kPrehashKeyFieldNumber = 2,
    kPrehashValueFieldNumber = 3,
    kLengthFieldNumber = 4,
  };
  // bytes prefix = 5 [json_name = "prefix"];
  void clear_prefix() ;
  const std::string& prefix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_prefix(Arg_&& arg, Args_... args);
  std::string* mutable_prefix();
  PROTOBUF_NODISCARD std::string* release_prefix();
  void set_allocated_prefix(std::string* value);

  private:
  const std::string& _internal_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(
      const std::string& value);
  std::string* _internal_mutable_prefix();

  public:
  // .cosmos.ics23.v1.HashOp hash = 1 [json_name = "hash"];
  void clear_hash() ;
  ::cosmos::ics23::v1::HashOp hash() const;
  void set_hash(::cosmos::ics23::v1::HashOp value);

  private:
  ::cosmos::ics23::v1::HashOp _internal_hash() const;
  void _internal_set_hash(::cosmos::ics23::v1::HashOp value);

  public:
  // .cosmos.ics23.v1.HashOp prehash_key = 2 [json_name = "prehashKey"];
  void clear_prehash_key() ;
  ::cosmos::ics23::v1::HashOp prehash_key() const;
  void set_prehash_key(::cosmos::ics23::v1::HashOp value);

  private:
  ::cosmos::ics23::v1::HashOp _internal_prehash_key() const;
  void _internal_set_prehash_key(::cosmos::ics23::v1::HashOp value);

  public:
  // .cosmos.ics23.v1.HashOp prehash_value = 3 [json_name = "prehashValue"];
  void clear_prehash_value() ;
  ::cosmos::ics23::v1::HashOp prehash_value() const;
  void set_prehash_value(::cosmos::ics23::v1::HashOp value);

  private:
  ::cosmos::ics23::v1::HashOp _internal_prehash_value() const;
  void _internal_set_prehash_value(::cosmos::ics23::v1::HashOp value);

  public:
  // .cosmos.ics23.v1.LengthOp length = 4 [json_name = "length"];
  void clear_length() ;
  ::cosmos::ics23::v1::LengthOp length() const;
  void set_length(::cosmos::ics23::v1::LengthOp value);

  private:
  ::cosmos::ics23::v1::LengthOp _internal_length() const;
  void _internal_set_length(::cosmos::ics23::v1::LengthOp value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.LeafOp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LeafOp& from_msg);
    ::google::protobuf::internal::ArenaStringPtr prefix_;
    int hash_;
    int prehash_key_;
    int prehash_value_;
    int length_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};
// -------------------------------------------------------------------

class InnerSpec final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.InnerSpec) */ {
 public:
  inline InnerSpec() : InnerSpec(nullptr) {}
  ~InnerSpec() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InnerSpec* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InnerSpec));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InnerSpec(
      ::google::protobuf::internal::ConstantInitialized);

  inline InnerSpec(const InnerSpec& from) : InnerSpec(nullptr, from) {}
  inline InnerSpec(InnerSpec&& from) noexcept
      : InnerSpec(nullptr, std::move(from)) {}
  inline InnerSpec& operator=(const InnerSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline InnerSpec& operator=(InnerSpec&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InnerSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const InnerSpec* internal_default_instance() {
    return reinterpret_cast<const InnerSpec*>(
        &_InnerSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(InnerSpec& a, InnerSpec& b) { a.Swap(&b); }
  inline void Swap(InnerSpec* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InnerSpec* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InnerSpec* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InnerSpec>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InnerSpec& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InnerSpec& from) { InnerSpec::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InnerSpec* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.ics23.v1.InnerSpec"; }

 protected:
  explicit InnerSpec(::google::protobuf::Arena* arena);
  InnerSpec(::google::protobuf::Arena* arena, const InnerSpec& from);
  InnerSpec(::google::protobuf::Arena* arena, InnerSpec&& from) noexcept
      : InnerSpec(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChildOrderFieldNumber = 1,
    kEmptyChildFieldNumber = 5,
    kChildSizeFieldNumber = 2,
    kMinPrefixLengthFieldNumber = 3,
    kMaxPrefixLengthFieldNumber = 4,
    kHashFieldNumber = 6,
  };
  // repeated int32 child_order = 1 [json_name = "childOrder"];
  int child_order_size() const;
  private:
  int _internal_child_order_size() const;

  public:
  void clear_child_order() ;
  ::int32_t child_order(int index) const;
  void set_child_order(int index, ::int32_t value);
  void add_child_order(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& child_order() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_child_order();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_child_order() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_child_order();

  public:
  // bytes empty_child = 5 [json_name = "emptyChild"];
  void clear_empty_child() ;
  const std::string& empty_child() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_empty_child(Arg_&& arg, Args_... args);
  std::string* mutable_empty_child();
  PROTOBUF_NODISCARD std::string* release_empty_child();
  void set_allocated_empty_child(std::string* value);

  private:
  const std::string& _internal_empty_child() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_empty_child(
      const std::string& value);
  std::string* _internal_mutable_empty_child();

  public:
  // int32 child_size = 2 [json_name = "childSize"];
  void clear_child_size() ;
  ::int32_t child_size() const;
  void set_child_size(::int32_t value);

  private:
  ::int32_t _internal_child_size() const;
  void _internal_set_child_size(::int32_t value);

  public:
  // int32 min_prefix_length = 3 [json_name = "minPrefixLength"];
  void clear_min_prefix_length() ;
  ::int32_t min_prefix_length() const;
  void set_min_prefix_length(::int32_t value);

  private:
  ::int32_t _internal_min_prefix_length() const;
  void _internal_set_min_prefix_length(::int32_t value);

  public:
  // int32 max_prefix_length = 4 [json_name = "maxPrefixLength"];
  void clear_max_prefix_length() ;
  ::int32_t max_prefix_length() const;
  void set_max_prefix_length(::int32_t value);

  private:
  ::int32_t _internal_max_prefix_length() const;
  void _internal_set_max_prefix_length(::int32_t value);

  public:
  // .cosmos.ics23.v1.HashOp hash = 6 [json_name = "hash"];
  void clear_hash() ;
  ::cosmos::ics23::v1::HashOp hash() const;
  void set_hash(::cosmos::ics23::v1::HashOp value);

  private:
  ::cosmos::ics23::v1::HashOp _internal_hash() const;
  void _internal_set_hash(::cosmos::ics23::v1::HashOp value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.InnerSpec)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InnerSpec& from_msg);
    ::google::protobuf::RepeatedField<::int32_t> child_order_;
    ::google::protobuf::internal::CachedSize _child_order_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr empty_child_;
    ::int32_t child_size_;
    ::int32_t min_prefix_length_;
    ::int32_t max_prefix_length_;
    int hash_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};
// -------------------------------------------------------------------

class InnerOp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.InnerOp) */ {
 public:
  inline InnerOp() : InnerOp(nullptr) {}
  ~InnerOp() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InnerOp* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InnerOp));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InnerOp(
      ::google::protobuf::internal::ConstantInitialized);

  inline InnerOp(const InnerOp& from) : InnerOp(nullptr, from) {}
  inline InnerOp(InnerOp&& from) noexcept
      : InnerOp(nullptr, std::move(from)) {}
  inline InnerOp& operator=(const InnerOp& from) {
    CopyFrom(from);
    return *this;
  }
  inline InnerOp& operator=(InnerOp&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InnerOp& default_instance() {
    return *internal_default_instance();
  }
  static inline const InnerOp* internal_default_instance() {
    return reinterpret_cast<const InnerOp*>(
        &_InnerOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(InnerOp& a, InnerOp& b) { a.Swap(&b); }
  inline void Swap(InnerOp* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InnerOp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InnerOp* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InnerOp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InnerOp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InnerOp& from) { InnerOp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InnerOp* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.ics23.v1.InnerOp"; }

 protected:
  explicit InnerOp(::google::protobuf::Arena* arena);
  InnerOp(::google::protobuf::Arena* arena, const InnerOp& from);
  InnerOp(::google::protobuf::Arena* arena, InnerOp&& from) noexcept
      : InnerOp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPrefixFieldNumber = 2,
    kSuffixFieldNumber = 3,
    kHashFieldNumber = 1,
  };
  // bytes prefix = 2 [json_name = "prefix"];
  void clear_prefix() ;
  const std::string& prefix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_prefix(Arg_&& arg, Args_... args);
  std::string* mutable_prefix();
  PROTOBUF_NODISCARD std::string* release_prefix();
  void set_allocated_prefix(std::string* value);

  private:
  const std::string& _internal_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(
      const std::string& value);
  std::string* _internal_mutable_prefix();

  public:
  // bytes suffix = 3 [json_name = "suffix"];
  void clear_suffix() ;
  const std::string& suffix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_suffix(Arg_&& arg, Args_... args);
  std::string* mutable_suffix();
  PROTOBUF_NODISCARD std::string* release_suffix();
  void set_allocated_suffix(std::string* value);

  private:
  const std::string& _internal_suffix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_suffix(
      const std::string& value);
  std::string* _internal_mutable_suffix();

  public:
  // .cosmos.ics23.v1.HashOp hash = 1 [json_name = "hash"];
  void clear_hash() ;
  ::cosmos::ics23::v1::HashOp hash() const;
  void set_hash(::cosmos::ics23::v1::HashOp value);

  private:
  ::cosmos::ics23::v1::HashOp _internal_hash() const;
  void _internal_set_hash(::cosmos::ics23::v1::HashOp value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.InnerOp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InnerOp& from_msg);
    ::google::protobuf::internal::ArenaStringPtr prefix_;
    ::google::protobuf::internal::ArenaStringPtr suffix_;
    int hash_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};
// -------------------------------------------------------------------

class ProofSpec final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.ProofSpec) */ {
 public:
  inline ProofSpec() : ProofSpec(nullptr) {}
  ~ProofSpec() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ProofSpec* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ProofSpec));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ProofSpec(
      ::google::protobuf::internal::ConstantInitialized);

  inline ProofSpec(const ProofSpec& from) : ProofSpec(nullptr, from) {}
  inline ProofSpec(ProofSpec&& from) noexcept
      : ProofSpec(nullptr, std::move(from)) {}
  inline ProofSpec& operator=(const ProofSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProofSpec& operator=(ProofSpec&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProofSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProofSpec* internal_default_instance() {
    return reinterpret_cast<const ProofSpec*>(
        &_ProofSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(ProofSpec& a, ProofSpec& b) { a.Swap(&b); }
  inline void Swap(ProofSpec* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProofSpec* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProofSpec* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ProofSpec>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProofSpec& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ProofSpec& from) { ProofSpec::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ProofSpec* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.ics23.v1.ProofSpec"; }

 protected:
  explicit ProofSpec(::google::protobuf::Arena* arena);
  ProofSpec(::google::protobuf::Arena* arena, const ProofSpec& from);
  ProofSpec(::google::protobuf::Arena* arena, ProofSpec&& from) noexcept
      : ProofSpec(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLeafSpecFieldNumber = 1,
    kInnerSpecFieldNumber = 2,
    kMaxDepthFieldNumber = 3,
    kMinDepthFieldNumber = 4,
  };
  // .cosmos.ics23.v1.LeafOp leaf_spec = 1 [json_name = "leafSpec"];
  bool has_leaf_spec() const;
  void clear_leaf_spec() ;
  const ::cosmos::ics23::v1::LeafOp& leaf_spec() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::LeafOp* release_leaf_spec();
  ::cosmos::ics23::v1::LeafOp* mutable_leaf_spec();
  void set_allocated_leaf_spec(::cosmos::ics23::v1::LeafOp* value);
  void unsafe_arena_set_allocated_leaf_spec(::cosmos::ics23::v1::LeafOp* value);
  ::cosmos::ics23::v1::LeafOp* unsafe_arena_release_leaf_spec();

  private:
  const ::cosmos::ics23::v1::LeafOp& _internal_leaf_spec() const;
  ::cosmos::ics23::v1::LeafOp* _internal_mutable_leaf_spec();

  public:
  // .cosmos.ics23.v1.InnerSpec inner_spec = 2 [json_name = "innerSpec"];
  bool has_inner_spec() const;
  void clear_inner_spec() ;
  const ::cosmos::ics23::v1::InnerSpec& inner_spec() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::InnerSpec* release_inner_spec();
  ::cosmos::ics23::v1::InnerSpec* mutable_inner_spec();
  void set_allocated_inner_spec(::cosmos::ics23::v1::InnerSpec* value);
  void unsafe_arena_set_allocated_inner_spec(::cosmos::ics23::v1::InnerSpec* value);
  ::cosmos::ics23::v1::InnerSpec* unsafe_arena_release_inner_spec();

  private:
  const ::cosmos::ics23::v1::InnerSpec& _internal_inner_spec() const;
  ::cosmos::ics23::v1::InnerSpec* _internal_mutable_inner_spec();

  public:
  // int32 max_depth = 3 [json_name = "maxDepth"];
  void clear_max_depth() ;
  ::int32_t max_depth() const;
  void set_max_depth(::int32_t value);

  private:
  ::int32_t _internal_max_depth() const;
  void _internal_set_max_depth(::int32_t value);

  public:
  // int32 min_depth = 4 [json_name = "minDepth"];
  void clear_min_depth() ;
  ::int32_t min_depth() const;
  void set_min_depth(::int32_t value);

  private:
  ::int32_t _internal_min_depth() const;
  void _internal_set_min_depth(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.ProofSpec)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ProofSpec& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::cosmos::ics23::v1::LeafOp* leaf_spec_;
    ::cosmos::ics23::v1::InnerSpec* inner_spec_;
    ::int32_t max_depth_;
    ::int32_t min_depth_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};
// -------------------------------------------------------------------

class ExistenceProof final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.ExistenceProof) */ {
 public:
  inline ExistenceProof() : ExistenceProof(nullptr) {}
  ~ExistenceProof() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExistenceProof* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExistenceProof));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExistenceProof(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExistenceProof(const ExistenceProof& from) : ExistenceProof(nullptr, from) {}
  inline ExistenceProof(ExistenceProof&& from) noexcept
      : ExistenceProof(nullptr, std::move(from)) {}
  inline ExistenceProof& operator=(const ExistenceProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExistenceProof& operator=(ExistenceProof&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExistenceProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExistenceProof* internal_default_instance() {
    return reinterpret_cast<const ExistenceProof*>(
        &_ExistenceProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(ExistenceProof& a, ExistenceProof& b) { a.Swap(&b); }
  inline void Swap(ExistenceProof* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExistenceProof* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExistenceProof* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExistenceProof>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExistenceProof& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExistenceProof& from) { ExistenceProof::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExistenceProof* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.ics23.v1.ExistenceProof"; }

 protected:
  explicit ExistenceProof(::google::protobuf::Arena* arena);
  ExistenceProof(::google::protobuf::Arena* arena, const ExistenceProof& from);
  ExistenceProof(::google::protobuf::Arena* arena, ExistenceProof&& from) noexcept
      : ExistenceProof(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPathFieldNumber = 4,
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
    kLeafFieldNumber = 3,
  };
  // repeated .cosmos.ics23.v1.InnerOp path = 4 [json_name = "path"];
  int path_size() const;
  private:
  int _internal_path_size() const;

  public:
  void clear_path() ;
  ::cosmos::ics23::v1::InnerOp* mutable_path(int index);
  ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>* mutable_path();

  private:
  const ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>& _internal_path() const;
  ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>* _internal_mutable_path();
  public:
  const ::cosmos::ics23::v1::InnerOp& path(int index) const;
  ::cosmos::ics23::v1::InnerOp* add_path();
  const ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>& path() const;
  // bytes key = 1 [json_name = "key"];
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes value = 2 [json_name = "value"];
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // .cosmos.ics23.v1.LeafOp leaf = 3 [json_name = "leaf"];
  bool has_leaf() const;
  void clear_leaf() ;
  const ::cosmos::ics23::v1::LeafOp& leaf() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::LeafOp* release_leaf();
  ::cosmos::ics23::v1::LeafOp* mutable_leaf();
  void set_allocated_leaf(::cosmos::ics23::v1::LeafOp* value);
  void unsafe_arena_set_allocated_leaf(::cosmos::ics23::v1::LeafOp* value);
  ::cosmos::ics23::v1::LeafOp* unsafe_arena_release_leaf();

  private:
  const ::cosmos::ics23::v1::LeafOp& _internal_leaf() const;
  ::cosmos::ics23::v1::LeafOp* _internal_mutable_leaf();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.ExistenceProof)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExistenceProof& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::cosmos::ics23::v1::InnerOp > path_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    ::cosmos::ics23::v1::LeafOp* leaf_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};
// -------------------------------------------------------------------

class CompressedExistenceProof final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.CompressedExistenceProof) */ {
 public:
  inline CompressedExistenceProof() : CompressedExistenceProof(nullptr) {}
  ~CompressedExistenceProof() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CompressedExistenceProof* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CompressedExistenceProof));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CompressedExistenceProof(
      ::google::protobuf::internal::ConstantInitialized);

  inline CompressedExistenceProof(const CompressedExistenceProof& from) : CompressedExistenceProof(nullptr, from) {}
  inline CompressedExistenceProof(CompressedExistenceProof&& from) noexcept
      : CompressedExistenceProof(nullptr, std::move(from)) {}
  inline CompressedExistenceProof& operator=(const CompressedExistenceProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedExistenceProof& operator=(CompressedExistenceProof&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedExistenceProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedExistenceProof* internal_default_instance() {
    return reinterpret_cast<const CompressedExistenceProof*>(
        &_CompressedExistenceProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(CompressedExistenceProof& a, CompressedExistenceProof& b) { a.Swap(&b); }
  inline void Swap(CompressedExistenceProof* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedExistenceProof* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedExistenceProof* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CompressedExistenceProof>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CompressedExistenceProof& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CompressedExistenceProof& from) { CompressedExistenceProof::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CompressedExistenceProof* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.ics23.v1.CompressedExistenceProof"; }

 protected:
  explicit CompressedExistenceProof(::google::protobuf::Arena* arena);
  CompressedExistenceProof(::google::protobuf::Arena* arena, const CompressedExistenceProof& from);
  CompressedExistenceProof(::google::protobuf::Arena* arena, CompressedExistenceProof&& from) noexcept
      : CompressedExistenceProof(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPathFieldNumber = 4,
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
    kLeafFieldNumber = 3,
  };
  // repeated int32 path = 4 [json_name = "path"];
  int path_size() const;
  private:
  int _internal_path_size() const;

  public:
  void clear_path() ;
  ::int32_t path(int index) const;
  void set_path(int index, ::int32_t value);
  void add_path(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& path() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_path();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_path() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_path();

  public:
  // bytes key = 1 [json_name = "key"];
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes value = 2 [json_name = "value"];
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // .cosmos.ics23.v1.LeafOp leaf = 3 [json_name = "leaf"];
  bool has_leaf() const;
  void clear_leaf() ;
  const ::cosmos::ics23::v1::LeafOp& leaf() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::LeafOp* release_leaf();
  ::cosmos::ics23::v1::LeafOp* mutable_leaf();
  void set_allocated_leaf(::cosmos::ics23::v1::LeafOp* value);
  void unsafe_arena_set_allocated_leaf(::cosmos::ics23::v1::LeafOp* value);
  ::cosmos::ics23::v1::LeafOp* unsafe_arena_release_leaf();

  private:
  const ::cosmos::ics23::v1::LeafOp& _internal_leaf() const;
  ::cosmos::ics23::v1::LeafOp* _internal_mutable_leaf();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.CompressedExistenceProof)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CompressedExistenceProof& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> path_;
    ::google::protobuf::internal::CachedSize _path_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    ::cosmos::ics23::v1::LeafOp* leaf_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};
// -------------------------------------------------------------------

class NonExistenceProof final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.NonExistenceProof) */ {
 public:
  inline NonExistenceProof() : NonExistenceProof(nullptr) {}
  ~NonExistenceProof() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NonExistenceProof* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NonExistenceProof));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NonExistenceProof(
      ::google::protobuf::internal::ConstantInitialized);

  inline NonExistenceProof(const NonExistenceProof& from) : NonExistenceProof(nullptr, from) {}
  inline NonExistenceProof(NonExistenceProof&& from) noexcept
      : NonExistenceProof(nullptr, std::move(from)) {}
  inline NonExistenceProof& operator=(const NonExistenceProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline NonExistenceProof& operator=(NonExistenceProof&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NonExistenceProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const NonExistenceProof* internal_default_instance() {
    return reinterpret_cast<const NonExistenceProof*>(
        &_NonExistenceProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(NonExistenceProof& a, NonExistenceProof& b) { a.Swap(&b); }
  inline void Swap(NonExistenceProof* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NonExistenceProof* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NonExistenceProof* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NonExistenceProof>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NonExistenceProof& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NonExistenceProof& from) { NonExistenceProof::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NonExistenceProof* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.ics23.v1.NonExistenceProof"; }

 protected:
  explicit NonExistenceProof(::google::protobuf::Arena* arena);
  NonExistenceProof(::google::protobuf::Arena* arena, const NonExistenceProof& from);
  NonExistenceProof(::google::protobuf::Arena* arena, NonExistenceProof&& from) noexcept
      : NonExistenceProof(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 1,
    kLeftFieldNumber = 2,
    kRightFieldNumber = 3,
  };
  // bytes key = 1 [json_name = "key"];
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // .cosmos.ics23.v1.ExistenceProof left = 2 [json_name = "left"];
  bool has_left() const;
  void clear_left() ;
  const ::cosmos::ics23::v1::ExistenceProof& left() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::ExistenceProof* release_left();
  ::cosmos::ics23::v1::ExistenceProof* mutable_left();
  void set_allocated_left(::cosmos::ics23::v1::ExistenceProof* value);
  void unsafe_arena_set_allocated_left(::cosmos::ics23::v1::ExistenceProof* value);
  ::cosmos::ics23::v1::ExistenceProof* unsafe_arena_release_left();

  private:
  const ::cosmos::ics23::v1::ExistenceProof& _internal_left() const;
  ::cosmos::ics23::v1::ExistenceProof* _internal_mutable_left();

  public:
  // .cosmos.ics23.v1.ExistenceProof right = 3 [json_name = "right"];
  bool has_right() const;
  void clear_right() ;
  const ::cosmos::ics23::v1::ExistenceProof& right() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::ExistenceProof* release_right();
  ::cosmos::ics23::v1::ExistenceProof* mutable_right();
  void set_allocated_right(::cosmos::ics23::v1::ExistenceProof* value);
  void unsafe_arena_set_allocated_right(::cosmos::ics23::v1::ExistenceProof* value);
  ::cosmos::ics23::v1::ExistenceProof* unsafe_arena_release_right();

  private:
  const ::cosmos::ics23::v1::ExistenceProof& _internal_right() const;
  ::cosmos::ics23::v1::ExistenceProof* _internal_mutable_right();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.NonExistenceProof)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NonExistenceProof& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::cosmos::ics23::v1::ExistenceProof* left_;
    ::cosmos::ics23::v1::ExistenceProof* right_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};
// -------------------------------------------------------------------

class CompressedNonExistenceProof final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.CompressedNonExistenceProof) */ {
 public:
  inline CompressedNonExistenceProof() : CompressedNonExistenceProof(nullptr) {}
  ~CompressedNonExistenceProof() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CompressedNonExistenceProof* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CompressedNonExistenceProof));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CompressedNonExistenceProof(
      ::google::protobuf::internal::ConstantInitialized);

  inline CompressedNonExistenceProof(const CompressedNonExistenceProof& from) : CompressedNonExistenceProof(nullptr, from) {}
  inline CompressedNonExistenceProof(CompressedNonExistenceProof&& from) noexcept
      : CompressedNonExistenceProof(nullptr, std::move(from)) {}
  inline CompressedNonExistenceProof& operator=(const CompressedNonExistenceProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedNonExistenceProof& operator=(CompressedNonExistenceProof&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedNonExistenceProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedNonExistenceProof* internal_default_instance() {
    return reinterpret_cast<const CompressedNonExistenceProof*>(
        &_CompressedNonExistenceProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(CompressedNonExistenceProof& a, CompressedNonExistenceProof& b) { a.Swap(&b); }
  inline void Swap(CompressedNonExistenceProof* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedNonExistenceProof* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedNonExistenceProof* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CompressedNonExistenceProof>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CompressedNonExistenceProof& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CompressedNonExistenceProof& from) { CompressedNonExistenceProof::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CompressedNonExistenceProof* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.ics23.v1.CompressedNonExistenceProof"; }

 protected:
  explicit CompressedNonExistenceProof(::google::protobuf::Arena* arena);
  CompressedNonExistenceProof(::google::protobuf::Arena* arena, const CompressedNonExistenceProof& from);
  CompressedNonExistenceProof(::google::protobuf::Arena* arena, CompressedNonExistenceProof&& from) noexcept
      : CompressedNonExistenceProof(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 1,
    kLeftFieldNumber = 2,
    kRightFieldNumber = 3,
  };
  // bytes key = 1 [json_name = "key"];
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // .cosmos.ics23.v1.CompressedExistenceProof left = 2 [json_name = "left"];
  bool has_left() const;
  void clear_left() ;
  const ::cosmos::ics23::v1::CompressedExistenceProof& left() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::CompressedExistenceProof* release_left();
  ::cosmos::ics23::v1::CompressedExistenceProof* mutable_left();
  void set_allocated_left(::cosmos::ics23::v1::CompressedExistenceProof* value);
  void unsafe_arena_set_allocated_left(::cosmos::ics23::v1::CompressedExistenceProof* value);
  ::cosmos::ics23::v1::CompressedExistenceProof* unsafe_arena_release_left();

  private:
  const ::cosmos::ics23::v1::CompressedExistenceProof& _internal_left() const;
  ::cosmos::ics23::v1::CompressedExistenceProof* _internal_mutable_left();

  public:
  // .cosmos.ics23.v1.CompressedExistenceProof right = 3 [json_name = "right"];
  bool has_right() const;
  void clear_right() ;
  const ::cosmos::ics23::v1::CompressedExistenceProof& right() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::CompressedExistenceProof* release_right();
  ::cosmos::ics23::v1::CompressedExistenceProof* mutable_right();
  void set_allocated_right(::cosmos::ics23::v1::CompressedExistenceProof* value);
  void unsafe_arena_set_allocated_right(::cosmos::ics23::v1::CompressedExistenceProof* value);
  ::cosmos::ics23::v1::CompressedExistenceProof* unsafe_arena_release_right();

  private:
  const ::cosmos::ics23::v1::CompressedExistenceProof& _internal_right() const;
  ::cosmos::ics23::v1::CompressedExistenceProof* _internal_mutable_right();

  public:
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.CompressedNonExistenceProof)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CompressedNonExistenceProof& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::cosmos::ics23::v1::CompressedExistenceProof* left_;
    ::cosmos::ics23::v1::CompressedExistenceProof* right_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};
// -------------------------------------------------------------------

class CompressedBatchEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.CompressedBatchEntry) */ {
 public:
  inline CompressedBatchEntry() : CompressedBatchEntry(nullptr) {}
  ~CompressedBatchEntry() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CompressedBatchEntry* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CompressedBatchEntry));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CompressedBatchEntry(
      ::google::protobuf::internal::ConstantInitialized);

  inline CompressedBatchEntry(const CompressedBatchEntry& from) : CompressedBatchEntry(nullptr, from) {}
  inline CompressedBatchEntry(CompressedBatchEntry&& from) noexcept
      : CompressedBatchEntry(nullptr, std::move(from)) {}
  inline CompressedBatchEntry& operator=(const CompressedBatchEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedBatchEntry& operator=(CompressedBatchEntry&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedBatchEntry& default_instance() {
    return *internal_default_instance();
  }
  enum ProofCase {
    kExist = 1,
    kNonexist = 2,
    PROOF_NOT_SET = 0,
  };
  static inline const CompressedBatchEntry* internal_default_instance() {
    return reinterpret_cast<const CompressedBatchEntry*>(
        &_CompressedBatchEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(CompressedBatchEntry& a, CompressedBatchEntry& b) { a.Swap(&b); }
  inline void Swap(CompressedBatchEntry* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedBatchEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedBatchEntry* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CompressedBatchEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CompressedBatchEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CompressedBatchEntry& from) { CompressedBatchEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CompressedBatchEntry* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.ics23.v1.CompressedBatchEntry"; }

 protected:
  explicit CompressedBatchEntry(::google::protobuf::Arena* arena);
  CompressedBatchEntry(::google::protobuf::Arena* arena, const CompressedBatchEntry& from);
  CompressedBatchEntry(::google::protobuf::Arena* arena, CompressedBatchEntry&& from) noexcept
      : CompressedBatchEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExistFieldNumber = 1,
    kNonexistFieldNumber = 2,
  };
  // .cosmos.ics23.v1.CompressedExistenceProof exist = 1 [json_name = "exist"];
  bool has_exist() const;
  private:
  bool _internal_has_exist() const;

  public:
  void clear_exist() ;
  const ::cosmos::ics23::v1::CompressedExistenceProof& exist() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::CompressedExistenceProof* release_exist();
  ::cosmos::ics23::v1::CompressedExistenceProof* mutable_exist();
  void set_allocated_exist(::cosmos::ics23::v1::CompressedExistenceProof* value);
  void unsafe_arena_set_allocated_exist(::cosmos::ics23::v1::CompressedExistenceProof* value);
  ::cosmos::ics23::v1::CompressedExistenceProof* unsafe_arena_release_exist();

  private:
  const ::cosmos::ics23::v1::CompressedExistenceProof& _internal_exist() const;
  ::cosmos::ics23::v1::CompressedExistenceProof* _internal_mutable_exist();

  public:
  // .cosmos.ics23.v1.CompressedNonExistenceProof nonexist = 2 [json_name = "nonexist"];
  bool has_nonexist() const;
  private:
  bool _internal_has_nonexist() const;

  public:
  void clear_nonexist() ;
  const ::cosmos::ics23::v1::CompressedNonExistenceProof& nonexist() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::CompressedNonExistenceProof* release_nonexist();
  ::cosmos::ics23::v1::CompressedNonExistenceProof* mutable_nonexist();
  void set_allocated_nonexist(::cosmos::ics23::v1::CompressedNonExistenceProof* value);
  void unsafe_arena_set_allocated_nonexist(::cosmos::ics23::v1::CompressedNonExistenceProof* value);
  ::cosmos::ics23::v1::CompressedNonExistenceProof* unsafe_arena_release_nonexist();

  private:
  const ::cosmos::ics23::v1::CompressedNonExistenceProof& _internal_nonexist() const;
  ::cosmos::ics23::v1::CompressedNonExistenceProof* _internal_mutable_nonexist();

  public:
  void clear_proof();
  ProofCase proof_case() const;
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.CompressedBatchEntry)
 private:
  class _Internal;
  void set_has_exist();
  void set_has_nonexist();
  inline bool has_proof() const;
  inline void clear_has_proof();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CompressedBatchEntry& from_msg);
    union ProofUnion {
      constexpr ProofUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::cosmos::ics23::v1::CompressedExistenceProof* exist_;
      ::cosmos::ics23::v1::CompressedNonExistenceProof* nonexist_;
    } proof_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};
// -------------------------------------------------------------------

class BatchEntry final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.BatchEntry) */ {
 public:
  inline BatchEntry() : BatchEntry(nullptr) {}
  ~BatchEntry() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BatchEntry* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BatchEntry));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BatchEntry(
      ::google::protobuf::internal::ConstantInitialized);

  inline BatchEntry(const BatchEntry& from) : BatchEntry(nullptr, from) {}
  inline BatchEntry(BatchEntry&& from) noexcept
      : BatchEntry(nullptr, std::move(from)) {}
  inline BatchEntry& operator=(const BatchEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchEntry& operator=(BatchEntry&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchEntry& default_instance() {
    return *internal_default_instance();
  }
  enum ProofCase {
    kExist = 1,
    kNonexist = 2,
    PROOF_NOT_SET = 0,
  };
  static inline const BatchEntry* internal_default_instance() {
    return reinterpret_cast<const BatchEntry*>(
        &_BatchEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(BatchEntry& a, BatchEntry& b) { a.Swap(&b); }
  inline void Swap(BatchEntry* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchEntry* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BatchEntry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BatchEntry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BatchEntry& from) { BatchEntry::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BatchEntry* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.ics23.v1.BatchEntry"; }

 protected:
  explicit BatchEntry(::google::protobuf::Arena* arena);
  BatchEntry(::google::protobuf::Arena* arena, const BatchEntry& from);
  BatchEntry(::google::protobuf::Arena* arena, BatchEntry&& from) noexcept
      : BatchEntry(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExistFieldNumber = 1,
    kNonexistFieldNumber = 2,
  };
  // .cosmos.ics23.v1.ExistenceProof exist = 1 [json_name = "exist"];
  bool has_exist() const;
  private:
  bool _internal_has_exist() const;

  public:
  void clear_exist() ;
  const ::cosmos::ics23::v1::ExistenceProof& exist() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::ExistenceProof* release_exist();
  ::cosmos::ics23::v1::ExistenceProof* mutable_exist();
  void set_allocated_exist(::cosmos::ics23::v1::ExistenceProof* value);
  void unsafe_arena_set_allocated_exist(::cosmos::ics23::v1::ExistenceProof* value);
  ::cosmos::ics23::v1::ExistenceProof* unsafe_arena_release_exist();

  private:
  const ::cosmos::ics23::v1::ExistenceProof& _internal_exist() const;
  ::cosmos::ics23::v1::ExistenceProof* _internal_mutable_exist();

  public:
  // .cosmos.ics23.v1.NonExistenceProof nonexist = 2 [json_name = "nonexist"];
  bool has_nonexist() const;
  private:
  bool _internal_has_nonexist() const;

  public:
  void clear_nonexist() ;
  const ::cosmos::ics23::v1::NonExistenceProof& nonexist() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::NonExistenceProof* release_nonexist();
  ::cosmos::ics23::v1::NonExistenceProof* mutable_nonexist();
  void set_allocated_nonexist(::cosmos::ics23::v1::NonExistenceProof* value);
  void unsafe_arena_set_allocated_nonexist(::cosmos::ics23::v1::NonExistenceProof* value);
  ::cosmos::ics23::v1::NonExistenceProof* unsafe_arena_release_nonexist();

  private:
  const ::cosmos::ics23::v1::NonExistenceProof& _internal_nonexist() const;
  ::cosmos::ics23::v1::NonExistenceProof* _internal_mutable_nonexist();

  public:
  void clear_proof();
  ProofCase proof_case() const;
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.BatchEntry)
 private:
  class _Internal;
  void set_has_exist();
  void set_has_nonexist();
  inline bool has_proof() const;
  inline void clear_has_proof();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BatchEntry& from_msg);
    union ProofUnion {
      constexpr ProofUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::cosmos::ics23::v1::ExistenceProof* exist_;
      ::cosmos::ics23::v1::NonExistenceProof* nonexist_;
    } proof_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};
// -------------------------------------------------------------------

class CompressedBatchProof final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.CompressedBatchProof) */ {
 public:
  inline CompressedBatchProof() : CompressedBatchProof(nullptr) {}
  ~CompressedBatchProof() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CompressedBatchProof* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CompressedBatchProof));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CompressedBatchProof(
      ::google::protobuf::internal::ConstantInitialized);

  inline CompressedBatchProof(const CompressedBatchProof& from) : CompressedBatchProof(nullptr, from) {}
  inline CompressedBatchProof(CompressedBatchProof&& from) noexcept
      : CompressedBatchProof(nullptr, std::move(from)) {}
  inline CompressedBatchProof& operator=(const CompressedBatchProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedBatchProof& operator=(CompressedBatchProof&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedBatchProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedBatchProof* internal_default_instance() {
    return reinterpret_cast<const CompressedBatchProof*>(
        &_CompressedBatchProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(CompressedBatchProof& a, CompressedBatchProof& b) { a.Swap(&b); }
  inline void Swap(CompressedBatchProof* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedBatchProof* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedBatchProof* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CompressedBatchProof>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CompressedBatchProof& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CompressedBatchProof& from) { CompressedBatchProof::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CompressedBatchProof* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.ics23.v1.CompressedBatchProof"; }

 protected:
  explicit CompressedBatchProof(::google::protobuf::Arena* arena);
  CompressedBatchProof(::google::protobuf::Arena* arena, const CompressedBatchProof& from);
  CompressedBatchProof(::google::protobuf::Arena* arena, CompressedBatchProof&& from) noexcept
      : CompressedBatchProof(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntriesFieldNumber = 1,
    kLookupInnersFieldNumber = 2,
  };
  // repeated .cosmos.ics23.v1.CompressedBatchEntry entries = 1 [json_name = "entries"];
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::cosmos::ics23::v1::CompressedBatchEntry* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::CompressedBatchEntry>* mutable_entries();

  private:
  const ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::CompressedBatchEntry>& _internal_entries() const;
  ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::CompressedBatchEntry>* _internal_mutable_entries();
  public:
  const ::cosmos::ics23::v1::CompressedBatchEntry& entries(int index) const;
  ::cosmos::ics23::v1::CompressedBatchEntry* add_entries();
  const ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::CompressedBatchEntry>& entries() const;
  // repeated .cosmos.ics23.v1.InnerOp lookup_inners = 2 [json_name = "lookupInners"];
  int lookup_inners_size() const;
  private:
  int _internal_lookup_inners_size() const;

  public:
  void clear_lookup_inners() ;
  ::cosmos::ics23::v1::InnerOp* mutable_lookup_inners(int index);
  ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>* mutable_lookup_inners();

  private:
  const ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>& _internal_lookup_inners() const;
  ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>* _internal_mutable_lookup_inners();
  public:
  const ::cosmos::ics23::v1::InnerOp& lookup_inners(int index) const;
  ::cosmos::ics23::v1::InnerOp* add_lookup_inners();
  const ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>& lookup_inners() const;
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.CompressedBatchProof)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CompressedBatchProof& from_msg);
    ::google::protobuf::RepeatedPtrField< ::cosmos::ics23::v1::CompressedBatchEntry > entries_;
    ::google::protobuf::RepeatedPtrField< ::cosmos::ics23::v1::InnerOp > lookup_inners_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};
// -------------------------------------------------------------------

class BatchProof final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.BatchProof) */ {
 public:
  inline BatchProof() : BatchProof(nullptr) {}
  ~BatchProof() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BatchProof* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BatchProof));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BatchProof(
      ::google::protobuf::internal::ConstantInitialized);

  inline BatchProof(const BatchProof& from) : BatchProof(nullptr, from) {}
  inline BatchProof(BatchProof&& from) noexcept
      : BatchProof(nullptr, std::move(from)) {}
  inline BatchProof& operator=(const BatchProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchProof& operator=(BatchProof&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchProof* internal_default_instance() {
    return reinterpret_cast<const BatchProof*>(
        &_BatchProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(BatchProof& a, BatchProof& b) { a.Swap(&b); }
  inline void Swap(BatchProof* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchProof* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchProof* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BatchProof>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BatchProof& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BatchProof& from) { BatchProof::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BatchProof* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.ics23.v1.BatchProof"; }

 protected:
  explicit BatchProof(::google::protobuf::Arena* arena);
  BatchProof(::google::protobuf::Arena* arena, const BatchProof& from);
  BatchProof(::google::protobuf::Arena* arena, BatchProof&& from) noexcept
      : BatchProof(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .cosmos.ics23.v1.BatchEntry entries = 1 [json_name = "entries"];
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::cosmos::ics23::v1::BatchEntry* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::BatchEntry>* mutable_entries();

  private:
  const ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::BatchEntry>& _internal_entries() const;
  ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::BatchEntry>* _internal_mutable_entries();
  public:
  const ::cosmos::ics23::v1::BatchEntry& entries(int index) const;
  ::cosmos::ics23::v1::BatchEntry* add_entries();
  const ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::BatchEntry>& entries() const;
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.BatchProof)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BatchProof& from_msg);
    ::google::protobuf::RepeatedPtrField< ::cosmos::ics23::v1::BatchEntry > entries_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};
// -------------------------------------------------------------------

class CommitmentProof final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmos.ics23.v1.CommitmentProof) */ {
 public:
  inline CommitmentProof() : CommitmentProof(nullptr) {}
  ~CommitmentProof() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CommitmentProof* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CommitmentProof));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommitmentProof(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommitmentProof(const CommitmentProof& from) : CommitmentProof(nullptr, from) {}
  inline CommitmentProof(CommitmentProof&& from) noexcept
      : CommitmentProof(nullptr, std::move(from)) {}
  inline CommitmentProof& operator=(const CommitmentProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommitmentProof& operator=(CommitmentProof&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommitmentProof& default_instance() {
    return *internal_default_instance();
  }
  enum ProofCase {
    kExist = 1,
    kNonexist = 2,
    kBatch = 3,
    kCompressed = 4,
    PROOF_NOT_SET = 0,
  };
  static inline const CommitmentProof* internal_default_instance() {
    return reinterpret_cast<const CommitmentProof*>(
        &_CommitmentProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(CommitmentProof& a, CommitmentProof& b) { a.Swap(&b); }
  inline void Swap(CommitmentProof* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommitmentProof* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommitmentProof* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CommitmentProof>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommitmentProof& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommitmentProof& from) { CommitmentProof::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CommitmentProof* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmos.ics23.v1.CommitmentProof"; }

 protected:
  explicit CommitmentProof(::google::protobuf::Arena* arena);
  CommitmentProof(::google::protobuf::Arena* arena, const CommitmentProof& from);
  CommitmentProof(::google::protobuf::Arena* arena, CommitmentProof&& from) noexcept
      : CommitmentProof(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExistFieldNumber = 1,
    kNonexistFieldNumber = 2,
    kBatchFieldNumber = 3,
    kCompressedFieldNumber = 4,
  };
  // .cosmos.ics23.v1.ExistenceProof exist = 1 [json_name = "exist"];
  bool has_exist() const;
  private:
  bool _internal_has_exist() const;

  public:
  void clear_exist() ;
  const ::cosmos::ics23::v1::ExistenceProof& exist() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::ExistenceProof* release_exist();
  ::cosmos::ics23::v1::ExistenceProof* mutable_exist();
  void set_allocated_exist(::cosmos::ics23::v1::ExistenceProof* value);
  void unsafe_arena_set_allocated_exist(::cosmos::ics23::v1::ExistenceProof* value);
  ::cosmos::ics23::v1::ExistenceProof* unsafe_arena_release_exist();

  private:
  const ::cosmos::ics23::v1::ExistenceProof& _internal_exist() const;
  ::cosmos::ics23::v1::ExistenceProof* _internal_mutable_exist();

  public:
  // .cosmos.ics23.v1.NonExistenceProof nonexist = 2 [json_name = "nonexist"];
  bool has_nonexist() const;
  private:
  bool _internal_has_nonexist() const;

  public:
  void clear_nonexist() ;
  const ::cosmos::ics23::v1::NonExistenceProof& nonexist() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::NonExistenceProof* release_nonexist();
  ::cosmos::ics23::v1::NonExistenceProof* mutable_nonexist();
  void set_allocated_nonexist(::cosmos::ics23::v1::NonExistenceProof* value);
  void unsafe_arena_set_allocated_nonexist(::cosmos::ics23::v1::NonExistenceProof* value);
  ::cosmos::ics23::v1::NonExistenceProof* unsafe_arena_release_nonexist();

  private:
  const ::cosmos::ics23::v1::NonExistenceProof& _internal_nonexist() const;
  ::cosmos::ics23::v1::NonExistenceProof* _internal_mutable_nonexist();

  public:
  // .cosmos.ics23.v1.BatchProof batch = 3 [json_name = "batch"];
  bool has_batch() const;
  private:
  bool _internal_has_batch() const;

  public:
  void clear_batch() ;
  const ::cosmos::ics23::v1::BatchProof& batch() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::BatchProof* release_batch();
  ::cosmos::ics23::v1::BatchProof* mutable_batch();
  void set_allocated_batch(::cosmos::ics23::v1::BatchProof* value);
  void unsafe_arena_set_allocated_batch(::cosmos::ics23::v1::BatchProof* value);
  ::cosmos::ics23::v1::BatchProof* unsafe_arena_release_batch();

  private:
  const ::cosmos::ics23::v1::BatchProof& _internal_batch() const;
  ::cosmos::ics23::v1::BatchProof* _internal_mutable_batch();

  public:
  // .cosmos.ics23.v1.CompressedBatchProof compressed = 4 [json_name = "compressed"];
  bool has_compressed() const;
  private:
  bool _internal_has_compressed() const;

  public:
  void clear_compressed() ;
  const ::cosmos::ics23::v1::CompressedBatchProof& compressed() const;
  PROTOBUF_NODISCARD ::cosmos::ics23::v1::CompressedBatchProof* release_compressed();
  ::cosmos::ics23::v1::CompressedBatchProof* mutable_compressed();
  void set_allocated_compressed(::cosmos::ics23::v1::CompressedBatchProof* value);
  void unsafe_arena_set_allocated_compressed(::cosmos::ics23::v1::CompressedBatchProof* value);
  ::cosmos::ics23::v1::CompressedBatchProof* unsafe_arena_release_compressed();

  private:
  const ::cosmos::ics23::v1::CompressedBatchProof& _internal_compressed() const;
  ::cosmos::ics23::v1::CompressedBatchProof* _internal_mutable_compressed();

  public:
  void clear_proof();
  ProofCase proof_case() const;
  // @@protoc_insertion_point(class_scope:cosmos.ics23.v1.CommitmentProof)
 private:
  class _Internal;
  void set_has_exist();
  void set_has_nonexist();
  void set_has_batch();
  void set_has_compressed();
  inline bool has_proof() const;
  inline void clear_has_proof();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommitmentProof& from_msg);
    union ProofUnion {
      constexpr ProofUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::cosmos::ics23::v1::ExistenceProof* exist_;
      ::cosmos::ics23::v1::NonExistenceProof* nonexist_;
      ::cosmos::ics23::v1::BatchProof* batch_;
      ::cosmos::ics23::v1::CompressedBatchProof* compressed_;
    } proof_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmos_2fics23_2fv1_2fproofs_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ExistenceProof

// bytes key = 1 [json_name = "key"];
inline void ExistenceProof::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& ExistenceProof::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.ExistenceProof.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExistenceProof::set_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.ExistenceProof.key)
}
inline std::string* ExistenceProof::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.ExistenceProof.key)
  return _s;
}
inline const std::string& ExistenceProof::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void ExistenceProof::_internal_set_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline std::string* ExistenceProof::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* ExistenceProof::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.ExistenceProof.key)
  return _impl_.key_.Release();
}
inline void ExistenceProof::set_allocated_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.ExistenceProof.key)
}

// bytes value = 2 [json_name = "value"];
inline void ExistenceProof::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& ExistenceProof::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.ExistenceProof.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExistenceProof::set_value(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.ExistenceProof.value)
}
inline std::string* ExistenceProof::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.ExistenceProof.value)
  return _s;
}
inline const std::string& ExistenceProof::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_.Get();
}
inline void ExistenceProof::_internal_set_value(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Set(value, GetArena());
}
inline std::string* ExistenceProof::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* ExistenceProof::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.ExistenceProof.value)
  return _impl_.value_.Release();
}
inline void ExistenceProof::set_allocated_value(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.ExistenceProof.value)
}

// .cosmos.ics23.v1.LeafOp leaf = 3 [json_name = "leaf"];
inline bool ExistenceProof::has_leaf() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.leaf_ != nullptr);
  return value;
}
inline void ExistenceProof::clear_leaf() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.leaf_ != nullptr) _impl_.leaf_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cosmos::ics23::v1::LeafOp& ExistenceProof::_internal_leaf() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::cosmos::ics23::v1::LeafOp* p = _impl_.leaf_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::ics23::v1::LeafOp&>(::cosmos::ics23::v1::_LeafOp_default_instance_);
}
inline const ::cosmos::ics23::v1::LeafOp& ExistenceProof::leaf() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.ExistenceProof.leaf)
  return _internal_leaf();
}
inline void ExistenceProof::unsafe_arena_set_allocated_leaf(::cosmos::ics23::v1::LeafOp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.leaf_);
  }
  _impl_.leaf_ = reinterpret_cast<::cosmos::ics23::v1::LeafOp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.ExistenceProof.leaf)
}
inline ::cosmos::ics23::v1::LeafOp* ExistenceProof::release_leaf() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::ics23::v1::LeafOp* released = _impl_.leaf_;
  _impl_.leaf_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::cosmos::ics23::v1::LeafOp* ExistenceProof::unsafe_arena_release_leaf() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.ExistenceProof.leaf)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::ics23::v1::LeafOp* temp = _impl_.leaf_;
  _impl_.leaf_ = nullptr;
  return temp;
}
inline ::cosmos::ics23::v1::LeafOp* ExistenceProof::_internal_mutable_leaf() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.leaf_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::cosmos::ics23::v1::LeafOp>(GetArena());
    _impl_.leaf_ = reinterpret_cast<::cosmos::ics23::v1::LeafOp*>(p);
  }
  return _impl_.leaf_;
}
inline ::cosmos::ics23::v1::LeafOp* ExistenceProof::mutable_leaf() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::cosmos::ics23::v1::LeafOp* _msg = _internal_mutable_leaf();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.ExistenceProof.leaf)
  return _msg;
}
inline void ExistenceProof::set_allocated_leaf(::cosmos::ics23::v1::LeafOp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.leaf_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.leaf_ = reinterpret_cast<::cosmos::ics23::v1::LeafOp*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.ExistenceProof.leaf)
}

// repeated .cosmos.ics23.v1.InnerOp path = 4 [json_name = "path"];
inline int ExistenceProof::_internal_path_size() const {
  return _internal_path().size();
}
inline int ExistenceProof::path_size() const {
  return _internal_path_size();
}
inline void ExistenceProof::clear_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.Clear();
}
inline ::cosmos::ics23::v1::InnerOp* ExistenceProof::mutable_path(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.ExistenceProof.path)
  return _internal_mutable_path()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>* ExistenceProof::mutable_path()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cosmos.ics23.v1.ExistenceProof.path)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_path();
}
inline const ::cosmos::ics23::v1::InnerOp& ExistenceProof::path(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.ExistenceProof.path)
  return _internal_path().Get(index);
}
inline ::cosmos::ics23::v1::InnerOp* ExistenceProof::add_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::cosmos::ics23::v1::InnerOp* _add = _internal_mutable_path()->Add();
  // @@protoc_insertion_point(field_add:cosmos.ics23.v1.ExistenceProof.path)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>& ExistenceProof::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cosmos.ics23.v1.ExistenceProof.path)
  return _internal_path();
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>&
ExistenceProof::_internal_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.path_;
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>*
ExistenceProof::_internal_mutable_path() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.path_;
}

// -------------------------------------------------------------------

// NonExistenceProof

// bytes key = 1 [json_name = "key"];
inline void NonExistenceProof::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& NonExistenceProof::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.NonExistenceProof.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NonExistenceProof::set_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.NonExistenceProof.key)
}
inline std::string* NonExistenceProof::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.NonExistenceProof.key)
  return _s;
}
inline const std::string& NonExistenceProof::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void NonExistenceProof::_internal_set_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline std::string* NonExistenceProof::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* NonExistenceProof::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.NonExistenceProof.key)
  return _impl_.key_.Release();
}
inline void NonExistenceProof::set_allocated_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.NonExistenceProof.key)
}

// .cosmos.ics23.v1.ExistenceProof left = 2 [json_name = "left"];
inline bool NonExistenceProof::has_left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_ != nullptr);
  return value;
}
inline void NonExistenceProof::clear_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.left_ != nullptr) _impl_.left_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cosmos::ics23::v1::ExistenceProof& NonExistenceProof::_internal_left() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::cosmos::ics23::v1::ExistenceProof* p = _impl_.left_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::ics23::v1::ExistenceProof&>(::cosmos::ics23::v1::_ExistenceProof_default_instance_);
}
inline const ::cosmos::ics23::v1::ExistenceProof& NonExistenceProof::left() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.NonExistenceProof.left)
  return _internal_left();
}
inline void NonExistenceProof::unsafe_arena_set_allocated_left(::cosmos::ics23::v1::ExistenceProof* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.left_);
  }
  _impl_.left_ = reinterpret_cast<::cosmos::ics23::v1::ExistenceProof*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.NonExistenceProof.left)
}
inline ::cosmos::ics23::v1::ExistenceProof* NonExistenceProof::release_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::ics23::v1::ExistenceProof* released = _impl_.left_;
  _impl_.left_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::cosmos::ics23::v1::ExistenceProof* NonExistenceProof::unsafe_arena_release_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.NonExistenceProof.left)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::ics23::v1::ExistenceProof* temp = _impl_.left_;
  _impl_.left_ = nullptr;
  return temp;
}
inline ::cosmos::ics23::v1::ExistenceProof* NonExistenceProof::_internal_mutable_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.left_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::cosmos::ics23::v1::ExistenceProof>(GetArena());
    _impl_.left_ = reinterpret_cast<::cosmos::ics23::v1::ExistenceProof*>(p);
  }
  return _impl_.left_;
}
inline ::cosmos::ics23::v1::ExistenceProof* NonExistenceProof::mutable_left() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::cosmos::ics23::v1::ExistenceProof* _msg = _internal_mutable_left();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.NonExistenceProof.left)
  return _msg;
}
inline void NonExistenceProof::set_allocated_left(::cosmos::ics23::v1::ExistenceProof* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.left_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.left_ = reinterpret_cast<::cosmos::ics23::v1::ExistenceProof*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.NonExistenceProof.left)
}

// .cosmos.ics23.v1.ExistenceProof right = 3 [json_name = "right"];
inline bool NonExistenceProof::has_right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_ != nullptr);
  return value;
}
inline void NonExistenceProof::clear_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.right_ != nullptr) _impl_.right_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::cosmos::ics23::v1::ExistenceProof& NonExistenceProof::_internal_right() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::cosmos::ics23::v1::ExistenceProof* p = _impl_.right_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::ics23::v1::ExistenceProof&>(::cosmos::ics23::v1::_ExistenceProof_default_instance_);
}
inline const ::cosmos::ics23::v1::ExistenceProof& NonExistenceProof::right() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.NonExistenceProof.right)
  return _internal_right();
}
inline void NonExistenceProof::unsafe_arena_set_allocated_right(::cosmos::ics23::v1::ExistenceProof* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_);
  }
  _impl_.right_ = reinterpret_cast<::cosmos::ics23::v1::ExistenceProof*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.NonExistenceProof.right)
}
inline ::cosmos::ics23::v1::ExistenceProof* NonExistenceProof::release_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::ics23::v1::ExistenceProof* released = _impl_.right_;
  _impl_.right_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::cosmos::ics23::v1::ExistenceProof* NonExistenceProof::unsafe_arena_release_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.NonExistenceProof.right)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::ics23::v1::ExistenceProof* temp = _impl_.right_;
  _impl_.right_ = nullptr;
  return temp;
}
inline ::cosmos::ics23::v1::ExistenceProof* NonExistenceProof::_internal_mutable_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.right_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::cosmos::ics23::v1::ExistenceProof>(GetArena());
    _impl_.right_ = reinterpret_cast<::cosmos::ics23::v1::ExistenceProof*>(p);
  }
  return _impl_.right_;
}
inline ::cosmos::ics23::v1::ExistenceProof* NonExistenceProof::mutable_right() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::cosmos::ics23::v1::ExistenceProof* _msg = _internal_mutable_right();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.NonExistenceProof.right)
  return _msg;
}
inline void NonExistenceProof::set_allocated_right(::cosmos::ics23::v1::ExistenceProof* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.right_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.right_ = reinterpret_cast<::cosmos::ics23::v1::ExistenceProof*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.NonExistenceProof.right)
}

// -------------------------------------------------------------------

// CommitmentProof

// .cosmos.ics23.v1.ExistenceProof exist = 1 [json_name = "exist"];
inline bool CommitmentProof::has_exist() const {
  return proof_case() == kExist;
}
inline bool CommitmentProof::_internal_has_exist() const {
  return proof_case() == kExist;
}
inline void CommitmentProof::set_has_exist() {
  _impl_._oneof_case_[0] = kExist;
}
inline void CommitmentProof::clear_exist() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (proof_case() == kExist) {
    if (GetArena() == nullptr) {
      delete _impl_.proof_.exist_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.proof_.exist_);
    }
    clear_has_proof();
  }
}
inline ::cosmos::ics23::v1::ExistenceProof* CommitmentProof::release_exist() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CommitmentProof.exist)
  if (proof_case() == kExist) {
    clear_has_proof();
    auto* temp = _impl_.proof_.exist_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.proof_.exist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cosmos::ics23::v1::ExistenceProof& CommitmentProof::_internal_exist() const {
  return proof_case() == kExist ? *_impl_.proof_.exist_ : reinterpret_cast<::cosmos::ics23::v1::ExistenceProof&>(::cosmos::ics23::v1::_ExistenceProof_default_instance_);
}
inline const ::cosmos::ics23::v1::ExistenceProof& CommitmentProof::exist() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CommitmentProof.exist)
  return _internal_exist();
}
inline ::cosmos::ics23::v1::ExistenceProof* CommitmentProof::unsafe_arena_release_exist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cosmos.ics23.v1.CommitmentProof.exist)
  if (proof_case() == kExist) {
    clear_has_proof();
    auto* temp = _impl_.proof_.exist_;
    _impl_.proof_.exist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CommitmentProof::unsafe_arena_set_allocated_exist(::cosmos::ics23::v1::ExistenceProof* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_proof();
  if (value) {
    set_has_exist();
    _impl_.proof_.exist_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.CommitmentProof.exist)
}
inline ::cosmos::ics23::v1::ExistenceProof* CommitmentProof::_internal_mutable_exist() {
  if (proof_case() != kExist) {
    clear_proof();
    set_has_exist();
    _impl_.proof_.exist_ =
        ::google::protobuf::Message::DefaultConstruct<::cosmos::ics23::v1::ExistenceProof>(GetArena());
  }
  return _impl_.proof_.exist_;
}
inline ::cosmos::ics23::v1::ExistenceProof* CommitmentProof::mutable_exist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cosmos::ics23::v1::ExistenceProof* _msg = _internal_mutable_exist();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CommitmentProof.exist)
  return _msg;
}

// .cosmos.ics23.v1.NonExistenceProof nonexist = 2 [json_name = "nonexist"];
inline bool CommitmentProof::has_nonexist() const {
  return proof_case() == kNonexist;
}
inline bool CommitmentProof::_internal_has_nonexist() const {
  return proof_case() == kNonexist;
}
inline void CommitmentProof::set_has_nonexist() {
  _impl_._oneof_case_[0] = kNonexist;
}
inline void CommitmentProof::clear_nonexist() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (proof_case() == kNonexist) {
    if (GetArena() == nullptr) {
      delete _impl_.proof_.nonexist_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.proof_.nonexist_);
    }
    clear_has_proof();
  }
}
inline ::cosmos::ics23::v1::NonExistenceProof* CommitmentProof::release_nonexist() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CommitmentProof.nonexist)
  if (proof_case() == kNonexist) {
    clear_has_proof();
    auto* temp = _impl_.proof_.nonexist_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.proof_.nonexist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cosmos::ics23::v1::NonExistenceProof& CommitmentProof::_internal_nonexist() const {
  return proof_case() == kNonexist ? *_impl_.proof_.nonexist_ : reinterpret_cast<::cosmos::ics23::v1::NonExistenceProof&>(::cosmos::ics23::v1::_NonExistenceProof_default_instance_);
}
inline const ::cosmos::ics23::v1::NonExistenceProof& CommitmentProof::nonexist() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CommitmentProof.nonexist)
  return _internal_nonexist();
}
inline ::cosmos::ics23::v1::NonExistenceProof* CommitmentProof::unsafe_arena_release_nonexist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cosmos.ics23.v1.CommitmentProof.nonexist)
  if (proof_case() == kNonexist) {
    clear_has_proof();
    auto* temp = _impl_.proof_.nonexist_;
    _impl_.proof_.nonexist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CommitmentProof::unsafe_arena_set_allocated_nonexist(::cosmos::ics23::v1::NonExistenceProof* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_proof();
  if (value) {
    set_has_nonexist();
    _impl_.proof_.nonexist_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.CommitmentProof.nonexist)
}
inline ::cosmos::ics23::v1::NonExistenceProof* CommitmentProof::_internal_mutable_nonexist() {
  if (proof_case() != kNonexist) {
    clear_proof();
    set_has_nonexist();
    _impl_.proof_.nonexist_ =
        ::google::protobuf::Message::DefaultConstruct<::cosmos::ics23::v1::NonExistenceProof>(GetArena());
  }
  return _impl_.proof_.nonexist_;
}
inline ::cosmos::ics23::v1::NonExistenceProof* CommitmentProof::mutable_nonexist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cosmos::ics23::v1::NonExistenceProof* _msg = _internal_mutable_nonexist();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CommitmentProof.nonexist)
  return _msg;
}

// .cosmos.ics23.v1.BatchProof batch = 3 [json_name = "batch"];
inline bool CommitmentProof::has_batch() const {
  return proof_case() == kBatch;
}
inline bool CommitmentProof::_internal_has_batch() const {
  return proof_case() == kBatch;
}
inline void CommitmentProof::set_has_batch() {
  _impl_._oneof_case_[0] = kBatch;
}
inline void CommitmentProof::clear_batch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (proof_case() == kBatch) {
    if (GetArena() == nullptr) {
      delete _impl_.proof_.batch_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.proof_.batch_);
    }
    clear_has_proof();
  }
}
inline ::cosmos::ics23::v1::BatchProof* CommitmentProof::release_batch() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CommitmentProof.batch)
  if (proof_case() == kBatch) {
    clear_has_proof();
    auto* temp = _impl_.proof_.batch_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.proof_.batch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cosmos::ics23::v1::BatchProof& CommitmentProof::_internal_batch() const {
  return proof_case() == kBatch ? *_impl_.proof_.batch_ : reinterpret_cast<::cosmos::ics23::v1::BatchProof&>(::cosmos::ics23::v1::_BatchProof_default_instance_);
}
inline const ::cosmos::ics23::v1::BatchProof& CommitmentProof::batch() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CommitmentProof.batch)
  return _internal_batch();
}
inline ::cosmos::ics23::v1::BatchProof* CommitmentProof::unsafe_arena_release_batch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cosmos.ics23.v1.CommitmentProof.batch)
  if (proof_case() == kBatch) {
    clear_has_proof();
    auto* temp = _impl_.proof_.batch_;
    _impl_.proof_.batch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CommitmentProof::unsafe_arena_set_allocated_batch(::cosmos::ics23::v1::BatchProof* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_proof();
  if (value) {
    set_has_batch();
    _impl_.proof_.batch_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.CommitmentProof.batch)
}
inline ::cosmos::ics23::v1::BatchProof* CommitmentProof::_internal_mutable_batch() {
  if (proof_case() != kBatch) {
    clear_proof();
    set_has_batch();
    _impl_.proof_.batch_ =
        ::google::protobuf::Message::DefaultConstruct<::cosmos::ics23::v1::BatchProof>(GetArena());
  }
  return _impl_.proof_.batch_;
}
inline ::cosmos::ics23::v1::BatchProof* CommitmentProof::mutable_batch() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cosmos::ics23::v1::BatchProof* _msg = _internal_mutable_batch();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CommitmentProof.batch)
  return _msg;
}

// .cosmos.ics23.v1.CompressedBatchProof compressed = 4 [json_name = "compressed"];
inline bool CommitmentProof::has_compressed() const {
  return proof_case() == kCompressed;
}
inline bool CommitmentProof::_internal_has_compressed() const {
  return proof_case() == kCompressed;
}
inline void CommitmentProof::set_has_compressed() {
  _impl_._oneof_case_[0] = kCompressed;
}
inline void CommitmentProof::clear_compressed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (proof_case() == kCompressed) {
    if (GetArena() == nullptr) {
      delete _impl_.proof_.compressed_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.proof_.compressed_);
    }
    clear_has_proof();
  }
}
inline ::cosmos::ics23::v1::CompressedBatchProof* CommitmentProof::release_compressed() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CommitmentProof.compressed)
  if (proof_case() == kCompressed) {
    clear_has_proof();
    auto* temp = _impl_.proof_.compressed_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.proof_.compressed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cosmos::ics23::v1::CompressedBatchProof& CommitmentProof::_internal_compressed() const {
  return proof_case() == kCompressed ? *_impl_.proof_.compressed_ : reinterpret_cast<::cosmos::ics23::v1::CompressedBatchProof&>(::cosmos::ics23::v1::_CompressedBatchProof_default_instance_);
}
inline const ::cosmos::ics23::v1::CompressedBatchProof& CommitmentProof::compressed() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CommitmentProof.compressed)
  return _internal_compressed();
}
inline ::cosmos::ics23::v1::CompressedBatchProof* CommitmentProof::unsafe_arena_release_compressed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cosmos.ics23.v1.CommitmentProof.compressed)
  if (proof_case() == kCompressed) {
    clear_has_proof();
    auto* temp = _impl_.proof_.compressed_;
    _impl_.proof_.compressed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CommitmentProof::unsafe_arena_set_allocated_compressed(::cosmos::ics23::v1::CompressedBatchProof* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_proof();
  if (value) {
    set_has_compressed();
    _impl_.proof_.compressed_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.CommitmentProof.compressed)
}
inline ::cosmos::ics23::v1::CompressedBatchProof* CommitmentProof::_internal_mutable_compressed() {
  if (proof_case() != kCompressed) {
    clear_proof();
    set_has_compressed();
    _impl_.proof_.compressed_ =
        ::google::protobuf::Message::DefaultConstruct<::cosmos::ics23::v1::CompressedBatchProof>(GetArena());
  }
  return _impl_.proof_.compressed_;
}
inline ::cosmos::ics23::v1::CompressedBatchProof* CommitmentProof::mutable_compressed() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cosmos::ics23::v1::CompressedBatchProof* _msg = _internal_mutable_compressed();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CommitmentProof.compressed)
  return _msg;
}

inline bool CommitmentProof::has_proof() const {
  return proof_case() != PROOF_NOT_SET;
}
inline void CommitmentProof::clear_has_proof() {
  _impl_._oneof_case_[0] = PROOF_NOT_SET;
}
inline CommitmentProof::ProofCase CommitmentProof::proof_case() const {
  return CommitmentProof::ProofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LeafOp

// .cosmos.ics23.v1.HashOp hash = 1 [json_name = "hash"];
inline void LeafOp::clear_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_ = 0;
}
inline ::cosmos::ics23::v1::HashOp LeafOp::hash() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.LeafOp.hash)
  return _internal_hash();
}
inline void LeafOp::set_hash(::cosmos::ics23::v1::HashOp value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.LeafOp.hash)
}
inline ::cosmos::ics23::v1::HashOp LeafOp::_internal_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::cosmos::ics23::v1::HashOp>(_impl_.hash_);
}
inline void LeafOp::_internal_set_hash(::cosmos::ics23::v1::HashOp value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_ = value;
}

// .cosmos.ics23.v1.HashOp prehash_key = 2 [json_name = "prehashKey"];
inline void LeafOp::clear_prehash_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prehash_key_ = 0;
}
inline ::cosmos::ics23::v1::HashOp LeafOp::prehash_key() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.LeafOp.prehash_key)
  return _internal_prehash_key();
}
inline void LeafOp::set_prehash_key(::cosmos::ics23::v1::HashOp value) {
  _internal_set_prehash_key(value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.LeafOp.prehash_key)
}
inline ::cosmos::ics23::v1::HashOp LeafOp::_internal_prehash_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::cosmos::ics23::v1::HashOp>(_impl_.prehash_key_);
}
inline void LeafOp::_internal_set_prehash_key(::cosmos::ics23::v1::HashOp value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prehash_key_ = value;
}

// .cosmos.ics23.v1.HashOp prehash_value = 3 [json_name = "prehashValue"];
inline void LeafOp::clear_prehash_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prehash_value_ = 0;
}
inline ::cosmos::ics23::v1::HashOp LeafOp::prehash_value() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.LeafOp.prehash_value)
  return _internal_prehash_value();
}
inline void LeafOp::set_prehash_value(::cosmos::ics23::v1::HashOp value) {
  _internal_set_prehash_value(value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.LeafOp.prehash_value)
}
inline ::cosmos::ics23::v1::HashOp LeafOp::_internal_prehash_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::cosmos::ics23::v1::HashOp>(_impl_.prehash_value_);
}
inline void LeafOp::_internal_set_prehash_value(::cosmos::ics23::v1::HashOp value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prehash_value_ = value;
}

// .cosmos.ics23.v1.LengthOp length = 4 [json_name = "length"];
inline void LeafOp::clear_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.length_ = 0;
}
inline ::cosmos::ics23::v1::LengthOp LeafOp::length() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.LeafOp.length)
  return _internal_length();
}
inline void LeafOp::set_length(::cosmos::ics23::v1::LengthOp value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.LeafOp.length)
}
inline ::cosmos::ics23::v1::LengthOp LeafOp::_internal_length() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::cosmos::ics23::v1::LengthOp>(_impl_.length_);
}
inline void LeafOp::_internal_set_length(::cosmos::ics23::v1::LengthOp value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.length_ = value;
}

// bytes prefix = 5 [json_name = "prefix"];
inline void LeafOp::clear_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prefix_.ClearToEmpty();
}
inline const std::string& LeafOp::prefix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.LeafOp.prefix)
  return _internal_prefix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LeafOp::set_prefix(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prefix_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.LeafOp.prefix)
}
inline std::string* LeafOp::mutable_prefix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.LeafOp.prefix)
  return _s;
}
inline const std::string& LeafOp::_internal_prefix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prefix_.Get();
}
inline void LeafOp::_internal_set_prefix(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prefix_.Set(value, GetArena());
}
inline std::string* LeafOp::_internal_mutable_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.prefix_.Mutable( GetArena());
}
inline std::string* LeafOp::release_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.LeafOp.prefix)
  return _impl_.prefix_.Release();
}
inline void LeafOp::set_allocated_prefix(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prefix_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.prefix_.IsDefault()) {
    _impl_.prefix_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.LeafOp.prefix)
}

// -------------------------------------------------------------------

// InnerOp

// .cosmos.ics23.v1.HashOp hash = 1 [json_name = "hash"];
inline void InnerOp::clear_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_ = 0;
}
inline ::cosmos::ics23::v1::HashOp InnerOp::hash() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.InnerOp.hash)
  return _internal_hash();
}
inline void InnerOp::set_hash(::cosmos::ics23::v1::HashOp value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.InnerOp.hash)
}
inline ::cosmos::ics23::v1::HashOp InnerOp::_internal_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::cosmos::ics23::v1::HashOp>(_impl_.hash_);
}
inline void InnerOp::_internal_set_hash(::cosmos::ics23::v1::HashOp value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_ = value;
}

// bytes prefix = 2 [json_name = "prefix"];
inline void InnerOp::clear_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prefix_.ClearToEmpty();
}
inline const std::string& InnerOp::prefix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.InnerOp.prefix)
  return _internal_prefix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InnerOp::set_prefix(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prefix_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.InnerOp.prefix)
}
inline std::string* InnerOp::mutable_prefix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.InnerOp.prefix)
  return _s;
}
inline const std::string& InnerOp::_internal_prefix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prefix_.Get();
}
inline void InnerOp::_internal_set_prefix(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prefix_.Set(value, GetArena());
}
inline std::string* InnerOp::_internal_mutable_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.prefix_.Mutable( GetArena());
}
inline std::string* InnerOp::release_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.InnerOp.prefix)
  return _impl_.prefix_.Release();
}
inline void InnerOp::set_allocated_prefix(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prefix_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.prefix_.IsDefault()) {
    _impl_.prefix_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.InnerOp.prefix)
}

// bytes suffix = 3 [json_name = "suffix"];
inline void InnerOp::clear_suffix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.suffix_.ClearToEmpty();
}
inline const std::string& InnerOp::suffix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.InnerOp.suffix)
  return _internal_suffix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InnerOp::set_suffix(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.suffix_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.InnerOp.suffix)
}
inline std::string* InnerOp::mutable_suffix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_suffix();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.InnerOp.suffix)
  return _s;
}
inline const std::string& InnerOp::_internal_suffix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.suffix_.Get();
}
inline void InnerOp::_internal_set_suffix(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.suffix_.Set(value, GetArena());
}
inline std::string* InnerOp::_internal_mutable_suffix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.suffix_.Mutable( GetArena());
}
inline std::string* InnerOp::release_suffix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.InnerOp.suffix)
  return _impl_.suffix_.Release();
}
inline void InnerOp::set_allocated_suffix(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.suffix_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.suffix_.IsDefault()) {
    _impl_.suffix_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.InnerOp.suffix)
}

// -------------------------------------------------------------------

// ProofSpec

// .cosmos.ics23.v1.LeafOp leaf_spec = 1 [json_name = "leafSpec"];
inline bool ProofSpec::has_leaf_spec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.leaf_spec_ != nullptr);
  return value;
}
inline void ProofSpec::clear_leaf_spec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.leaf_spec_ != nullptr) _impl_.leaf_spec_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cosmos::ics23::v1::LeafOp& ProofSpec::_internal_leaf_spec() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::cosmos::ics23::v1::LeafOp* p = _impl_.leaf_spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::ics23::v1::LeafOp&>(::cosmos::ics23::v1::_LeafOp_default_instance_);
}
inline const ::cosmos::ics23::v1::LeafOp& ProofSpec::leaf_spec() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.ProofSpec.leaf_spec)
  return _internal_leaf_spec();
}
inline void ProofSpec::unsafe_arena_set_allocated_leaf_spec(::cosmos::ics23::v1::LeafOp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.leaf_spec_);
  }
  _impl_.leaf_spec_ = reinterpret_cast<::cosmos::ics23::v1::LeafOp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.ProofSpec.leaf_spec)
}
inline ::cosmos::ics23::v1::LeafOp* ProofSpec::release_leaf_spec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::ics23::v1::LeafOp* released = _impl_.leaf_spec_;
  _impl_.leaf_spec_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::cosmos::ics23::v1::LeafOp* ProofSpec::unsafe_arena_release_leaf_spec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.ProofSpec.leaf_spec)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::ics23::v1::LeafOp* temp = _impl_.leaf_spec_;
  _impl_.leaf_spec_ = nullptr;
  return temp;
}
inline ::cosmos::ics23::v1::LeafOp* ProofSpec::_internal_mutable_leaf_spec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.leaf_spec_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::cosmos::ics23::v1::LeafOp>(GetArena());
    _impl_.leaf_spec_ = reinterpret_cast<::cosmos::ics23::v1::LeafOp*>(p);
  }
  return _impl_.leaf_spec_;
}
inline ::cosmos::ics23::v1::LeafOp* ProofSpec::mutable_leaf_spec() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::cosmos::ics23::v1::LeafOp* _msg = _internal_mutable_leaf_spec();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.ProofSpec.leaf_spec)
  return _msg;
}
inline void ProofSpec::set_allocated_leaf_spec(::cosmos::ics23::v1::LeafOp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.leaf_spec_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.leaf_spec_ = reinterpret_cast<::cosmos::ics23::v1::LeafOp*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.ProofSpec.leaf_spec)
}

// .cosmos.ics23.v1.InnerSpec inner_spec = 2 [json_name = "innerSpec"];
inline bool ProofSpec::has_inner_spec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.inner_spec_ != nullptr);
  return value;
}
inline void ProofSpec::clear_inner_spec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.inner_spec_ != nullptr) _impl_.inner_spec_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::cosmos::ics23::v1::InnerSpec& ProofSpec::_internal_inner_spec() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::cosmos::ics23::v1::InnerSpec* p = _impl_.inner_spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::ics23::v1::InnerSpec&>(::cosmos::ics23::v1::_InnerSpec_default_instance_);
}
inline const ::cosmos::ics23::v1::InnerSpec& ProofSpec::inner_spec() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.ProofSpec.inner_spec)
  return _internal_inner_spec();
}
inline void ProofSpec::unsafe_arena_set_allocated_inner_spec(::cosmos::ics23::v1::InnerSpec* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.inner_spec_);
  }
  _impl_.inner_spec_ = reinterpret_cast<::cosmos::ics23::v1::InnerSpec*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.ProofSpec.inner_spec)
}
inline ::cosmos::ics23::v1::InnerSpec* ProofSpec::release_inner_spec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::ics23::v1::InnerSpec* released = _impl_.inner_spec_;
  _impl_.inner_spec_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::cosmos::ics23::v1::InnerSpec* ProofSpec::unsafe_arena_release_inner_spec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.ProofSpec.inner_spec)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::ics23::v1::InnerSpec* temp = _impl_.inner_spec_;
  _impl_.inner_spec_ = nullptr;
  return temp;
}
inline ::cosmos::ics23::v1::InnerSpec* ProofSpec::_internal_mutable_inner_spec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.inner_spec_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::cosmos::ics23::v1::InnerSpec>(GetArena());
    _impl_.inner_spec_ = reinterpret_cast<::cosmos::ics23::v1::InnerSpec*>(p);
  }
  return _impl_.inner_spec_;
}
inline ::cosmos::ics23::v1::InnerSpec* ProofSpec::mutable_inner_spec() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::cosmos::ics23::v1::InnerSpec* _msg = _internal_mutable_inner_spec();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.ProofSpec.inner_spec)
  return _msg;
}
inline void ProofSpec::set_allocated_inner_spec(::cosmos::ics23::v1::InnerSpec* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.inner_spec_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.inner_spec_ = reinterpret_cast<::cosmos::ics23::v1::InnerSpec*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.ProofSpec.inner_spec)
}

// int32 max_depth = 3 [json_name = "maxDepth"];
inline void ProofSpec::clear_max_depth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_depth_ = 0;
}
inline ::int32_t ProofSpec::max_depth() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.ProofSpec.max_depth)
  return _internal_max_depth();
}
inline void ProofSpec::set_max_depth(::int32_t value) {
  _internal_set_max_depth(value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.ProofSpec.max_depth)
}
inline ::int32_t ProofSpec::_internal_max_depth() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_depth_;
}
inline void ProofSpec::_internal_set_max_depth(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_depth_ = value;
}

// int32 min_depth = 4 [json_name = "minDepth"];
inline void ProofSpec::clear_min_depth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_depth_ = 0;
}
inline ::int32_t ProofSpec::min_depth() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.ProofSpec.min_depth)
  return _internal_min_depth();
}
inline void ProofSpec::set_min_depth(::int32_t value) {
  _internal_set_min_depth(value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.ProofSpec.min_depth)
}
inline ::int32_t ProofSpec::_internal_min_depth() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_depth_;
}
inline void ProofSpec::_internal_set_min_depth(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_depth_ = value;
}

// -------------------------------------------------------------------

// InnerSpec

// repeated int32 child_order = 1 [json_name = "childOrder"];
inline int InnerSpec::_internal_child_order_size() const {
  return _internal_child_order().size();
}
inline int InnerSpec::child_order_size() const {
  return _internal_child_order_size();
}
inline void InnerSpec::clear_child_order() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.child_order_.Clear();
}
inline ::int32_t InnerSpec::child_order(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.InnerSpec.child_order)
  return _internal_child_order().Get(index);
}
inline void InnerSpec::set_child_order(int index, ::int32_t value) {
  _internal_mutable_child_order()->Set(index, value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.InnerSpec.child_order)
}
inline void InnerSpec::add_child_order(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_child_order()->Add(value);
  // @@protoc_insertion_point(field_add:cosmos.ics23.v1.InnerSpec.child_order)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& InnerSpec::child_order() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cosmos.ics23.v1.InnerSpec.child_order)
  return _internal_child_order();
}
inline ::google::protobuf::RepeatedField<::int32_t>* InnerSpec::mutable_child_order()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cosmos.ics23.v1.InnerSpec.child_order)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_child_order();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
InnerSpec::_internal_child_order() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.child_order_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* InnerSpec::_internal_mutable_child_order() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.child_order_;
}

// int32 child_size = 2 [json_name = "childSize"];
inline void InnerSpec::clear_child_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.child_size_ = 0;
}
inline ::int32_t InnerSpec::child_size() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.InnerSpec.child_size)
  return _internal_child_size();
}
inline void InnerSpec::set_child_size(::int32_t value) {
  _internal_set_child_size(value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.InnerSpec.child_size)
}
inline ::int32_t InnerSpec::_internal_child_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.child_size_;
}
inline void InnerSpec::_internal_set_child_size(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.child_size_ = value;
}

// int32 min_prefix_length = 3 [json_name = "minPrefixLength"];
inline void InnerSpec::clear_min_prefix_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_prefix_length_ = 0;
}
inline ::int32_t InnerSpec::min_prefix_length() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.InnerSpec.min_prefix_length)
  return _internal_min_prefix_length();
}
inline void InnerSpec::set_min_prefix_length(::int32_t value) {
  _internal_set_min_prefix_length(value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.InnerSpec.min_prefix_length)
}
inline ::int32_t InnerSpec::_internal_min_prefix_length() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_prefix_length_;
}
inline void InnerSpec::_internal_set_min_prefix_length(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_prefix_length_ = value;
}

// int32 max_prefix_length = 4 [json_name = "maxPrefixLength"];
inline void InnerSpec::clear_max_prefix_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_prefix_length_ = 0;
}
inline ::int32_t InnerSpec::max_prefix_length() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.InnerSpec.max_prefix_length)
  return _internal_max_prefix_length();
}
inline void InnerSpec::set_max_prefix_length(::int32_t value) {
  _internal_set_max_prefix_length(value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.InnerSpec.max_prefix_length)
}
inline ::int32_t InnerSpec::_internal_max_prefix_length() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_prefix_length_;
}
inline void InnerSpec::_internal_set_max_prefix_length(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_prefix_length_ = value;
}

// bytes empty_child = 5 [json_name = "emptyChild"];
inline void InnerSpec::clear_empty_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.empty_child_.ClearToEmpty();
}
inline const std::string& InnerSpec::empty_child() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.InnerSpec.empty_child)
  return _internal_empty_child();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InnerSpec::set_empty_child(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.empty_child_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.InnerSpec.empty_child)
}
inline std::string* InnerSpec::mutable_empty_child() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_empty_child();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.InnerSpec.empty_child)
  return _s;
}
inline const std::string& InnerSpec::_internal_empty_child() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.empty_child_.Get();
}
inline void InnerSpec::_internal_set_empty_child(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.empty_child_.Set(value, GetArena());
}
inline std::string* InnerSpec::_internal_mutable_empty_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.empty_child_.Mutable( GetArena());
}
inline std::string* InnerSpec::release_empty_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.InnerSpec.empty_child)
  return _impl_.empty_child_.Release();
}
inline void InnerSpec::set_allocated_empty_child(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.empty_child_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.empty_child_.IsDefault()) {
    _impl_.empty_child_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.InnerSpec.empty_child)
}

// .cosmos.ics23.v1.HashOp hash = 6 [json_name = "hash"];
inline void InnerSpec::clear_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_ = 0;
}
inline ::cosmos::ics23::v1::HashOp InnerSpec::hash() const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.InnerSpec.hash)
  return _internal_hash();
}
inline void InnerSpec::set_hash(::cosmos::ics23::v1::HashOp value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.InnerSpec.hash)
}
inline ::cosmos::ics23::v1::HashOp InnerSpec::_internal_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::cosmos::ics23::v1::HashOp>(_impl_.hash_);
}
inline void InnerSpec::_internal_set_hash(::cosmos::ics23::v1::HashOp value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_ = value;
}

// -------------------------------------------------------------------

// BatchProof

// repeated .cosmos.ics23.v1.BatchEntry entries = 1 [json_name = "entries"];
inline int BatchProof::_internal_entries_size() const {
  return _internal_entries().size();
}
inline int BatchProof::entries_size() const {
  return _internal_entries_size();
}
inline void BatchProof::clear_entries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entries_.Clear();
}
inline ::cosmos::ics23::v1::BatchEntry* BatchProof::mutable_entries(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.BatchProof.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::BatchEntry>* BatchProof::mutable_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cosmos.ics23.v1.BatchProof.entries)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entries();
}
inline const ::cosmos::ics23::v1::BatchEntry& BatchProof::entries(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.BatchProof.entries)
  return _internal_entries().Get(index);
}
inline ::cosmos::ics23::v1::BatchEntry* BatchProof::add_entries() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::cosmos::ics23::v1::BatchEntry* _add = _internal_mutable_entries()->Add();
  // @@protoc_insertion_point(field_add:cosmos.ics23.v1.BatchProof.entries)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::BatchEntry>& BatchProof::entries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cosmos.ics23.v1.BatchProof.entries)
  return _internal_entries();
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::BatchEntry>&
BatchProof::_internal_entries() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entries_;
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::BatchEntry>*
BatchProof::_internal_mutable_entries() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entries_;
}

// -------------------------------------------------------------------

// BatchEntry

// .cosmos.ics23.v1.ExistenceProof exist = 1 [json_name = "exist"];
inline bool BatchEntry::has_exist() const {
  return proof_case() == kExist;
}
inline bool BatchEntry::_internal_has_exist() const {
  return proof_case() == kExist;
}
inline void BatchEntry::set_has_exist() {
  _impl_._oneof_case_[0] = kExist;
}
inline void BatchEntry::clear_exist() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (proof_case() == kExist) {
    if (GetArena() == nullptr) {
      delete _impl_.proof_.exist_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.proof_.exist_);
    }
    clear_has_proof();
  }
}
inline ::cosmos::ics23::v1::ExistenceProof* BatchEntry::release_exist() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.BatchEntry.exist)
  if (proof_case() == kExist) {
    clear_has_proof();
    auto* temp = _impl_.proof_.exist_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.proof_.exist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cosmos::ics23::v1::ExistenceProof& BatchEntry::_internal_exist() const {
  return proof_case() == kExist ? *_impl_.proof_.exist_ : reinterpret_cast<::cosmos::ics23::v1::ExistenceProof&>(::cosmos::ics23::v1::_ExistenceProof_default_instance_);
}
inline const ::cosmos::ics23::v1::ExistenceProof& BatchEntry::exist() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.BatchEntry.exist)
  return _internal_exist();
}
inline ::cosmos::ics23::v1::ExistenceProof* BatchEntry::unsafe_arena_release_exist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cosmos.ics23.v1.BatchEntry.exist)
  if (proof_case() == kExist) {
    clear_has_proof();
    auto* temp = _impl_.proof_.exist_;
    _impl_.proof_.exist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchEntry::unsafe_arena_set_allocated_exist(::cosmos::ics23::v1::ExistenceProof* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_proof();
  if (value) {
    set_has_exist();
    _impl_.proof_.exist_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.BatchEntry.exist)
}
inline ::cosmos::ics23::v1::ExistenceProof* BatchEntry::_internal_mutable_exist() {
  if (proof_case() != kExist) {
    clear_proof();
    set_has_exist();
    _impl_.proof_.exist_ =
        ::google::protobuf::Message::DefaultConstruct<::cosmos::ics23::v1::ExistenceProof>(GetArena());
  }
  return _impl_.proof_.exist_;
}
inline ::cosmos::ics23::v1::ExistenceProof* BatchEntry::mutable_exist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cosmos::ics23::v1::ExistenceProof* _msg = _internal_mutable_exist();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.BatchEntry.exist)
  return _msg;
}

// .cosmos.ics23.v1.NonExistenceProof nonexist = 2 [json_name = "nonexist"];
inline bool BatchEntry::has_nonexist() const {
  return proof_case() == kNonexist;
}
inline bool BatchEntry::_internal_has_nonexist() const {
  return proof_case() == kNonexist;
}
inline void BatchEntry::set_has_nonexist() {
  _impl_._oneof_case_[0] = kNonexist;
}
inline void BatchEntry::clear_nonexist() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (proof_case() == kNonexist) {
    if (GetArena() == nullptr) {
      delete _impl_.proof_.nonexist_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.proof_.nonexist_);
    }
    clear_has_proof();
  }
}
inline ::cosmos::ics23::v1::NonExistenceProof* BatchEntry::release_nonexist() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.BatchEntry.nonexist)
  if (proof_case() == kNonexist) {
    clear_has_proof();
    auto* temp = _impl_.proof_.nonexist_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.proof_.nonexist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cosmos::ics23::v1::NonExistenceProof& BatchEntry::_internal_nonexist() const {
  return proof_case() == kNonexist ? *_impl_.proof_.nonexist_ : reinterpret_cast<::cosmos::ics23::v1::NonExistenceProof&>(::cosmos::ics23::v1::_NonExistenceProof_default_instance_);
}
inline const ::cosmos::ics23::v1::NonExistenceProof& BatchEntry::nonexist() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.BatchEntry.nonexist)
  return _internal_nonexist();
}
inline ::cosmos::ics23::v1::NonExistenceProof* BatchEntry::unsafe_arena_release_nonexist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cosmos.ics23.v1.BatchEntry.nonexist)
  if (proof_case() == kNonexist) {
    clear_has_proof();
    auto* temp = _impl_.proof_.nonexist_;
    _impl_.proof_.nonexist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchEntry::unsafe_arena_set_allocated_nonexist(::cosmos::ics23::v1::NonExistenceProof* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_proof();
  if (value) {
    set_has_nonexist();
    _impl_.proof_.nonexist_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.BatchEntry.nonexist)
}
inline ::cosmos::ics23::v1::NonExistenceProof* BatchEntry::_internal_mutable_nonexist() {
  if (proof_case() != kNonexist) {
    clear_proof();
    set_has_nonexist();
    _impl_.proof_.nonexist_ =
        ::google::protobuf::Message::DefaultConstruct<::cosmos::ics23::v1::NonExistenceProof>(GetArena());
  }
  return _impl_.proof_.nonexist_;
}
inline ::cosmos::ics23::v1::NonExistenceProof* BatchEntry::mutable_nonexist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cosmos::ics23::v1::NonExistenceProof* _msg = _internal_mutable_nonexist();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.BatchEntry.nonexist)
  return _msg;
}

inline bool BatchEntry::has_proof() const {
  return proof_case() != PROOF_NOT_SET;
}
inline void BatchEntry::clear_has_proof() {
  _impl_._oneof_case_[0] = PROOF_NOT_SET;
}
inline BatchEntry::ProofCase BatchEntry::proof_case() const {
  return BatchEntry::ProofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CompressedBatchProof

// repeated .cosmos.ics23.v1.CompressedBatchEntry entries = 1 [json_name = "entries"];
inline int CompressedBatchProof::_internal_entries_size() const {
  return _internal_entries().size();
}
inline int CompressedBatchProof::entries_size() const {
  return _internal_entries_size();
}
inline void CompressedBatchProof::clear_entries() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entries_.Clear();
}
inline ::cosmos::ics23::v1::CompressedBatchEntry* CompressedBatchProof::mutable_entries(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CompressedBatchProof.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::CompressedBatchEntry>* CompressedBatchProof::mutable_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cosmos.ics23.v1.CompressedBatchProof.entries)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entries();
}
inline const ::cosmos::ics23::v1::CompressedBatchEntry& CompressedBatchProof::entries(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CompressedBatchProof.entries)
  return _internal_entries().Get(index);
}
inline ::cosmos::ics23::v1::CompressedBatchEntry* CompressedBatchProof::add_entries() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::cosmos::ics23::v1::CompressedBatchEntry* _add = _internal_mutable_entries()->Add();
  // @@protoc_insertion_point(field_add:cosmos.ics23.v1.CompressedBatchProof.entries)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::CompressedBatchEntry>& CompressedBatchProof::entries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cosmos.ics23.v1.CompressedBatchProof.entries)
  return _internal_entries();
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::CompressedBatchEntry>&
CompressedBatchProof::_internal_entries() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entries_;
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::CompressedBatchEntry>*
CompressedBatchProof::_internal_mutable_entries() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entries_;
}

// repeated .cosmos.ics23.v1.InnerOp lookup_inners = 2 [json_name = "lookupInners"];
inline int CompressedBatchProof::_internal_lookup_inners_size() const {
  return _internal_lookup_inners().size();
}
inline int CompressedBatchProof::lookup_inners_size() const {
  return _internal_lookup_inners_size();
}
inline void CompressedBatchProof::clear_lookup_inners() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.lookup_inners_.Clear();
}
inline ::cosmos::ics23::v1::InnerOp* CompressedBatchProof::mutable_lookup_inners(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CompressedBatchProof.lookup_inners)
  return _internal_mutable_lookup_inners()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>* CompressedBatchProof::mutable_lookup_inners()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cosmos.ics23.v1.CompressedBatchProof.lookup_inners)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_lookup_inners();
}
inline const ::cosmos::ics23::v1::InnerOp& CompressedBatchProof::lookup_inners(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CompressedBatchProof.lookup_inners)
  return _internal_lookup_inners().Get(index);
}
inline ::cosmos::ics23::v1::InnerOp* CompressedBatchProof::add_lookup_inners() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::cosmos::ics23::v1::InnerOp* _add = _internal_mutable_lookup_inners()->Add();
  // @@protoc_insertion_point(field_add:cosmos.ics23.v1.CompressedBatchProof.lookup_inners)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>& CompressedBatchProof::lookup_inners() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cosmos.ics23.v1.CompressedBatchProof.lookup_inners)
  return _internal_lookup_inners();
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>&
CompressedBatchProof::_internal_lookup_inners() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.lookup_inners_;
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::ics23::v1::InnerOp>*
CompressedBatchProof::_internal_mutable_lookup_inners() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.lookup_inners_;
}

// -------------------------------------------------------------------

// CompressedBatchEntry

// .cosmos.ics23.v1.CompressedExistenceProof exist = 1 [json_name = "exist"];
inline bool CompressedBatchEntry::has_exist() const {
  return proof_case() == kExist;
}
inline bool CompressedBatchEntry::_internal_has_exist() const {
  return proof_case() == kExist;
}
inline void CompressedBatchEntry::set_has_exist() {
  _impl_._oneof_case_[0] = kExist;
}
inline void CompressedBatchEntry::clear_exist() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (proof_case() == kExist) {
    if (GetArena() == nullptr) {
      delete _impl_.proof_.exist_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.proof_.exist_);
    }
    clear_has_proof();
  }
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedBatchEntry::release_exist() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CompressedBatchEntry.exist)
  if (proof_case() == kExist) {
    clear_has_proof();
    auto* temp = _impl_.proof_.exist_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.proof_.exist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cosmos::ics23::v1::CompressedExistenceProof& CompressedBatchEntry::_internal_exist() const {
  return proof_case() == kExist ? *_impl_.proof_.exist_ : reinterpret_cast<::cosmos::ics23::v1::CompressedExistenceProof&>(::cosmos::ics23::v1::_CompressedExistenceProof_default_instance_);
}
inline const ::cosmos::ics23::v1::CompressedExistenceProof& CompressedBatchEntry::exist() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CompressedBatchEntry.exist)
  return _internal_exist();
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedBatchEntry::unsafe_arena_release_exist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cosmos.ics23.v1.CompressedBatchEntry.exist)
  if (proof_case() == kExist) {
    clear_has_proof();
    auto* temp = _impl_.proof_.exist_;
    _impl_.proof_.exist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CompressedBatchEntry::unsafe_arena_set_allocated_exist(::cosmos::ics23::v1::CompressedExistenceProof* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_proof();
  if (value) {
    set_has_exist();
    _impl_.proof_.exist_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.CompressedBatchEntry.exist)
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedBatchEntry::_internal_mutable_exist() {
  if (proof_case() != kExist) {
    clear_proof();
    set_has_exist();
    _impl_.proof_.exist_ =
        ::google::protobuf::Message::DefaultConstruct<::cosmos::ics23::v1::CompressedExistenceProof>(GetArena());
  }
  return _impl_.proof_.exist_;
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedBatchEntry::mutable_exist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cosmos::ics23::v1::CompressedExistenceProof* _msg = _internal_mutable_exist();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CompressedBatchEntry.exist)
  return _msg;
}

// .cosmos.ics23.v1.CompressedNonExistenceProof nonexist = 2 [json_name = "nonexist"];
inline bool CompressedBatchEntry::has_nonexist() const {
  return proof_case() == kNonexist;
}
inline bool CompressedBatchEntry::_internal_has_nonexist() const {
  return proof_case() == kNonexist;
}
inline void CompressedBatchEntry::set_has_nonexist() {
  _impl_._oneof_case_[0] = kNonexist;
}
inline void CompressedBatchEntry::clear_nonexist() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (proof_case() == kNonexist) {
    if (GetArena() == nullptr) {
      delete _impl_.proof_.nonexist_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.proof_.nonexist_);
    }
    clear_has_proof();
  }
}
inline ::cosmos::ics23::v1::CompressedNonExistenceProof* CompressedBatchEntry::release_nonexist() {
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CompressedBatchEntry.nonexist)
  if (proof_case() == kNonexist) {
    clear_has_proof();
    auto* temp = _impl_.proof_.nonexist_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.proof_.nonexist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cosmos::ics23::v1::CompressedNonExistenceProof& CompressedBatchEntry::_internal_nonexist() const {
  return proof_case() == kNonexist ? *_impl_.proof_.nonexist_ : reinterpret_cast<::cosmos::ics23::v1::CompressedNonExistenceProof&>(::cosmos::ics23::v1::_CompressedNonExistenceProof_default_instance_);
}
inline const ::cosmos::ics23::v1::CompressedNonExistenceProof& CompressedBatchEntry::nonexist() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CompressedBatchEntry.nonexist)
  return _internal_nonexist();
}
inline ::cosmos::ics23::v1::CompressedNonExistenceProof* CompressedBatchEntry::unsafe_arena_release_nonexist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cosmos.ics23.v1.CompressedBatchEntry.nonexist)
  if (proof_case() == kNonexist) {
    clear_has_proof();
    auto* temp = _impl_.proof_.nonexist_;
    _impl_.proof_.nonexist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CompressedBatchEntry::unsafe_arena_set_allocated_nonexist(::cosmos::ics23::v1::CompressedNonExistenceProof* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_proof();
  if (value) {
    set_has_nonexist();
    _impl_.proof_.nonexist_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.CompressedBatchEntry.nonexist)
}
inline ::cosmos::ics23::v1::CompressedNonExistenceProof* CompressedBatchEntry::_internal_mutable_nonexist() {
  if (proof_case() != kNonexist) {
    clear_proof();
    set_has_nonexist();
    _impl_.proof_.nonexist_ =
        ::google::protobuf::Message::DefaultConstruct<::cosmos::ics23::v1::CompressedNonExistenceProof>(GetArena());
  }
  return _impl_.proof_.nonexist_;
}
inline ::cosmos::ics23::v1::CompressedNonExistenceProof* CompressedBatchEntry::mutable_nonexist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cosmos::ics23::v1::CompressedNonExistenceProof* _msg = _internal_mutable_nonexist();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CompressedBatchEntry.nonexist)
  return _msg;
}

inline bool CompressedBatchEntry::has_proof() const {
  return proof_case() != PROOF_NOT_SET;
}
inline void CompressedBatchEntry::clear_has_proof() {
  _impl_._oneof_case_[0] = PROOF_NOT_SET;
}
inline CompressedBatchEntry::ProofCase CompressedBatchEntry::proof_case() const {
  return CompressedBatchEntry::ProofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CompressedExistenceProof

// bytes key = 1 [json_name = "key"];
inline void CompressedExistenceProof::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& CompressedExistenceProof::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CompressedExistenceProof.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CompressedExistenceProof::set_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.CompressedExistenceProof.key)
}
inline std::string* CompressedExistenceProof::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CompressedExistenceProof.key)
  return _s;
}
inline const std::string& CompressedExistenceProof::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void CompressedExistenceProof::_internal_set_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline std::string* CompressedExistenceProof::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* CompressedExistenceProof::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CompressedExistenceProof.key)
  return _impl_.key_.Release();
}
inline void CompressedExistenceProof::set_allocated_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CompressedExistenceProof.key)
}

// bytes value = 2 [json_name = "value"];
inline void CompressedExistenceProof::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& CompressedExistenceProof::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CompressedExistenceProof.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CompressedExistenceProof::set_value(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.CompressedExistenceProof.value)
}
inline std::string* CompressedExistenceProof::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CompressedExistenceProof.value)
  return _s;
}
inline const std::string& CompressedExistenceProof::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_.Get();
}
inline void CompressedExistenceProof::_internal_set_value(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Set(value, GetArena());
}
inline std::string* CompressedExistenceProof::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* CompressedExistenceProof::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CompressedExistenceProof.value)
  return _impl_.value_.Release();
}
inline void CompressedExistenceProof::set_allocated_value(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CompressedExistenceProof.value)
}

// .cosmos.ics23.v1.LeafOp leaf = 3 [json_name = "leaf"];
inline bool CompressedExistenceProof::has_leaf() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.leaf_ != nullptr);
  return value;
}
inline void CompressedExistenceProof::clear_leaf() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.leaf_ != nullptr) _impl_.leaf_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cosmos::ics23::v1::LeafOp& CompressedExistenceProof::_internal_leaf() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::cosmos::ics23::v1::LeafOp* p = _impl_.leaf_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::ics23::v1::LeafOp&>(::cosmos::ics23::v1::_LeafOp_default_instance_);
}
inline const ::cosmos::ics23::v1::LeafOp& CompressedExistenceProof::leaf() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CompressedExistenceProof.leaf)
  return _internal_leaf();
}
inline void CompressedExistenceProof::unsafe_arena_set_allocated_leaf(::cosmos::ics23::v1::LeafOp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.leaf_);
  }
  _impl_.leaf_ = reinterpret_cast<::cosmos::ics23::v1::LeafOp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.CompressedExistenceProof.leaf)
}
inline ::cosmos::ics23::v1::LeafOp* CompressedExistenceProof::release_leaf() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::ics23::v1::LeafOp* released = _impl_.leaf_;
  _impl_.leaf_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::cosmos::ics23::v1::LeafOp* CompressedExistenceProof::unsafe_arena_release_leaf() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CompressedExistenceProof.leaf)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::ics23::v1::LeafOp* temp = _impl_.leaf_;
  _impl_.leaf_ = nullptr;
  return temp;
}
inline ::cosmos::ics23::v1::LeafOp* CompressedExistenceProof::_internal_mutable_leaf() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.leaf_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::cosmos::ics23::v1::LeafOp>(GetArena());
    _impl_.leaf_ = reinterpret_cast<::cosmos::ics23::v1::LeafOp*>(p);
  }
  return _impl_.leaf_;
}
inline ::cosmos::ics23::v1::LeafOp* CompressedExistenceProof::mutable_leaf() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::cosmos::ics23::v1::LeafOp* _msg = _internal_mutable_leaf();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CompressedExistenceProof.leaf)
  return _msg;
}
inline void CompressedExistenceProof::set_allocated_leaf(::cosmos::ics23::v1::LeafOp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.leaf_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.leaf_ = reinterpret_cast<::cosmos::ics23::v1::LeafOp*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CompressedExistenceProof.leaf)
}

// repeated int32 path = 4 [json_name = "path"];
inline int CompressedExistenceProof::_internal_path_size() const {
  return _internal_path().size();
}
inline int CompressedExistenceProof::path_size() const {
  return _internal_path_size();
}
inline void CompressedExistenceProof::clear_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.Clear();
}
inline ::int32_t CompressedExistenceProof::path(int index) const {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CompressedExistenceProof.path)
  return _internal_path().Get(index);
}
inline void CompressedExistenceProof::set_path(int index, ::int32_t value) {
  _internal_mutable_path()->Set(index, value);
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.CompressedExistenceProof.path)
}
inline void CompressedExistenceProof::add_path(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_path()->Add(value);
  // @@protoc_insertion_point(field_add:cosmos.ics23.v1.CompressedExistenceProof.path)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& CompressedExistenceProof::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cosmos.ics23.v1.CompressedExistenceProof.path)
  return _internal_path();
}
inline ::google::protobuf::RepeatedField<::int32_t>* CompressedExistenceProof::mutable_path()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cosmos.ics23.v1.CompressedExistenceProof.path)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_path();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
CompressedExistenceProof::_internal_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.path_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* CompressedExistenceProof::_internal_mutable_path() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.path_;
}

// -------------------------------------------------------------------

// CompressedNonExistenceProof

// bytes key = 1 [json_name = "key"];
inline void CompressedNonExistenceProof::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
}
inline const std::string& CompressedNonExistenceProof::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CompressedNonExistenceProof.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CompressedNonExistenceProof::set_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmos.ics23.v1.CompressedNonExistenceProof.key)
}
inline std::string* CompressedNonExistenceProof::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CompressedNonExistenceProof.key)
  return _s;
}
inline const std::string& CompressedNonExistenceProof::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void CompressedNonExistenceProof::_internal_set_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.Set(value, GetArena());
}
inline std::string* CompressedNonExistenceProof::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* CompressedNonExistenceProof::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CompressedNonExistenceProof.key)
  return _impl_.key_.Release();
}
inline void CompressedNonExistenceProof::set_allocated_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CompressedNonExistenceProof.key)
}

// .cosmos.ics23.v1.CompressedExistenceProof left = 2 [json_name = "left"];
inline bool CompressedNonExistenceProof::has_left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_ != nullptr);
  return value;
}
inline void CompressedNonExistenceProof::clear_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.left_ != nullptr) _impl_.left_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cosmos::ics23::v1::CompressedExistenceProof& CompressedNonExistenceProof::_internal_left() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::cosmos::ics23::v1::CompressedExistenceProof* p = _impl_.left_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::ics23::v1::CompressedExistenceProof&>(::cosmos::ics23::v1::_CompressedExistenceProof_default_instance_);
}
inline const ::cosmos::ics23::v1::CompressedExistenceProof& CompressedNonExistenceProof::left() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CompressedNonExistenceProof.left)
  return _internal_left();
}
inline void CompressedNonExistenceProof::unsafe_arena_set_allocated_left(::cosmos::ics23::v1::CompressedExistenceProof* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.left_);
  }
  _impl_.left_ = reinterpret_cast<::cosmos::ics23::v1::CompressedExistenceProof*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.CompressedNonExistenceProof.left)
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedNonExistenceProof::release_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::ics23::v1::CompressedExistenceProof* released = _impl_.left_;
  _impl_.left_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedNonExistenceProof::unsafe_arena_release_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CompressedNonExistenceProof.left)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmos::ics23::v1::CompressedExistenceProof* temp = _impl_.left_;
  _impl_.left_ = nullptr;
  return temp;
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedNonExistenceProof::_internal_mutable_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.left_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::cosmos::ics23::v1::CompressedExistenceProof>(GetArena());
    _impl_.left_ = reinterpret_cast<::cosmos::ics23::v1::CompressedExistenceProof*>(p);
  }
  return _impl_.left_;
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedNonExistenceProof::mutable_left() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::cosmos::ics23::v1::CompressedExistenceProof* _msg = _internal_mutable_left();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CompressedNonExistenceProof.left)
  return _msg;
}
inline void CompressedNonExistenceProof::set_allocated_left(::cosmos::ics23::v1::CompressedExistenceProof* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.left_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.left_ = reinterpret_cast<::cosmos::ics23::v1::CompressedExistenceProof*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CompressedNonExistenceProof.left)
}

// .cosmos.ics23.v1.CompressedExistenceProof right = 3 [json_name = "right"];
inline bool CompressedNonExistenceProof::has_right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_ != nullptr);
  return value;
}
inline void CompressedNonExistenceProof::clear_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.right_ != nullptr) _impl_.right_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::cosmos::ics23::v1::CompressedExistenceProof& CompressedNonExistenceProof::_internal_right() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::cosmos::ics23::v1::CompressedExistenceProof* p = _impl_.right_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmos::ics23::v1::CompressedExistenceProof&>(::cosmos::ics23::v1::_CompressedExistenceProof_default_instance_);
}
inline const ::cosmos::ics23::v1::CompressedExistenceProof& CompressedNonExistenceProof::right() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmos.ics23.v1.CompressedNonExistenceProof.right)
  return _internal_right();
}
inline void CompressedNonExistenceProof::unsafe_arena_set_allocated_right(::cosmos::ics23::v1::CompressedExistenceProof* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_);
  }
  _impl_.right_ = reinterpret_cast<::cosmos::ics23::v1::CompressedExistenceProof*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmos.ics23.v1.CompressedNonExistenceProof.right)
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedNonExistenceProof::release_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::ics23::v1::CompressedExistenceProof* released = _impl_.right_;
  _impl_.right_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedNonExistenceProof::unsafe_arena_release_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmos.ics23.v1.CompressedNonExistenceProof.right)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::cosmos::ics23::v1::CompressedExistenceProof* temp = _impl_.right_;
  _impl_.right_ = nullptr;
  return temp;
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedNonExistenceProof::_internal_mutable_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.right_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::cosmos::ics23::v1::CompressedExistenceProof>(GetArena());
    _impl_.right_ = reinterpret_cast<::cosmos::ics23::v1::CompressedExistenceProof*>(p);
  }
  return _impl_.right_;
}
inline ::cosmos::ics23::v1::CompressedExistenceProof* CompressedNonExistenceProof::mutable_right() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::cosmos::ics23::v1::CompressedExistenceProof* _msg = _internal_mutable_right();
  // @@protoc_insertion_point(field_mutable:cosmos.ics23.v1.CompressedNonExistenceProof.right)
  return _msg;
}
inline void CompressedNonExistenceProof::set_allocated_right(::cosmos::ics23::v1::CompressedExistenceProof* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.right_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.right_ = reinterpret_cast<::cosmos::ics23::v1::CompressedExistenceProof*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmos.ics23.v1.CompressedNonExistenceProof.right)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace ics23
}  // namespace cosmos


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::cosmos::ics23::v1::HashOp> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cosmos::ics23::v1::HashOp>() {
  return ::cosmos::ics23::v1::HashOp_descriptor();
}
template <>
struct is_proto_enum<::cosmos::ics23::v1::LengthOp> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cosmos::ics23::v1::LengthOp>() {
  return ::cosmos::ics23::v1::LengthOp_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // cosmos_2fics23_2fv1_2fproofs_2eproto_2epb_2eh
