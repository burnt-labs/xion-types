// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: cosmwasm/wasm/v1/authz.proto
// Protobuf C++ Version: 5.29.4

#ifndef cosmwasm_2fwasm_2fv1_2fauthz_2eproto_2epb_2eh
#define cosmwasm_2fwasm_2fv1_2fauthz_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029004
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "gogoproto/gogo.pb.h"
#include "cosmos_proto/cosmos.pb.h"
#include "cosmos/base/v1beta1/coin.pb.h"
#include "cosmwasm/wasm/v1/types.pb.h"
#include "google/protobuf/any.pb.h"
#include "amino/amino.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_cosmwasm_2fwasm_2fv1_2fauthz_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_cosmwasm_2fwasm_2fv1_2fauthz_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_cosmwasm_2fwasm_2fv1_2fauthz_2eproto;
namespace cosmwasm {
namespace wasm {
namespace v1 {
class AcceptedMessageKeysFilter;
struct AcceptedMessageKeysFilterDefaultTypeInternal;
extern AcceptedMessageKeysFilterDefaultTypeInternal _AcceptedMessageKeysFilter_default_instance_;
class AcceptedMessagesFilter;
struct AcceptedMessagesFilterDefaultTypeInternal;
extern AcceptedMessagesFilterDefaultTypeInternal _AcceptedMessagesFilter_default_instance_;
class AllowAllMessagesFilter;
struct AllowAllMessagesFilterDefaultTypeInternal;
extern AllowAllMessagesFilterDefaultTypeInternal _AllowAllMessagesFilter_default_instance_;
class CodeGrant;
struct CodeGrantDefaultTypeInternal;
extern CodeGrantDefaultTypeInternal _CodeGrant_default_instance_;
class CombinedLimit;
struct CombinedLimitDefaultTypeInternal;
extern CombinedLimitDefaultTypeInternal _CombinedLimit_default_instance_;
class ContractExecutionAuthorization;
struct ContractExecutionAuthorizationDefaultTypeInternal;
extern ContractExecutionAuthorizationDefaultTypeInternal _ContractExecutionAuthorization_default_instance_;
class ContractGrant;
struct ContractGrantDefaultTypeInternal;
extern ContractGrantDefaultTypeInternal _ContractGrant_default_instance_;
class ContractMigrationAuthorization;
struct ContractMigrationAuthorizationDefaultTypeInternal;
extern ContractMigrationAuthorizationDefaultTypeInternal _ContractMigrationAuthorization_default_instance_;
class MaxCallsLimit;
struct MaxCallsLimitDefaultTypeInternal;
extern MaxCallsLimitDefaultTypeInternal _MaxCallsLimit_default_instance_;
class MaxFundsLimit;
struct MaxFundsLimitDefaultTypeInternal;
extern MaxFundsLimitDefaultTypeInternal _MaxFundsLimit_default_instance_;
class StoreCodeAuthorization;
struct StoreCodeAuthorizationDefaultTypeInternal;
extern StoreCodeAuthorizationDefaultTypeInternal _StoreCodeAuthorization_default_instance_;
}  // namespace v1
}  // namespace wasm
}  // namespace cosmwasm
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace cosmwasm {
namespace wasm {
namespace v1 {

// ===================================================================


// -------------------------------------------------------------------

class MaxCallsLimit final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.MaxCallsLimit) */ {
 public:
  inline MaxCallsLimit() : MaxCallsLimit(nullptr) {}
  ~MaxCallsLimit() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MaxCallsLimit* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MaxCallsLimit));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MaxCallsLimit(
      ::google::protobuf::internal::ConstantInitialized);

  inline MaxCallsLimit(const MaxCallsLimit& from) : MaxCallsLimit(nullptr, from) {}
  inline MaxCallsLimit(MaxCallsLimit&& from) noexcept
      : MaxCallsLimit(nullptr, std::move(from)) {}
  inline MaxCallsLimit& operator=(const MaxCallsLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaxCallsLimit& operator=(MaxCallsLimit&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaxCallsLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const MaxCallsLimit* internal_default_instance() {
    return reinterpret_cast<const MaxCallsLimit*>(
        &_MaxCallsLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(MaxCallsLimit& a, MaxCallsLimit& b) { a.Swap(&b); }
  inline void Swap(MaxCallsLimit* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaxCallsLimit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MaxCallsLimit* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MaxCallsLimit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MaxCallsLimit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MaxCallsLimit& from) { MaxCallsLimit::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MaxCallsLimit* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmwasm.wasm.v1.MaxCallsLimit"; }

 protected:
  explicit MaxCallsLimit(::google::protobuf::Arena* arena);
  MaxCallsLimit(::google::protobuf::Arena* arena, const MaxCallsLimit& from);
  MaxCallsLimit(::google::protobuf::Arena* arena, MaxCallsLimit&& from) noexcept
      : MaxCallsLimit(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRemainingFieldNumber = 1,
  };
  // uint64 remaining = 1 [json_name = "remaining"];
  void clear_remaining() ;
  ::uint64_t remaining() const;
  void set_remaining(::uint64_t value);

  private:
  ::uint64_t _internal_remaining() const;
  void _internal_set_remaining(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.MaxCallsLimit)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MaxCallsLimit& from_msg);
    ::uint64_t remaining_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fauthz_2eproto;
};
// -------------------------------------------------------------------

class AllowAllMessagesFilter final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.AllowAllMessagesFilter) */ {
 public:
  inline AllowAllMessagesFilter() : AllowAllMessagesFilter(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AllowAllMessagesFilter* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AllowAllMessagesFilter));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AllowAllMessagesFilter(
      ::google::protobuf::internal::ConstantInitialized);

  inline AllowAllMessagesFilter(const AllowAllMessagesFilter& from) : AllowAllMessagesFilter(nullptr, from) {}
  inline AllowAllMessagesFilter(AllowAllMessagesFilter&& from) noexcept
      : AllowAllMessagesFilter(nullptr, std::move(from)) {}
  inline AllowAllMessagesFilter& operator=(const AllowAllMessagesFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllowAllMessagesFilter& operator=(AllowAllMessagesFilter&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllowAllMessagesFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllowAllMessagesFilter* internal_default_instance() {
    return reinterpret_cast<const AllowAllMessagesFilter*>(
        &_AllowAllMessagesFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(AllowAllMessagesFilter& a, AllowAllMessagesFilter& b) { a.Swap(&b); }
  inline void Swap(AllowAllMessagesFilter* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllowAllMessagesFilter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllowAllMessagesFilter* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<AllowAllMessagesFilter>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AllowAllMessagesFilter& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AllowAllMessagesFilter& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmwasm.wasm.v1.AllowAllMessagesFilter"; }

 protected:
  explicit AllowAllMessagesFilter(::google::protobuf::Arena* arena);
  AllowAllMessagesFilter(::google::protobuf::Arena* arena, const AllowAllMessagesFilter& from);
  AllowAllMessagesFilter(::google::protobuf::Arena* arena, AllowAllMessagesFilter&& from) noexcept
      : AllowAllMessagesFilter(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.AllowAllMessagesFilter)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AllowAllMessagesFilter& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fauthz_2eproto;
};
// -------------------------------------------------------------------

class AcceptedMessagesFilter final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.AcceptedMessagesFilter) */ {
 public:
  inline AcceptedMessagesFilter() : AcceptedMessagesFilter(nullptr) {}
  ~AcceptedMessagesFilter() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AcceptedMessagesFilter* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AcceptedMessagesFilter));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AcceptedMessagesFilter(
      ::google::protobuf::internal::ConstantInitialized);

  inline AcceptedMessagesFilter(const AcceptedMessagesFilter& from) : AcceptedMessagesFilter(nullptr, from) {}
  inline AcceptedMessagesFilter(AcceptedMessagesFilter&& from) noexcept
      : AcceptedMessagesFilter(nullptr, std::move(from)) {}
  inline AcceptedMessagesFilter& operator=(const AcceptedMessagesFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcceptedMessagesFilter& operator=(AcceptedMessagesFilter&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AcceptedMessagesFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const AcceptedMessagesFilter* internal_default_instance() {
    return reinterpret_cast<const AcceptedMessagesFilter*>(
        &_AcceptedMessagesFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(AcceptedMessagesFilter& a, AcceptedMessagesFilter& b) { a.Swap(&b); }
  inline void Swap(AcceptedMessagesFilter* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcceptedMessagesFilter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AcceptedMessagesFilter* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AcceptedMessagesFilter>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AcceptedMessagesFilter& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AcceptedMessagesFilter& from) { AcceptedMessagesFilter::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AcceptedMessagesFilter* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmwasm.wasm.v1.AcceptedMessagesFilter"; }

 protected:
  explicit AcceptedMessagesFilter(::google::protobuf::Arena* arena);
  AcceptedMessagesFilter(::google::protobuf::Arena* arena, const AcceptedMessagesFilter& from);
  AcceptedMessagesFilter(::google::protobuf::Arena* arena, AcceptedMessagesFilter&& from) noexcept
      : AcceptedMessagesFilter(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessagesFieldNumber = 1,
  };
  // repeated bytes messages = 1 [json_name = "messages", (.gogoproto.casttype) = "RawContractMessage", (.amino.encoding) = "inline_json"];
  int messages_size() const;
  private:
  int _internal_messages_size() const;

  public:
  void clear_messages() ;
  const std::string& messages(int index) const;
  std::string* mutable_messages(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_messages(int index, Arg_&& value, Args_... args);
  std::string* add_messages();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_messages(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& messages() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_messages();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_messages() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_messages();

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.AcceptedMessagesFilter)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AcceptedMessagesFilter& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> messages_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fauthz_2eproto;
};
// -------------------------------------------------------------------

class AcceptedMessageKeysFilter final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.AcceptedMessageKeysFilter) */ {
 public:
  inline AcceptedMessageKeysFilter() : AcceptedMessageKeysFilter(nullptr) {}
  ~AcceptedMessageKeysFilter() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AcceptedMessageKeysFilter* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AcceptedMessageKeysFilter));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AcceptedMessageKeysFilter(
      ::google::protobuf::internal::ConstantInitialized);

  inline AcceptedMessageKeysFilter(const AcceptedMessageKeysFilter& from) : AcceptedMessageKeysFilter(nullptr, from) {}
  inline AcceptedMessageKeysFilter(AcceptedMessageKeysFilter&& from) noexcept
      : AcceptedMessageKeysFilter(nullptr, std::move(from)) {}
  inline AcceptedMessageKeysFilter& operator=(const AcceptedMessageKeysFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcceptedMessageKeysFilter& operator=(AcceptedMessageKeysFilter&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AcceptedMessageKeysFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const AcceptedMessageKeysFilter* internal_default_instance() {
    return reinterpret_cast<const AcceptedMessageKeysFilter*>(
        &_AcceptedMessageKeysFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(AcceptedMessageKeysFilter& a, AcceptedMessageKeysFilter& b) { a.Swap(&b); }
  inline void Swap(AcceptedMessageKeysFilter* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcceptedMessageKeysFilter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AcceptedMessageKeysFilter* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AcceptedMessageKeysFilter>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AcceptedMessageKeysFilter& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AcceptedMessageKeysFilter& from) { AcceptedMessageKeysFilter::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AcceptedMessageKeysFilter* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmwasm.wasm.v1.AcceptedMessageKeysFilter"; }

 protected:
  explicit AcceptedMessageKeysFilter(::google::protobuf::Arena* arena);
  AcceptedMessageKeysFilter(::google::protobuf::Arena* arena, const AcceptedMessageKeysFilter& from);
  AcceptedMessageKeysFilter(::google::protobuf::Arena* arena, AcceptedMessageKeysFilter&& from) noexcept
      : AcceptedMessageKeysFilter(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeysFieldNumber = 1,
  };
  // repeated string keys = 1 [json_name = "keys"];
  int keys_size() const;
  private:
  int _internal_keys_size() const;

  public:
  void clear_keys() ;
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_keys(int index, Arg_&& value, Args_... args);
  std::string* add_keys();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_keys(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_keys();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_keys() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_keys();

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.AcceptedMessageKeysFilter)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      55, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AcceptedMessageKeysFilter& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> keys_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fauthz_2eproto;
};
// -------------------------------------------------------------------

class MaxFundsLimit final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.MaxFundsLimit) */ {
 public:
  inline MaxFundsLimit() : MaxFundsLimit(nullptr) {}
  ~MaxFundsLimit() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MaxFundsLimit* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MaxFundsLimit));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MaxFundsLimit(
      ::google::protobuf::internal::ConstantInitialized);

  inline MaxFundsLimit(const MaxFundsLimit& from) : MaxFundsLimit(nullptr, from) {}
  inline MaxFundsLimit(MaxFundsLimit&& from) noexcept
      : MaxFundsLimit(nullptr, std::move(from)) {}
  inline MaxFundsLimit& operator=(const MaxFundsLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaxFundsLimit& operator=(MaxFundsLimit&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaxFundsLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const MaxFundsLimit* internal_default_instance() {
    return reinterpret_cast<const MaxFundsLimit*>(
        &_MaxFundsLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(MaxFundsLimit& a, MaxFundsLimit& b) { a.Swap(&b); }
  inline void Swap(MaxFundsLimit* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaxFundsLimit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MaxFundsLimit* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MaxFundsLimit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MaxFundsLimit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MaxFundsLimit& from) { MaxFundsLimit::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MaxFundsLimit* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmwasm.wasm.v1.MaxFundsLimit"; }

 protected:
  explicit MaxFundsLimit(::google::protobuf::Arena* arena);
  MaxFundsLimit(::google::protobuf::Arena* arena, const MaxFundsLimit& from);
  MaxFundsLimit(::google::protobuf::Arena* arena, MaxFundsLimit&& from) noexcept
      : MaxFundsLimit(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAmountsFieldNumber = 1,
  };
  // repeated .cosmos.base.v1beta1.Coin amounts = 1 [json_name = "amounts", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins", (.amino.encoding) = "legacy_coins", (.amino.dont_omitempty) = true];
  int amounts_size() const;
  private:
  int _internal_amounts_size() const;

  public:
  void clear_amounts() ;
  ::cosmos::base::v1beta1::Coin* mutable_amounts(int index);
  ::google::protobuf::RepeatedPtrField<::cosmos::base::v1beta1::Coin>* mutable_amounts();

  private:
  const ::google::protobuf::RepeatedPtrField<::cosmos::base::v1beta1::Coin>& _internal_amounts() const;
  ::google::protobuf::RepeatedPtrField<::cosmos::base::v1beta1::Coin>* _internal_mutable_amounts();
  public:
  const ::cosmos::base::v1beta1::Coin& amounts(int index) const;
  ::cosmos::base::v1beta1::Coin* add_amounts();
  const ::google::protobuf::RepeatedPtrField<::cosmos::base::v1beta1::Coin>& amounts() const;
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.MaxFundsLimit)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MaxFundsLimit& from_msg);
    ::google::protobuf::RepeatedPtrField< ::cosmos::base::v1beta1::Coin > amounts_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fauthz_2eproto;
};
// -------------------------------------------------------------------

class ContractGrant final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.ContractGrant) */ {
 public:
  inline ContractGrant() : ContractGrant(nullptr) {}
  ~ContractGrant() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ContractGrant* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ContractGrant));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContractGrant(
      ::google::protobuf::internal::ConstantInitialized);

  inline ContractGrant(const ContractGrant& from) : ContractGrant(nullptr, from) {}
  inline ContractGrant(ContractGrant&& from) noexcept
      : ContractGrant(nullptr, std::move(from)) {}
  inline ContractGrant& operator=(const ContractGrant& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractGrant& operator=(ContractGrant&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractGrant& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractGrant* internal_default_instance() {
    return reinterpret_cast<const ContractGrant*>(
        &_ContractGrant_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ContractGrant& a, ContractGrant& b) { a.Swap(&b); }
  inline void Swap(ContractGrant* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractGrant* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractGrant* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ContractGrant>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ContractGrant& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ContractGrant& from) { ContractGrant::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ContractGrant* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmwasm.wasm.v1.ContractGrant"; }

 protected:
  explicit ContractGrant(::google::protobuf::Arena* arena);
  ContractGrant(::google::protobuf::Arena* arena, const ContractGrant& from);
  ContractGrant(::google::protobuf::Arena* arena, ContractGrant&& from) noexcept
      : ContractGrant(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kContractFieldNumber = 1,
    kLimitFieldNumber = 2,
    kFilterFieldNumber = 3,
  };
  // string contract = 1 [json_name = "contract", (.cosmos_proto.scalar) = "cosmos.AddressString"];
  void clear_contract() ;
  const std::string& contract() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract(Arg_&& arg, Args_... args);
  std::string* mutable_contract();
  PROTOBUF_NODISCARD std::string* release_contract();
  void set_allocated_contract(std::string* value);

  private:
  const std::string& _internal_contract() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract(
      const std::string& value);
  std::string* _internal_mutable_contract();

  public:
  // .google.protobuf.Any limit = 2 [json_name = "limit", (.cosmos_proto.accepts_interface) = "cosmwasm.wasm.v1.ContractAuthzLimitX"];
  bool has_limit() const;
  void clear_limit() ;
  const ::google::protobuf::Any& limit() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_limit();
  ::google::protobuf::Any* mutable_limit();
  void set_allocated_limit(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_limit(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_limit();

  private:
  const ::google::protobuf::Any& _internal_limit() const;
  ::google::protobuf::Any* _internal_mutable_limit();

  public:
  // .google.protobuf.Any filter = 3 [json_name = "filter", (.cosmos_proto.accepts_interface) = "cosmwasm.wasm.v1.ContractAuthzFilterX"];
  bool has_filter() const;
  void clear_filter() ;
  const ::google::protobuf::Any& filter() const;
  PROTOBUF_NODISCARD ::google::protobuf::Any* release_filter();
  ::google::protobuf::Any* mutable_filter();
  void set_allocated_filter(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_filter(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_filter();

  private:
  const ::google::protobuf::Any& _internal_filter() const;
  ::google::protobuf::Any* _internal_mutable_filter();

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.ContractGrant)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      47, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ContractGrant& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr contract_;
    ::google::protobuf::Any* limit_;
    ::google::protobuf::Any* filter_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fauthz_2eproto;
};
// -------------------------------------------------------------------

class CombinedLimit final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.CombinedLimit) */ {
 public:
  inline CombinedLimit() : CombinedLimit(nullptr) {}
  ~CombinedLimit() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CombinedLimit* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CombinedLimit));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CombinedLimit(
      ::google::protobuf::internal::ConstantInitialized);

  inline CombinedLimit(const CombinedLimit& from) : CombinedLimit(nullptr, from) {}
  inline CombinedLimit(CombinedLimit&& from) noexcept
      : CombinedLimit(nullptr, std::move(from)) {}
  inline CombinedLimit& operator=(const CombinedLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline CombinedLimit& operator=(CombinedLimit&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CombinedLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const CombinedLimit* internal_default_instance() {
    return reinterpret_cast<const CombinedLimit*>(
        &_CombinedLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(CombinedLimit& a, CombinedLimit& b) { a.Swap(&b); }
  inline void Swap(CombinedLimit* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CombinedLimit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CombinedLimit* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CombinedLimit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CombinedLimit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CombinedLimit& from) { CombinedLimit::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CombinedLimit* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmwasm.wasm.v1.CombinedLimit"; }

 protected:
  explicit CombinedLimit(::google::protobuf::Arena* arena);
  CombinedLimit(::google::protobuf::Arena* arena, const CombinedLimit& from);
  CombinedLimit(::google::protobuf::Arena* arena, CombinedLimit&& from) noexcept
      : CombinedLimit(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAmountsFieldNumber = 2,
    kCallsRemainingFieldNumber = 1,
  };
  // repeated .cosmos.base.v1beta1.Coin amounts = 2 [json_name = "amounts", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins", (.amino.encoding) = "legacy_coins", (.amino.dont_omitempty) = true];
  int amounts_size() const;
  private:
  int _internal_amounts_size() const;

  public:
  void clear_amounts() ;
  ::cosmos::base::v1beta1::Coin* mutable_amounts(int index);
  ::google::protobuf::RepeatedPtrField<::cosmos::base::v1beta1::Coin>* mutable_amounts();

  private:
  const ::google::protobuf::RepeatedPtrField<::cosmos::base::v1beta1::Coin>& _internal_amounts() const;
  ::google::protobuf::RepeatedPtrField<::cosmos::base::v1beta1::Coin>* _internal_mutable_amounts();
  public:
  const ::cosmos::base::v1beta1::Coin& amounts(int index) const;
  ::cosmos::base::v1beta1::Coin* add_amounts();
  const ::google::protobuf::RepeatedPtrField<::cosmos::base::v1beta1::Coin>& amounts() const;
  // uint64 calls_remaining = 1 [json_name = "callsRemaining"];
  void clear_calls_remaining() ;
  ::uint64_t calls_remaining() const;
  void set_calls_remaining(::uint64_t value);

  private:
  ::uint64_t _internal_calls_remaining() const;
  void _internal_set_calls_remaining(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.CombinedLimit)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CombinedLimit& from_msg);
    ::google::protobuf::RepeatedPtrField< ::cosmos::base::v1beta1::Coin > amounts_;
    ::uint64_t calls_remaining_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fauthz_2eproto;
};
// -------------------------------------------------------------------

class CodeGrant final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.CodeGrant) */ {
 public:
  inline CodeGrant() : CodeGrant(nullptr) {}
  ~CodeGrant() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CodeGrant* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CodeGrant));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CodeGrant(
      ::google::protobuf::internal::ConstantInitialized);

  inline CodeGrant(const CodeGrant& from) : CodeGrant(nullptr, from) {}
  inline CodeGrant(CodeGrant&& from) noexcept
      : CodeGrant(nullptr, std::move(from)) {}
  inline CodeGrant& operator=(const CodeGrant& from) {
    CopyFrom(from);
    return *this;
  }
  inline CodeGrant& operator=(CodeGrant&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CodeGrant& default_instance() {
    return *internal_default_instance();
  }
  static inline const CodeGrant* internal_default_instance() {
    return reinterpret_cast<const CodeGrant*>(
        &_CodeGrant_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(CodeGrant& a, CodeGrant& b) { a.Swap(&b); }
  inline void Swap(CodeGrant* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CodeGrant* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CodeGrant* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CodeGrant>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CodeGrant& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CodeGrant& from) { CodeGrant::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CodeGrant* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmwasm.wasm.v1.CodeGrant"; }

 protected:
  explicit CodeGrant(::google::protobuf::Arena* arena);
  CodeGrant(::google::protobuf::Arena* arena, const CodeGrant& from);
  CodeGrant(::google::protobuf::Arena* arena, CodeGrant&& from) noexcept
      : CodeGrant(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCodeHashFieldNumber = 1,
    kInstantiatePermissionFieldNumber = 2,
  };
  // bytes code_hash = 1 [json_name = "codeHash"];
  void clear_code_hash() ;
  const std::string& code_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_code_hash(Arg_&& arg, Args_... args);
  std::string* mutable_code_hash();
  PROTOBUF_NODISCARD std::string* release_code_hash();
  void set_allocated_code_hash(std::string* value);

  private:
  const std::string& _internal_code_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code_hash(
      const std::string& value);
  std::string* _internal_mutable_code_hash();

  public:
  // .cosmwasm.wasm.v1.AccessConfig instantiate_permission = 2 [json_name = "instantiatePermission"];
  bool has_instantiate_permission() const;
  void clear_instantiate_permission() ;
  const ::cosmwasm::wasm::v1::AccessConfig& instantiate_permission() const;
  PROTOBUF_NODISCARD ::cosmwasm::wasm::v1::AccessConfig* release_instantiate_permission();
  ::cosmwasm::wasm::v1::AccessConfig* mutable_instantiate_permission();
  void set_allocated_instantiate_permission(::cosmwasm::wasm::v1::AccessConfig* value);
  void unsafe_arena_set_allocated_instantiate_permission(::cosmwasm::wasm::v1::AccessConfig* value);
  ::cosmwasm::wasm::v1::AccessConfig* unsafe_arena_release_instantiate_permission();

  private:
  const ::cosmwasm::wasm::v1::AccessConfig& _internal_instantiate_permission() const;
  ::cosmwasm::wasm::v1::AccessConfig* _internal_mutable_instantiate_permission();

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.CodeGrant)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CodeGrant& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr code_hash_;
    ::cosmwasm::wasm::v1::AccessConfig* instantiate_permission_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fauthz_2eproto;
};
// -------------------------------------------------------------------

class StoreCodeAuthorization final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.StoreCodeAuthorization) */ {
 public:
  inline StoreCodeAuthorization() : StoreCodeAuthorization(nullptr) {}
  ~StoreCodeAuthorization() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StoreCodeAuthorization* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StoreCodeAuthorization));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StoreCodeAuthorization(
      ::google::protobuf::internal::ConstantInitialized);

  inline StoreCodeAuthorization(const StoreCodeAuthorization& from) : StoreCodeAuthorization(nullptr, from) {}
  inline StoreCodeAuthorization(StoreCodeAuthorization&& from) noexcept
      : StoreCodeAuthorization(nullptr, std::move(from)) {}
  inline StoreCodeAuthorization& operator=(const StoreCodeAuthorization& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreCodeAuthorization& operator=(StoreCodeAuthorization&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreCodeAuthorization& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreCodeAuthorization* internal_default_instance() {
    return reinterpret_cast<const StoreCodeAuthorization*>(
        &_StoreCodeAuthorization_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(StoreCodeAuthorization& a, StoreCodeAuthorization& b) { a.Swap(&b); }
  inline void Swap(StoreCodeAuthorization* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreCodeAuthorization* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreCodeAuthorization* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StoreCodeAuthorization>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StoreCodeAuthorization& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StoreCodeAuthorization& from) { StoreCodeAuthorization::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StoreCodeAuthorization* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmwasm.wasm.v1.StoreCodeAuthorization"; }

 protected:
  explicit StoreCodeAuthorization(::google::protobuf::Arena* arena);
  StoreCodeAuthorization(::google::protobuf::Arena* arena, const StoreCodeAuthorization& from);
  StoreCodeAuthorization(::google::protobuf::Arena* arena, StoreCodeAuthorization&& from) noexcept
      : StoreCodeAuthorization(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGrantsFieldNumber = 1,
  };
  // repeated .cosmwasm.wasm.v1.CodeGrant grants = 1 [json_name = "grants", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  int grants_size() const;
  private:
  int _internal_grants_size() const;

  public:
  void clear_grants() ;
  ::cosmwasm::wasm::v1::CodeGrant* mutable_grants(int index);
  ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::CodeGrant>* mutable_grants();

  private:
  const ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::CodeGrant>& _internal_grants() const;
  ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::CodeGrant>* _internal_mutable_grants();
  public:
  const ::cosmwasm::wasm::v1::CodeGrant& grants(int index) const;
  ::cosmwasm::wasm::v1::CodeGrant* add_grants();
  const ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::CodeGrant>& grants() const;
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.StoreCodeAuthorization)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StoreCodeAuthorization& from_msg);
    ::google::protobuf::RepeatedPtrField< ::cosmwasm::wasm::v1::CodeGrant > grants_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fauthz_2eproto;
};
// -------------------------------------------------------------------

class ContractMigrationAuthorization final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.ContractMigrationAuthorization) */ {
 public:
  inline ContractMigrationAuthorization() : ContractMigrationAuthorization(nullptr) {}
  ~ContractMigrationAuthorization() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ContractMigrationAuthorization* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ContractMigrationAuthorization));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContractMigrationAuthorization(
      ::google::protobuf::internal::ConstantInitialized);

  inline ContractMigrationAuthorization(const ContractMigrationAuthorization& from) : ContractMigrationAuthorization(nullptr, from) {}
  inline ContractMigrationAuthorization(ContractMigrationAuthorization&& from) noexcept
      : ContractMigrationAuthorization(nullptr, std::move(from)) {}
  inline ContractMigrationAuthorization& operator=(const ContractMigrationAuthorization& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractMigrationAuthorization& operator=(ContractMigrationAuthorization&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractMigrationAuthorization& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractMigrationAuthorization* internal_default_instance() {
    return reinterpret_cast<const ContractMigrationAuthorization*>(
        &_ContractMigrationAuthorization_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(ContractMigrationAuthorization& a, ContractMigrationAuthorization& b) { a.Swap(&b); }
  inline void Swap(ContractMigrationAuthorization* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractMigrationAuthorization* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractMigrationAuthorization* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ContractMigrationAuthorization>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ContractMigrationAuthorization& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ContractMigrationAuthorization& from) { ContractMigrationAuthorization::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ContractMigrationAuthorization* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmwasm.wasm.v1.ContractMigrationAuthorization"; }

 protected:
  explicit ContractMigrationAuthorization(::google::protobuf::Arena* arena);
  ContractMigrationAuthorization(::google::protobuf::Arena* arena, const ContractMigrationAuthorization& from);
  ContractMigrationAuthorization(::google::protobuf::Arena* arena, ContractMigrationAuthorization&& from) noexcept
      : ContractMigrationAuthorization(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGrantsFieldNumber = 1,
  };
  // repeated .cosmwasm.wasm.v1.ContractGrant grants = 1 [json_name = "grants", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  int grants_size() const;
  private:
  int _internal_grants_size() const;

  public:
  void clear_grants() ;
  ::cosmwasm::wasm::v1::ContractGrant* mutable_grants(int index);
  ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>* mutable_grants();

  private:
  const ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>& _internal_grants() const;
  ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>* _internal_mutable_grants();
  public:
  const ::cosmwasm::wasm::v1::ContractGrant& grants(int index) const;
  ::cosmwasm::wasm::v1::ContractGrant* add_grants();
  const ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>& grants() const;
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.ContractMigrationAuthorization)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ContractMigrationAuthorization& from_msg);
    ::google::protobuf::RepeatedPtrField< ::cosmwasm::wasm::v1::ContractGrant > grants_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fauthz_2eproto;
};
// -------------------------------------------------------------------

class ContractExecutionAuthorization final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.ContractExecutionAuthorization) */ {
 public:
  inline ContractExecutionAuthorization() : ContractExecutionAuthorization(nullptr) {}
  ~ContractExecutionAuthorization() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ContractExecutionAuthorization* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ContractExecutionAuthorization));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ContractExecutionAuthorization(
      ::google::protobuf::internal::ConstantInitialized);

  inline ContractExecutionAuthorization(const ContractExecutionAuthorization& from) : ContractExecutionAuthorization(nullptr, from) {}
  inline ContractExecutionAuthorization(ContractExecutionAuthorization&& from) noexcept
      : ContractExecutionAuthorization(nullptr, std::move(from)) {}
  inline ContractExecutionAuthorization& operator=(const ContractExecutionAuthorization& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractExecutionAuthorization& operator=(ContractExecutionAuthorization&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractExecutionAuthorization& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractExecutionAuthorization* internal_default_instance() {
    return reinterpret_cast<const ContractExecutionAuthorization*>(
        &_ContractExecutionAuthorization_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(ContractExecutionAuthorization& a, ContractExecutionAuthorization& b) { a.Swap(&b); }
  inline void Swap(ContractExecutionAuthorization* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractExecutionAuthorization* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractExecutionAuthorization* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ContractExecutionAuthorization>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ContractExecutionAuthorization& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ContractExecutionAuthorization& from) { ContractExecutionAuthorization::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ContractExecutionAuthorization* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cosmwasm.wasm.v1.ContractExecutionAuthorization"; }

 protected:
  explicit ContractExecutionAuthorization(::google::protobuf::Arena* arena);
  ContractExecutionAuthorization(::google::protobuf::Arena* arena, const ContractExecutionAuthorization& from);
  ContractExecutionAuthorization(::google::protobuf::Arena* arena, ContractExecutionAuthorization&& from) noexcept
      : ContractExecutionAuthorization(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGrantsFieldNumber = 1,
  };
  // repeated .cosmwasm.wasm.v1.ContractGrant grants = 1 [json_name = "grants", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  int grants_size() const;
  private:
  int _internal_grants_size() const;

  public:
  void clear_grants() ;
  ::cosmwasm::wasm::v1::ContractGrant* mutable_grants(int index);
  ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>* mutable_grants();

  private:
  const ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>& _internal_grants() const;
  ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>* _internal_mutable_grants();
  public:
  const ::cosmwasm::wasm::v1::ContractGrant& grants(int index) const;
  ::cosmwasm::wasm::v1::ContractGrant* add_grants();
  const ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>& grants() const;
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.ContractExecutionAuthorization)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ContractExecutionAuthorization& from_msg);
    ::google::protobuf::RepeatedPtrField< ::cosmwasm::wasm::v1::ContractGrant > grants_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fauthz_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// StoreCodeAuthorization

// repeated .cosmwasm.wasm.v1.CodeGrant grants = 1 [json_name = "grants", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline int StoreCodeAuthorization::_internal_grants_size() const {
  return _internal_grants().size();
}
inline int StoreCodeAuthorization::grants_size() const {
  return _internal_grants_size();
}
inline void StoreCodeAuthorization::clear_grants() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grants_.Clear();
}
inline ::cosmwasm::wasm::v1::CodeGrant* StoreCodeAuthorization::mutable_grants(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.StoreCodeAuthorization.grants)
  return _internal_mutable_grants()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::CodeGrant>* StoreCodeAuthorization::mutable_grants()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cosmwasm.wasm.v1.StoreCodeAuthorization.grants)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_grants();
}
inline const ::cosmwasm::wasm::v1::CodeGrant& StoreCodeAuthorization::grants(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.StoreCodeAuthorization.grants)
  return _internal_grants().Get(index);
}
inline ::cosmwasm::wasm::v1::CodeGrant* StoreCodeAuthorization::add_grants() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::cosmwasm::wasm::v1::CodeGrant* _add = _internal_mutable_grants()->Add();
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.StoreCodeAuthorization.grants)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::CodeGrant>& StoreCodeAuthorization::grants() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cosmwasm.wasm.v1.StoreCodeAuthorization.grants)
  return _internal_grants();
}
inline const ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::CodeGrant>&
StoreCodeAuthorization::_internal_grants() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.grants_;
}
inline ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::CodeGrant>*
StoreCodeAuthorization::_internal_mutable_grants() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.grants_;
}

// -------------------------------------------------------------------

// ContractExecutionAuthorization

// repeated .cosmwasm.wasm.v1.ContractGrant grants = 1 [json_name = "grants", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline int ContractExecutionAuthorization::_internal_grants_size() const {
  return _internal_grants().size();
}
inline int ContractExecutionAuthorization::grants_size() const {
  return _internal_grants_size();
}
inline void ContractExecutionAuthorization::clear_grants() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grants_.Clear();
}
inline ::cosmwasm::wasm::v1::ContractGrant* ContractExecutionAuthorization::mutable_grants(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ContractExecutionAuthorization.grants)
  return _internal_mutable_grants()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>* ContractExecutionAuthorization::mutable_grants()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cosmwasm.wasm.v1.ContractExecutionAuthorization.grants)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_grants();
}
inline const ::cosmwasm::wasm::v1::ContractGrant& ContractExecutionAuthorization::grants(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ContractExecutionAuthorization.grants)
  return _internal_grants().Get(index);
}
inline ::cosmwasm::wasm::v1::ContractGrant* ContractExecutionAuthorization::add_grants() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::cosmwasm::wasm::v1::ContractGrant* _add = _internal_mutable_grants()->Add();
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.ContractExecutionAuthorization.grants)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>& ContractExecutionAuthorization::grants() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cosmwasm.wasm.v1.ContractExecutionAuthorization.grants)
  return _internal_grants();
}
inline const ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>&
ContractExecutionAuthorization::_internal_grants() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.grants_;
}
inline ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>*
ContractExecutionAuthorization::_internal_mutable_grants() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.grants_;
}

// -------------------------------------------------------------------

// ContractMigrationAuthorization

// repeated .cosmwasm.wasm.v1.ContractGrant grants = 1 [json_name = "grants", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline int ContractMigrationAuthorization::_internal_grants_size() const {
  return _internal_grants().size();
}
inline int ContractMigrationAuthorization::grants_size() const {
  return _internal_grants_size();
}
inline void ContractMigrationAuthorization::clear_grants() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grants_.Clear();
}
inline ::cosmwasm::wasm::v1::ContractGrant* ContractMigrationAuthorization::mutable_grants(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ContractMigrationAuthorization.grants)
  return _internal_mutable_grants()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>* ContractMigrationAuthorization::mutable_grants()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cosmwasm.wasm.v1.ContractMigrationAuthorization.grants)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_grants();
}
inline const ::cosmwasm::wasm::v1::ContractGrant& ContractMigrationAuthorization::grants(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ContractMigrationAuthorization.grants)
  return _internal_grants().Get(index);
}
inline ::cosmwasm::wasm::v1::ContractGrant* ContractMigrationAuthorization::add_grants() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::cosmwasm::wasm::v1::ContractGrant* _add = _internal_mutable_grants()->Add();
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.ContractMigrationAuthorization.grants)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>& ContractMigrationAuthorization::grants() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cosmwasm.wasm.v1.ContractMigrationAuthorization.grants)
  return _internal_grants();
}
inline const ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>&
ContractMigrationAuthorization::_internal_grants() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.grants_;
}
inline ::google::protobuf::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>*
ContractMigrationAuthorization::_internal_mutable_grants() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.grants_;
}

// -------------------------------------------------------------------

// CodeGrant

// bytes code_hash = 1 [json_name = "codeHash"];
inline void CodeGrant::clear_code_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_hash_.ClearToEmpty();
}
inline const std::string& CodeGrant::code_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.CodeGrant.code_hash)
  return _internal_code_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CodeGrant::set_code_hash(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.CodeGrant.code_hash)
}
inline std::string* CodeGrant::mutable_code_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_code_hash();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.CodeGrant.code_hash)
  return _s;
}
inline const std::string& CodeGrant::_internal_code_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.code_hash_.Get();
}
inline void CodeGrant::_internal_set_code_hash(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_hash_.Set(value, GetArena());
}
inline std::string* CodeGrant::_internal_mutable_code_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.code_hash_.Mutable( GetArena());
}
inline std::string* CodeGrant::release_code_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.CodeGrant.code_hash)
  return _impl_.code_hash_.Release();
}
inline void CodeGrant::set_allocated_code_hash(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_hash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.code_hash_.IsDefault()) {
    _impl_.code_hash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.CodeGrant.code_hash)
}

// .cosmwasm.wasm.v1.AccessConfig instantiate_permission = 2 [json_name = "instantiatePermission"];
inline bool CodeGrant::has_instantiate_permission() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.instantiate_permission_ != nullptr);
  return value;
}
inline const ::cosmwasm::wasm::v1::AccessConfig& CodeGrant::_internal_instantiate_permission() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::cosmwasm::wasm::v1::AccessConfig* p = _impl_.instantiate_permission_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmwasm::wasm::v1::AccessConfig&>(::cosmwasm::wasm::v1::_AccessConfig_default_instance_);
}
inline const ::cosmwasm::wasm::v1::AccessConfig& CodeGrant::instantiate_permission() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.CodeGrant.instantiate_permission)
  return _internal_instantiate_permission();
}
inline void CodeGrant::unsafe_arena_set_allocated_instantiate_permission(::cosmwasm::wasm::v1::AccessConfig* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.instantiate_permission_);
  }
  _impl_.instantiate_permission_ = reinterpret_cast<::cosmwasm::wasm::v1::AccessConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmwasm.wasm.v1.CodeGrant.instantiate_permission)
}
inline ::cosmwasm::wasm::v1::AccessConfig* CodeGrant::release_instantiate_permission() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmwasm::wasm::v1::AccessConfig* released = _impl_.instantiate_permission_;
  _impl_.instantiate_permission_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::cosmwasm::wasm::v1::AccessConfig* CodeGrant::unsafe_arena_release_instantiate_permission() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.CodeGrant.instantiate_permission)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmwasm::wasm::v1::AccessConfig* temp = _impl_.instantiate_permission_;
  _impl_.instantiate_permission_ = nullptr;
  return temp;
}
inline ::cosmwasm::wasm::v1::AccessConfig* CodeGrant::_internal_mutable_instantiate_permission() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.instantiate_permission_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::cosmwasm::wasm::v1::AccessConfig>(GetArena());
    _impl_.instantiate_permission_ = reinterpret_cast<::cosmwasm::wasm::v1::AccessConfig*>(p);
  }
  return _impl_.instantiate_permission_;
}
inline ::cosmwasm::wasm::v1::AccessConfig* CodeGrant::mutable_instantiate_permission() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::cosmwasm::wasm::v1::AccessConfig* _msg = _internal_mutable_instantiate_permission();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.CodeGrant.instantiate_permission)
  return _msg;
}
inline void CodeGrant::set_allocated_instantiate_permission(::cosmwasm::wasm::v1::AccessConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.instantiate_permission_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.instantiate_permission_ = reinterpret_cast<::cosmwasm::wasm::v1::AccessConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.CodeGrant.instantiate_permission)
}

// -------------------------------------------------------------------

// ContractGrant

// string contract = 1 [json_name = "contract", (.cosmos_proto.scalar) = "cosmos.AddressString"];
inline void ContractGrant::clear_contract() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_.ClearToEmpty();
}
inline const std::string& ContractGrant::contract() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ContractGrant.contract)
  return _internal_contract();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractGrant::set_contract(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.ContractGrant.contract)
}
inline std::string* ContractGrant::mutable_contract() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_contract();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ContractGrant.contract)
  return _s;
}
inline const std::string& ContractGrant::_internal_contract() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.contract_.Get();
}
inline void ContractGrant::_internal_set_contract(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_.Set(value, GetArena());
}
inline std::string* ContractGrant::_internal_mutable_contract() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.contract_.Mutable( GetArena());
}
inline std::string* ContractGrant::release_contract() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.ContractGrant.contract)
  return _impl_.contract_.Release();
}
inline void ContractGrant::set_allocated_contract(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contract_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.contract_.IsDefault()) {
    _impl_.contract_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.ContractGrant.contract)
}

// .google.protobuf.Any limit = 2 [json_name = "limit", (.cosmos_proto.accepts_interface) = "cosmwasm.wasm.v1.ContractAuthzLimitX"];
inline bool ContractGrant::has_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.limit_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& ContractGrant::_internal_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Any* p = _impl_.limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& ContractGrant::limit() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ContractGrant.limit)
  return _internal_limit();
}
inline void ContractGrant::unsafe_arena_set_allocated_limit(::google::protobuf::Any* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.limit_);
  }
  _impl_.limit_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmwasm.wasm.v1.ContractGrant.limit)
}
inline ::google::protobuf::Any* ContractGrant::release_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* released = _impl_.limit_;
  _impl_.limit_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Any* ContractGrant::unsafe_arena_release_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.ContractGrant.limit)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* temp = _impl_.limit_;
  _impl_.limit_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* ContractGrant::_internal_mutable_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.limit_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Any>(GetArena());
    _impl_.limit_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.limit_;
}
inline ::google::protobuf::Any* ContractGrant::mutable_limit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Any* _msg = _internal_mutable_limit();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ContractGrant.limit)
  return _msg;
}
inline void ContractGrant::set_allocated_limit(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.limit_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.limit_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.ContractGrant.limit)
}

// .google.protobuf.Any filter = 3 [json_name = "filter", (.cosmos_proto.accepts_interface) = "cosmwasm.wasm.v1.ContractAuthzFilterX"];
inline bool ContractGrant::has_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& ContractGrant::_internal_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Any* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& ContractGrant::filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ContractGrant.filter)
  return _internal_filter();
}
inline void ContractGrant::unsafe_arena_set_allocated_filter(::google::protobuf::Any* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmwasm.wasm.v1.ContractGrant.filter)
}
inline ::google::protobuf::Any* ContractGrant::release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Any* released = _impl_.filter_;
  _impl_.filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Any* ContractGrant::unsafe_arena_release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.ContractGrant.filter)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Any* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* ContractGrant::_internal_mutable_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Any>(GetArena());
    _impl_.filter_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.filter_;
}
inline ::google::protobuf::Any* ContractGrant::mutable_filter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Any* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ContractGrant.filter)
  return _msg;
}
inline void ContractGrant::set_allocated_filter(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.filter_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.ContractGrant.filter)
}

// -------------------------------------------------------------------

// MaxCallsLimit

// uint64 remaining = 1 [json_name = "remaining"];
inline void MaxCallsLimit::clear_remaining() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remaining_ = ::uint64_t{0u};
}
inline ::uint64_t MaxCallsLimit::remaining() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.MaxCallsLimit.remaining)
  return _internal_remaining();
}
inline void MaxCallsLimit::set_remaining(::uint64_t value) {
  _internal_set_remaining(value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.MaxCallsLimit.remaining)
}
inline ::uint64_t MaxCallsLimit::_internal_remaining() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.remaining_;
}
inline void MaxCallsLimit::_internal_set_remaining(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remaining_ = value;
}

// -------------------------------------------------------------------

// MaxFundsLimit

// repeated .cosmos.base.v1beta1.Coin amounts = 1 [json_name = "amounts", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins", (.amino.encoding) = "legacy_coins", (.amino.dont_omitempty) = true];
inline int MaxFundsLimit::_internal_amounts_size() const {
  return _internal_amounts().size();
}
inline int MaxFundsLimit::amounts_size() const {
  return _internal_amounts_size();
}
inline ::cosmos::base::v1beta1::Coin* MaxFundsLimit::mutable_amounts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.MaxFundsLimit.amounts)
  return _internal_mutable_amounts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::base::v1beta1::Coin>* MaxFundsLimit::mutable_amounts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cosmwasm.wasm.v1.MaxFundsLimit.amounts)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_amounts();
}
inline const ::cosmos::base::v1beta1::Coin& MaxFundsLimit::amounts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.MaxFundsLimit.amounts)
  return _internal_amounts().Get(index);
}
inline ::cosmos::base::v1beta1::Coin* MaxFundsLimit::add_amounts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::cosmos::base::v1beta1::Coin* _add = _internal_mutable_amounts()->Add();
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.MaxFundsLimit.amounts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::base::v1beta1::Coin>& MaxFundsLimit::amounts() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cosmwasm.wasm.v1.MaxFundsLimit.amounts)
  return _internal_amounts();
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::base::v1beta1::Coin>&
MaxFundsLimit::_internal_amounts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.amounts_;
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::base::v1beta1::Coin>*
MaxFundsLimit::_internal_mutable_amounts() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.amounts_;
}

// -------------------------------------------------------------------

// CombinedLimit

// uint64 calls_remaining = 1 [json_name = "callsRemaining"];
inline void CombinedLimit::clear_calls_remaining() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.calls_remaining_ = ::uint64_t{0u};
}
inline ::uint64_t CombinedLimit::calls_remaining() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.CombinedLimit.calls_remaining)
  return _internal_calls_remaining();
}
inline void CombinedLimit::set_calls_remaining(::uint64_t value) {
  _internal_set_calls_remaining(value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.CombinedLimit.calls_remaining)
}
inline ::uint64_t CombinedLimit::_internal_calls_remaining() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.calls_remaining_;
}
inline void CombinedLimit::_internal_set_calls_remaining(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.calls_remaining_ = value;
}

// repeated .cosmos.base.v1beta1.Coin amounts = 2 [json_name = "amounts", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins", (.amino.encoding) = "legacy_coins", (.amino.dont_omitempty) = true];
inline int CombinedLimit::_internal_amounts_size() const {
  return _internal_amounts().size();
}
inline int CombinedLimit::amounts_size() const {
  return _internal_amounts_size();
}
inline ::cosmos::base::v1beta1::Coin* CombinedLimit::mutable_amounts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.CombinedLimit.amounts)
  return _internal_mutable_amounts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::base::v1beta1::Coin>* CombinedLimit::mutable_amounts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cosmwasm.wasm.v1.CombinedLimit.amounts)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_amounts();
}
inline const ::cosmos::base::v1beta1::Coin& CombinedLimit::amounts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.CombinedLimit.amounts)
  return _internal_amounts().Get(index);
}
inline ::cosmos::base::v1beta1::Coin* CombinedLimit::add_amounts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::cosmos::base::v1beta1::Coin* _add = _internal_mutable_amounts()->Add();
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.CombinedLimit.amounts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::base::v1beta1::Coin>& CombinedLimit::amounts() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cosmwasm.wasm.v1.CombinedLimit.amounts)
  return _internal_amounts();
}
inline const ::google::protobuf::RepeatedPtrField<::cosmos::base::v1beta1::Coin>&
CombinedLimit::_internal_amounts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.amounts_;
}
inline ::google::protobuf::RepeatedPtrField<::cosmos::base::v1beta1::Coin>*
CombinedLimit::_internal_mutable_amounts() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.amounts_;
}

// -------------------------------------------------------------------

// AllowAllMessagesFilter

// -------------------------------------------------------------------

// AcceptedMessageKeysFilter

// repeated string keys = 1 [json_name = "keys"];
inline int AcceptedMessageKeysFilter::_internal_keys_size() const {
  return _internal_keys().size();
}
inline int AcceptedMessageKeysFilter::keys_size() const {
  return _internal_keys_size();
}
inline void AcceptedMessageKeysFilter::clear_keys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.keys_.Clear();
}
inline std::string* AcceptedMessageKeysFilter::add_keys() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_keys()->Add();
  // @@protoc_insertion_point(field_add_mutable:cosmwasm.wasm.v1.AcceptedMessageKeysFilter.keys)
  return _s;
}
inline const std::string& AcceptedMessageKeysFilter::keys(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.AcceptedMessageKeysFilter.keys)
  return _internal_keys().Get(index);
}
inline std::string* AcceptedMessageKeysFilter::mutable_keys(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.AcceptedMessageKeysFilter.keys)
  return _internal_mutable_keys()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void AcceptedMessageKeysFilter::set_keys(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_keys()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.AcceptedMessageKeysFilter.keys)
}
template <typename Arg_, typename... Args_>
inline void AcceptedMessageKeysFilter::add_keys(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_keys(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.AcceptedMessageKeysFilter.keys)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AcceptedMessageKeysFilter::keys() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cosmwasm.wasm.v1.AcceptedMessageKeysFilter.keys)
  return _internal_keys();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AcceptedMessageKeysFilter::mutable_keys() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cosmwasm.wasm.v1.AcceptedMessageKeysFilter.keys)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_keys();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AcceptedMessageKeysFilter::_internal_keys() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.keys_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AcceptedMessageKeysFilter::_internal_mutable_keys() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.keys_;
}

// -------------------------------------------------------------------

// AcceptedMessagesFilter

// repeated bytes messages = 1 [json_name = "messages", (.gogoproto.casttype) = "RawContractMessage", (.amino.encoding) = "inline_json"];
inline int AcceptedMessagesFilter::_internal_messages_size() const {
  return _internal_messages().size();
}
inline int AcceptedMessagesFilter::messages_size() const {
  return _internal_messages_size();
}
inline void AcceptedMessagesFilter::clear_messages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.messages_.Clear();
}
inline std::string* AcceptedMessagesFilter::add_messages() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_messages()->Add();
  // @@protoc_insertion_point(field_add_mutable:cosmwasm.wasm.v1.AcceptedMessagesFilter.messages)
  return _s;
}
inline const std::string& AcceptedMessagesFilter::messages(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.AcceptedMessagesFilter.messages)
  return _internal_messages().Get(index);
}
inline std::string* AcceptedMessagesFilter::mutable_messages(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.AcceptedMessagesFilter.messages)
  return _internal_mutable_messages()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void AcceptedMessagesFilter::set_messages(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_messages()->Mutable(index),
      std::forward<Arg_>(value), args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.AcceptedMessagesFilter.messages)
}
template <typename Arg_, typename... Args_>
inline void AcceptedMessagesFilter::add_messages(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_messages(),
                               std::forward<Arg_>(value),
                               args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.AcceptedMessagesFilter.messages)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AcceptedMessagesFilter::messages() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:cosmwasm.wasm.v1.AcceptedMessagesFilter.messages)
  return _internal_messages();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AcceptedMessagesFilter::mutable_messages() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:cosmwasm.wasm.v1.AcceptedMessagesFilter.messages)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_messages();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AcceptedMessagesFilter::_internal_messages() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.messages_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AcceptedMessagesFilter::_internal_mutable_messages() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.messages_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace wasm
}  // namespace cosmwasm


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // cosmwasm_2fwasm_2fv1_2fauthz_2eproto_2epb_2eh
