name: Rust Protobuf Gen & Publish

on:
  push:
    branches: 
    #   - main 
      -  feat/protobufs
            
  workflow_dispatch:
    inputs:
      next_version:
        description: 'Specific version to set (e.g., 1.2.3). Required for publishing.'
        required: true
        type: string

  repository_dispatch:
    types: [xion-types-release-trigger]
    
  schedule:
    - cron: '0 2 * * *' # Run nightly at 2 AM UTC

jobs:
  generate-protobuf:
    name: Generate Rust Types
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          submodules: false
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate Rust Definitions
        run: |
          make proto-gen-rust

      - name: Check if Types Were Generated
        run: |
          if [ -d "./rust/types" ] && [ "$(ls -A ./rust/types)" ]; then
            echo "✅ Rust definitions generated successfully"
          else
            echo "❌ Failed to generate Rust definitions"
            exit 1
          fi

      - name: Upload Generated Types
        uses: actions/upload-artifact@v4
        with:
          name: generated-types-rust
          path: rust/types
          retention-days: 30

  determine-version:
    name: Determine Version
    needs: [generate-protobuf]
    runs-on: ubuntu-latest
    if: |
        github.ref == 'refs/heads/feat/protobufs' ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.next_version != '') || 
        (github.event_name == 'repository_dispatch' && github.event.client_payload.release_type == 'published')
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine Version
        # Version scenarios:
        # 1. Manual trigger (workflow_dispatch) → Use input version (e.g., "1.2.3")
        # 2. Release event (repository_dispatch) → Use release tag (e.g., "v1.2.3" → "1.2.3")
        # 3. Push to branch → Generate dev version (e.g., "0.0.0-dev.abc1234")
        id: version
        run: |
          if [ "${{ github.event.inputs.next_version }}" != "" ]; then
            VERSION="${{ github.event.inputs.next_version }}"
            echo "Using manual version: $VERSION"
          elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            RELEASE_TAG="${{ github.event.client_payload.tag_name }}"
            VERSION=${RELEASE_TAG#v}
            echo "Using release version: $VERSION (from tag: $RELEASE_TAG)"
          elif [ "${{ github.event_name }}" == "push" ]; then
            GIT_SHA=$(git rev-parse --short HEAD)
            VERSION="0.0.0-dev.${GIT_SHA}"
            echo "Using dev version for testing: $VERSION"
          else
            echo "❌ No version specified"
            exit 1
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT

  # ============================================
  # Rust Crate Publishing
  # ============================================

  rust-build:
    name: Build Rust Crate
    needs: [determine-version, generate-protobuf]
    runs-on: ubuntu-latest
    outputs:
      version: ${{ needs.determine-version.outputs.version }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Generated Rust Types
        uses: actions/download-artifact@v4
        with:
          name: generated-types-rust
          path: rust/types

      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable
          cache: false  # Disable auto-cache, we'll handle it manually

      - name: Create Rust Package Structure
        run: |
          mkdir -p rust/src
          
          # Create Cargo.toml if it doesn't exist
          if [ ! -f "rust/Cargo.toml" ]; then
            cat > rust/Cargo.toml << 'CARGO'
          [package]
          name = "xion-types"
          version = "0.1.0"
          edition = "2021"
          description = "Generated Rust types for Xion blockchain protocol buffers"
          license = "Apache-2.0"
          repository = "https://github.com/burnt-labs/xion-types"
          
          [lib]
          name = "xion_types"
          path = "src/lib.rs"
          
          [dependencies]
          prost = "0.12"
          prost-types = "0.12"
          CARGO
          fi
          
          # Single Python script to handle all setup
          python3 << 'PYTHON'
          import re
          from pathlib import Path
          
          types_dir = Path("rust/types")
          if not types_dir.exists():
              print("❌ rust/types directory not found")
              exit(1)
          
          # 1. Generate mod.rs files recursively
          def create_mod_rs(dir_path):
              rs_files = [f for f in dir_path.glob("*.rs") if f.name != "mod.rs"]
              subdirs = [d for d in dir_path.iterdir() if d.is_dir() and create_mod_rs(d)]
              
              if not rs_files and not subdirs:
                  return False
              
              with (dir_path / "mod.rs").open("w") as f:
                  f.write("// Auto-generated module\n")
                  for rs_file in sorted(rs_files):
                      modname = rs_file.stem
                      if '.' in modname:
                          f.write(f'#[path = "{rs_file.name}"]\npub mod {modname.replace(".", "_")};\n')
                      else:
                          f.write(f"pub mod {modname};\n")
                  for subdir in subdirs:
                      f.write(f"pub mod {subdir.name};\n")
              return True
          
          # Process subdirectories first
          for item in sorted(types_dir.iterdir()):
              if item.is_dir() and any(item.rglob("*.rs")):
                  create_mod_rs(item)
          
          # Create root mod.rs
          with (types_dir / "mod.rs").open("w") as f:
              f.write("// Auto-generated module\n")
              for item in sorted(types_dir.iterdir()):
                  if item.is_dir() and (item / "mod.rs").exists():
                      f.write(f"pub mod {item.name};\n")
                  elif item.suffix == ".rs" and item.name != "mod.rs":
                      modname = item.stem
                      if '.' in modname:
                          f.write(f'#[path = "{item.name}"]\npub mod {modname.replace(".", "_")};\n')
                      else:
                          f.write(f"pub mod {modname};\n")
          
          # 2. Create lib.rs
          lib_rs = Path("rust/src/lib.rs")
          lib_rs.parent.mkdir(parents=True, exist_ok=True)
          lib_rs.write_text("""//! Generated Rust types for Xion blockchain protocol buffers
          
          pub mod types {
              include!(concat!(env!("CARGO_MANIFEST_DIR"), "/types/mod.rs"));
          }
          """)
          
          # 3. Build module name map from actual files
          module_map = {}
          for rs_file in types_dir.rglob("*.rs"):
              if rs_file.name == "mod.rs":
                  continue
              # File: cosmos.base.query.v1beta1.rs -> module: cosmos_base_query_v1beta1
              mod_name = rs_file.stem.replace('.', '_')
              module_map[mod_name] = rs_file
          
          # 4. Fix module paths in generated files
          # Order matters: most specific first
          path_mappings = [
              # IBC multi-level paths (most specific)
              (r'(super::)+ibc::applications::interchain_accounts::controller::v1::', 'crate::types::ibc_applications_interchain_accounts_controller_v1::'),
              (r'(super::)+ibc::applications::interchain_accounts::host::v1::', 'crate::types::ibc_applications_interchain_accounts_host_v1::'),
              (r'(super::)+ibc::applications::interchain_accounts::v1::', 'crate::types::ibc_applications_interchain_accounts_v1::'),
              (r'(super::)+ibc::core::channel::v1::', 'crate::types::ibc_core_channel_v1::'),
              (r'(super::)+ibc::core::channel::v2::', 'crate::types::ibc_core_channel_v2::'),
              (r'(super::)+ibc::core::connection::v1::', 'crate::types::ibc_core_connection_v1::'),
              (r'(super::)+ibc::core::types::v1::', 'crate::types::ibc_core_types_v1::'),
              (r'(super::)+ibc::core::client::v1::', 'crate::types::ibc_core_client_v1::'),
              (r'(super::)+ibc::core::client::v2::', 'crate::types::ibc_core_client_v2::'),
              (r'(super::)+ibc::core::commitment::v1::', 'crate::types::ibc_core_commitment_v1::'),
              (r'(super::)+ibc::core::commitment::v2::', 'crate::types::ibc_core_commitment_v2::'),
              # Cosmos multi-level paths
              (r'(super::)+tendermint::libs::bits::', 'crate::types::tendermint_libs_bits::'),
              (r'(super::)+cosmos::base::tendermint::v1beta1::', 'crate::types::cosmos_base_tendermint_v1beta1::'),
              (r'(super::)+cosmos::base::query::v1beta1::', 'crate::types::cosmos_base_query_v1beta1::'),
              (r'(super::)+cosmos::base::abci::v1beta1::', 'crate::types::cosmos_base_abci_v1beta1::'),
              (r'(super::)+cosmos::base::reflection::v1beta1::', 'crate::types::cosmos_base_reflection_v1beta1::'),
              (r'(super::)+cosmos::base::reflection::v2alpha1::', 'crate::types::cosmos_base_reflection_v2alpha1::'),
              (r'(super::)+cosmos::base::node::v1beta1::', 'crate::types::cosmos_base_node_v1beta1::'),
              (r'(super::)+cosmos::crypto::multisig::v1beta1::', 'crate::types::cosmos_crypto_multisig_v1beta1::'),
              (r'(super::)+cosmos::crypto::hd::v1::', 'crate::types::cosmos_crypto_hd_v1::'),
              (r'(super::)+cosmos::tx::signing::v1beta1::', 'crate::types::cosmos_tx_signing_v1beta1::'),
              (r'(super::)+cosmos::ics23::v1::', 'crate::types::cosmos_ics23_v1::'),
              (r'(super::)+cosmos::upgrade::v1beta1::', 'crate::types::cosmos_upgrade_v1beta1::'),
              (r'(super::)+cosmos::store::v1beta1::', 'crate::types::cosmos_store_v1beta1::'),
              # Two-level paths
              (r'(super::)+tendermint::abci::', 'crate::types::tendermint_abci::'),
              (r'(super::)+tendermint::types::', 'crate::types::tendermint_types::'),
              (r'(super::)+tendermint::version::', 'crate::types::tendermint_version::'),
              (r'(super::)+tendermint::p2p::', 'crate::types::tendermint_p2p::'),
              (r'(super::)+tendermint::crypto::', 'crate::types::tendermint_crypto::'),
              (r'(super::)+cosmos::base::v1beta1::', 'crate::types::cosmos_base_v1beta1::'),
              (r'(super::)+cosmos::bank::v1beta1::', 'crate::types::cosmos_bank_v1beta1::'),
              (r'(super::)+cosmos::auth::v1beta1::', 'crate::types::cosmos_auth_v1beta1::'),
              (r'(super::)+cosmos::authz::v1beta1::', 'crate::types::cosmos_authz_v1beta1::'),
              (r'(super::)+base::query::v1beta1::', 'crate::types::cosmos_base_query_v1beta1::'),
              (r'(super::)+base::v1beta1::', 'crate::types::cosmos_base_v1beta1::'),
              (r'(super::)+base::abci::v1beta1::', 'crate::types::cosmos_base_abci_v1beta1::'),
              # Single-level paths that need context
              (r'(super::)+query::v1beta1::', 'crate::types::cosmos_base_query_v1beta1::'),
              (r'(super::)+hd::v1::', 'crate::types::cosmos_crypto_hd_v1::'),
              (r'(super::)+crypto::multisig::v1beta1::', 'crate::types::cosmos_crypto_multisig_v1beta1::'),
              (r'(super::)+signing::v1beta1::', 'crate::types::cosmos_tx_signing_v1beta1::'),
              (r'(super::)+client::v1::', 'crate::types::ibc_core_client_v1::'),
              (r'(super::)+client::v2::', 'crate::types::ibc_core_client_v2::'),
              (r'(super::)+commitment::v1::', 'crate::types::ibc_core_commitment_v1::'),
              (r'(super::)+commitment::v2::', 'crate::types::ibc_core_commitment_v2::'),
              (r'(super::)+channel::v1::', 'crate::types::ibc_core_channel_v1::'),
              (r'(super::)+channel::v2::', 'crate::types::ibc_core_channel_v2::'),
              (r'(super::)+connection::v1::', 'crate::types::ibc_core_connection_v1::'),
              (r'(super::)+controller::v1::', 'crate::types::ibc_applications_interchain_accounts_controller_v1::'),
              (r'(super::)+host::v1::', 'crate::types::ibc_applications_interchain_accounts_host_v1::'),
              (r'(super::)+v1::', 'crate::types::ibc_applications_interchain_accounts_v1::'),
              (r'(super::)+v1beta1::', 'crate::types::cosmos_store_v1beta1::'),
          ]
          
          # Helper function to convert hierarchical path to flat module name
          def path_to_module(path_parts):
              """Convert ['cosmos', 'base', 'query', 'v1beta1'] to 'cosmos_base_query_v1beta1'"""
              return '_'.join(path_parts)
          
          files_processed = 0
          for rs_file in types_dir.rglob("*.rs"):
              if rs_file.name == "mod.rs":
                  continue
              
              content = rs_file.read_text()
              original = content
              
              # Apply specific mappings first
              for pattern_str, replacement in path_mappings:
                  content = re.sub(pattern_str, replacement, content)
              
              # Handle remaining super::super::... paths by converting to flat module names
              def replace_path(match):
                  path_parts = match.group(2).split('::')
                  mod_name = path_to_module(path_parts)
                  # Check if module exists, otherwise try common prefixes
                  if mod_name in module_map:
                      return f'crate::types::{mod_name}::'
                  # Try with cosmos prefix
                  cosmos_mod = f'cosmos_{mod_name}'
                  if cosmos_mod in module_map:
                      return f'crate::types::{cosmos_mod}::'
                  # Try with ibc prefix
                  ibc_mod = f'ibc_{mod_name}'
                  if ibc_mod in module_map:
                      return f'crate::types::{ibc_mod}::'
                  return match.group(0)  # Keep original if can't resolve
              
              # Match remaining super::... paths
              content = re.sub(
                  r'(super::)+([a-z_][a-z0-9_]*(?:::[a-z_][a-z0-9_]*)*)::',
                  replace_path,
                  content
              )
              
              # Fix super::types::, super::crypto::, and super::version:: in tendermint files
              if 'tendermint' in rs_file.stem:
                  content = re.sub(r'super::types::', 'crate::types::tendermint_types::', content)
                  content = re.sub(r'super::crypto::', 'crate::types::tendermint_crypto::', content)
                  content = re.sub(r'super::version::', 'crate::types::tendermint_version::', content)
              
              # Fix context-dependent paths like super::super::v1:: in IBC files
              # From ibc.applications.interchain_accounts.controller.v1.rs, super::super::v1:: -> interchain_accounts.v1
              if 'ibc.applications.interchain_accounts' in rs_file.stem:
                  # Extract parent module from filename
                  parts = rs_file.stem.split('.')
                  if 'controller' in parts or 'host' in parts:
                      # super::super::v1:: means go up to interchain_accounts.v1
                      parent_mod = '_'.join(parts[:-2])  # Remove controller.v1 or host.v1
                      content = re.sub(
                          r'super::super::v1::',
                          f'crate::types::{parent_mod}_v1::',
                          content
                      )
              
              # Fix already-converted paths that reference nested modules (e.g., crate::types::query::v1beta1::)
              def fix_nested_path(match):
                  path_parts = match.group(1).split('::')
                  mod_name = path_to_module(path_parts)
                  if mod_name in module_map:
                      return f'crate::types::{mod_name}::'
                  # Try with cosmos prefix
                  cosmos_mod = f'cosmos_{mod_name}'
                  if cosmos_mod in module_map:
                      return f'crate::types::{cosmos_mod}::'
                  # Try with ibc prefix  
                  ibc_mod = f'ibc_{mod_name}'
                  if ibc_mod in module_map:
                      return f'crate::types::{ibc_mod}::'
                  return match.group(0)
              
              # Fix paths like crate::types::query::v1beta1:: -> crate::types::cosmos_base_query_v1beta1::
              content = re.sub(
                  r'crate::types::([a-z_][a-z0-9_]*(?:::[a-z_][a-z0-9_]*)+)::',
                  fix_nested_path,
                  content
              )
              
              # Clean up invalid patterns
              content = re.sub(r'crate::types::super::+', 'crate::types::', content)
              
              # Fix Validators duplicate (enum conflicts with struct)
              if rs_file.name == 'cosmos.staking.v1beta1.rs':
                  # Rename the enum to ValidatorsEnum
                  content = re.sub(r'pub enum Validators \{', 'pub enum ValidatorsEnum {', content)
                  # Update oneof reference from Validators to ValidatorsEnum
                  content = re.sub(
                      r'oneof="stake_authorization::Validators"',
                      'oneof="stake_authorization::ValidatorsEnum"',
                      content
                  )
                  # Update Option<stake_authorization::Validators> to ValidatorsEnum (but keep struct Validators)
                  # This is tricky - we need to update the enum type, not the struct type
                  content = re.sub(
                      r'Option<stake_authorization::Validators>',
                      'Option<stake_authorization::ValidatorsEnum>',
                      content
                  )
                  # Update enum variant references that use the enum type
                  content = re.sub(
                      r'ValidatorsEnum::(AllowList|DenyList)\(Validators\)',
                      r'ValidatorsEnum::\1(Validators)',
                      content
                  )
              
              # Remove Copy from derive when struct contains non-Copy fields (Duration, Timestamp)
              # Check if struct contains Option<Duration> or Option<Timestamp>
              if 'Option<::prost_types::Duration>' in content or 'Option<::prost_types::Timestamp>' in content:
                  # Remove Copy from derive attributes that include prost::Message
                  content = re.sub(
                      r'#\[derive\(Clone,\s*Copy,\s*PartialEq,\s*::prost::Message\)\]',
                      '#[derive(Clone, PartialEq, ::prost::Message)]',
                      content
                  )
                  content = re.sub(
                      r'#\[derive\(Clone,\s*Copy,\s*::prost::Message\)\]',
                      '#[derive(Clone, ::prost::Message)]',
                      content
                  )
              
              # Fix doctest issues: prevent protobuf/YAML/EBNF code blocks from being compiled
              # Rust doctests extract indented code blocks (4+ spaces) and try to compile them
              # We add `# ` prefix to protobuf examples to make them comments (hidden from doctests)
              def fix_protobuf_code_blocks(text):
                  lines = text.split('\n')
                  result = []
                  i = 0
                  in_protobuf_block = False
                  
                  while i < len(lines):
                      line = lines[i]
                      protobuf_syntax = False
                      
                      # Check for ``` code blocks
                      if re.match(r'\s*///\s*```(?:rust)?\s*$', line):
                          # Look ahead to see if this code block contains protobuf syntax
                          j = i + 1
                          while j < len(lines) and j < i + 100:
                              if re.match(r'\s*///\s*```\s*$', lines[j]):
                                  break
                              if re.search(r'\bservice\s+\w+\s*\{', lines[j]) or \
                                 re.search(r'\brpc\s+\w+\(', lines[j]) or \
                                 re.search(r'\bmessage\s+\w+\s*\{', lines[j]) or \
                                 re.search(r'^\s*http:', lines[j]) or \
                                 re.search(r'\\\[.*\\\]', lines[j]):
                                  protobuf_syntax = True
                                  break
                              j += 1
                          
                          if protobuf_syntax:
                              result.append(re.sub(r'```(?:rust)?\s*$', '```text', line))
                              in_protobuf_block = True
                          else:
                              result.append(line)
                      # Check for indented code blocks (4+ spaces after ///) - these are treated as doctests
                      elif re.match(r'\s*///\s{4,}', line):
                          # If we're already in a protobuf block, continue adding # to this line
                          if in_protobuf_block:
                              result.append(re.sub(r'(///)(\s+)', r'\1 #\2', line))
                          else:
                              # Check current line first for quick detection
                              protobuf_syntax = (
                                  re.search(r'///.*\bservice\s+\w+\s*\{', line) or
                                  re.search(r'///.*\brpc\s+\w+\(', line) or
                                  re.search(r'///.*\bmessage\s+\w+\s*\{', line) or
                                  re.search(r'///.*http:', line) or
                                  re.search(r'///.*\\\[.*\\\]', line) or
                                  re.search(r'///.*Template\s*=\s*"/"', line) or
                                  re.search(r'///.*Variable\s*=\s*"\{', line) or
                                  re.search(r'///.*rules:', line) or
                                  re.search(r'///.*selector:', line)
                              )
                              
                              # If not found in current line, check nearby lines
                              if not protobuf_syntax:
                                  check_lines = [line]
                                  for j in range(i + 1, min(i + 20, len(lines))):
                                      if not re.match(r'\s*///', lines[j]):
                                          break
                                      check_lines.append(lines[j])
                                  
                                  block_text = '\n'.join(check_lines)
                                  protobuf_syntax = (
                                      re.search(r'///.*\bservice\s+\w+\s*\{', block_text) or
                                      re.search(r'///.*\brpc\s+\w+\(', block_text) or
                                      re.search(r'///.*\bmessage\s+\w+\s*\{', block_text) or
                                      re.search(r'///.*http:', block_text) or
                                      re.search(r'///.*\\\[.*\\\]', block_text) or
                                      re.search(r'///.*Template\s*=\s*"/"', block_text) or
                                      re.search(r'///.*Variable\s*=\s*"\{', block_text) or
                                      re.search(r'///.*rules:', block_text) or
                                      re.search(r'///.*selector:', block_text)
                                  )
                              
                              if protobuf_syntax:
                                  in_protobuf_block = True
                                  # Add `# ` prefix after /// to make it a comment (hidden from doctests)
                                  # Change `///      code` to `/// #      code` to prevent doctest extraction
                                  result.append(re.sub(r'(///)(\s+)', r'\1 #\2', line))
                              else:
                                  result.append(line)
                      else:
                          # Check if we're ending a protobuf block
                          if in_protobuf_block:
                              if re.match(r'\s*///\s*```\s*$', line):
                                  in_protobuf_block = False
                                  result.append(line)
                              elif not re.match(r'\s*///', line):
                                  in_protobuf_block = False
                                  result.append(line)
                              elif re.match(r'\s*///\s*$', line) or re.match(r'\s*///\s{1,3}\S', line):
                                  # Non-indented doc comment line - end the block
                                  in_protobuf_block = False
                                  result.append(line)
                              else:
                                  # Still in block but not indented - shouldn't happen, but handle it
                                  result.append(line)
                          else:
                              result.append(line)
                      
                      i += 1
                  
                  return '\n'.join(result)
              
              content = fix_protobuf_code_blocks(content)
              
              if content != original:
                  rs_file.write_text(content)
                  files_processed += 1
          
          print(f"✅ Setup complete: processed {files_processed} files")
          PYTHON

      - name: Cache Rust Dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: './rust'

      - name: Update Version
        working-directory: ./rust
        env:
          VERSION: ${{ needs.determine-version.outputs.version }}
        run: |
          sed -i "s/^version = .*/version = \"$VERSION\"/" Cargo.toml
          echo "✅ Updated Cargo.toml with version $VERSION"

      - name: Build Crate
        working-directory: ./rust
        run: |
          cargo build --release
          echo "✅ Crate built successfully"

      - name: Package Crate
        working-directory: ./rust
        run: |
          cargo package --allow-dirty
          echo "✅ Crate packaged successfully"

      - name: Upload Package
        uses: actions/upload-artifact@v4
        with:
          name: rust-crate
          path: rust/target/package/*.crate
          retention-days: 30

      - name: Upload Rust Source Directory
        uses: actions/upload-artifact@v4
        with:
          name: rust-source
          path: rust
          retention-days: 30

  rust-test:
    name: Test Rust ${{ matrix.rust-version }}
    needs: [rust-build]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        rust-version: ['1.70', '1.75', 'stable']
      fail-fast: false
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Generated Rust Types
        uses: actions/download-artifact@v4
        with:
          name: generated-types-rust
          path: rust/types

      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: ${{ matrix.rust-version }}
          cache: false  # Disable auto-cache, we'll handle it manually

      - name: Create Rust Package Structure
        run: |
          mkdir -p rust/src
          
          # Create Cargo.toml if it doesn't exist
          if [ ! -f "rust/Cargo.toml" ]; then
            cat > rust/Cargo.toml << 'CARGO'
          [package]
          name = "xion-types"
          version = "0.1.0"
          edition = "2021"
          description = "Generated Rust types for Xion blockchain protocol buffers"
          license = "Apache-2.0"
          repository = "https://github.com/burnt-labs/xion-types"
          
          [lib]
          name = "xion_types"
          path = "src/lib.rs"
          
          [dependencies]
          prost = "0.12"
          prost-types = "0.12"
          CARGO
          fi
          
          # Single Python script to handle all setup
          python3 << 'PYTHON'
          import re
          from pathlib import Path
          
          types_dir = Path("rust/types")
          if not types_dir.exists():
              print("❌ rust/types directory not found")
              exit(1)
          
          # 1. Generate mod.rs files recursively
          def create_mod_rs(dir_path):
              rs_files = [f for f in dir_path.glob("*.rs") if f.name != "mod.rs"]
              subdirs = [d for d in dir_path.iterdir() if d.is_dir() and create_mod_rs(d)]
              
              if not rs_files and not subdirs:
                  return False
              
              with (dir_path / "mod.rs").open("w") as f:
                  f.write("// Auto-generated module\n")
                  for rs_file in sorted(rs_files):
                      modname = rs_file.stem
                      if '.' in modname:
                          f.write(f'#[path = "{rs_file.name}"]\npub mod {modname.replace(".", "_")};\n')
                      else:
                          f.write(f"pub mod {modname};\n")
                  for subdir in subdirs:
                      f.write(f"pub mod {subdir.name};\n")
              return True
          
          # Process subdirectories first
          for item in sorted(types_dir.iterdir()):
              if item.is_dir() and any(item.rglob("*.rs")):
                  create_mod_rs(item)
          
          # Create root mod.rs
          with (types_dir / "mod.rs").open("w") as f:
              f.write("// Auto-generated module\n")
              for item in sorted(types_dir.iterdir()):
                  if item.is_dir() and (item / "mod.rs").exists():
                      f.write(f"pub mod {item.name};\n")
                  elif item.suffix == ".rs" and item.name != "mod.rs":
                      modname = item.stem
                      if '.' in modname:
                          f.write(f'#[path = "{item.name}"]\npub mod {modname.replace(".", "_")};\n')
                      else:
                          f.write(f"pub mod {modname};\n")
          
          # 2. Create lib.rs
          lib_rs = Path("rust/src/lib.rs")
          lib_rs.parent.mkdir(parents=True, exist_ok=True)
          lib_rs.write_text("""//! Generated Rust types for Xion blockchain protocol buffers
          
          pub mod types {
              include!(concat!(env!("CARGO_MANIFEST_DIR"), "/types/mod.rs"));
          }
          """)
          
          # 3. Build module name map from actual files
          module_map = {}
          for rs_file in types_dir.rglob("*.rs"):
              if rs_file.name == "mod.rs":
                  continue
              # File: cosmos.base.query.v1beta1.rs -> module: cosmos_base_query_v1beta1
              mod_name = rs_file.stem.replace('.', '_')
              module_map[mod_name] = rs_file
          
          # 4. Fix module paths in generated files
          # Order matters: most specific first
          path_mappings = [
              # IBC multi-level paths (most specific)
              (r'(super::)+ibc::applications::interchain_accounts::controller::v1::', 'crate::types::ibc_applications_interchain_accounts_controller_v1::'),
              (r'(super::)+ibc::applications::interchain_accounts::host::v1::', 'crate::types::ibc_applications_interchain_accounts_host_v1::'),
              (r'(super::)+ibc::applications::interchain_accounts::v1::', 'crate::types::ibc_applications_interchain_accounts_v1::'),
              (r'(super::)+ibc::core::channel::v1::', 'crate::types::ibc_core_channel_v1::'),
              (r'(super::)+ibc::core::channel::v2::', 'crate::types::ibc_core_channel_v2::'),
              (r'(super::)+ibc::core::connection::v1::', 'crate::types::ibc_core_connection_v1::'),
              (r'(super::)+ibc::core::types::v1::', 'crate::types::ibc_core_types_v1::'),
              (r'(super::)+ibc::core::client::v1::', 'crate::types::ibc_core_client_v1::'),
              (r'(super::)+ibc::core::client::v2::', 'crate::types::ibc_core_client_v2::'),
              (r'(super::)+ibc::core::commitment::v1::', 'crate::types::ibc_core_commitment_v1::'),
              (r'(super::)+ibc::core::commitment::v2::', 'crate::types::ibc_core_commitment_v2::'),
              # Cosmos multi-level paths
              (r'(super::)+tendermint::libs::bits::', 'crate::types::tendermint_libs_bits::'),
              (r'(super::)+cosmos::base::tendermint::v1beta1::', 'crate::types::cosmos_base_tendermint_v1beta1::'),
              (r'(super::)+cosmos::base::query::v1beta1::', 'crate::types::cosmos_base_query_v1beta1::'),
              (r'(super::)+cosmos::base::abci::v1beta1::', 'crate::types::cosmos_base_abci_v1beta1::'),
              (r'(super::)+cosmos::base::reflection::v1beta1::', 'crate::types::cosmos_base_reflection_v1beta1::'),
              (r'(super::)+cosmos::base::reflection::v2alpha1::', 'crate::types::cosmos_base_reflection_v2alpha1::'),
              (r'(super::)+cosmos::base::node::v1beta1::', 'crate::types::cosmos_base_node_v1beta1::'),
              (r'(super::)+cosmos::crypto::multisig::v1beta1::', 'crate::types::cosmos_crypto_multisig_v1beta1::'),
              (r'(super::)+cosmos::crypto::hd::v1::', 'crate::types::cosmos_crypto_hd_v1::'),
              (r'(super::)+cosmos::tx::signing::v1beta1::', 'crate::types::cosmos_tx_signing_v1beta1::'),
              (r'(super::)+cosmos::ics23::v1::', 'crate::types::cosmos_ics23_v1::'),
              (r'(super::)+cosmos::upgrade::v1beta1::', 'crate::types::cosmos_upgrade_v1beta1::'),
              (r'(super::)+cosmos::store::v1beta1::', 'crate::types::cosmos_store_v1beta1::'),
              # Two-level paths
              (r'(super::)+tendermint::abci::', 'crate::types::tendermint_abci::'),
              (r'(super::)+tendermint::types::', 'crate::types::tendermint_types::'),
              (r'(super::)+tendermint::version::', 'crate::types::tendermint_version::'),
              (r'(super::)+tendermint::p2p::', 'crate::types::tendermint_p2p::'),
              (r'(super::)+tendermint::crypto::', 'crate::types::tendermint_crypto::'),
              (r'(super::)+cosmos::base::v1beta1::', 'crate::types::cosmos_base_v1beta1::'),
              (r'(super::)+cosmos::bank::v1beta1::', 'crate::types::cosmos_bank_v1beta1::'),
              (r'(super::)+cosmos::auth::v1beta1::', 'crate::types::cosmos_auth_v1beta1::'),
              (r'(super::)+cosmos::authz::v1beta1::', 'crate::types::cosmos_authz_v1beta1::'),
              (r'(super::)+base::query::v1beta1::', 'crate::types::cosmos_base_query_v1beta1::'),
              (r'(super::)+base::v1beta1::', 'crate::types::cosmos_base_v1beta1::'),
              (r'(super::)+base::abci::v1beta1::', 'crate::types::cosmos_base_abci_v1beta1::'),
              # Single-level paths that need context
              (r'(super::)+query::v1beta1::', 'crate::types::cosmos_base_query_v1beta1::'),
              (r'(super::)+hd::v1::', 'crate::types::cosmos_crypto_hd_v1::'),
              (r'(super::)+crypto::multisig::v1beta1::', 'crate::types::cosmos_crypto_multisig_v1beta1::'),
              (r'(super::)+signing::v1beta1::', 'crate::types::cosmos_tx_signing_v1beta1::'),
              (r'(super::)+client::v1::', 'crate::types::ibc_core_client_v1::'),
              (r'(super::)+client::v2::', 'crate::types::ibc_core_client_v2::'),
              (r'(super::)+commitment::v1::', 'crate::types::ibc_core_commitment_v1::'),
              (r'(super::)+commitment::v2::', 'crate::types::ibc_core_commitment_v2::'),
              (r'(super::)+channel::v1::', 'crate::types::ibc_core_channel_v1::'),
              (r'(super::)+channel::v2::', 'crate::types::ibc_core_channel_v2::'),
              (r'(super::)+connection::v1::', 'crate::types::ibc_core_connection_v1::'),
              (r'(super::)+controller::v1::', 'crate::types::ibc_applications_interchain_accounts_controller_v1::'),
              (r'(super::)+host::v1::', 'crate::types::ibc_applications_interchain_accounts_host_v1::'),
              (r'(super::)+v1::', 'crate::types::ibc_applications_interchain_accounts_v1::'),
              (r'(super::)+v1beta1::', 'crate::types::cosmos_store_v1beta1::'),
          ]
          
          # Helper function to convert hierarchical path to flat module name
          def path_to_module(path_parts):
              """Convert ['cosmos', 'base', 'query', 'v1beta1'] to 'cosmos_base_query_v1beta1'"""
              return '_'.join(path_parts)
          
          files_processed = 0
          for rs_file in types_dir.rglob("*.rs"):
              if rs_file.name == "mod.rs":
                  continue
              
              content = rs_file.read_text()
              original = content
              
              # Apply specific mappings first
              for pattern_str, replacement in path_mappings:
                  content = re.sub(pattern_str, replacement, content)
              
              # Handle remaining super::super::... paths by converting to flat module names
              def replace_path(match):
                  path_parts = match.group(2).split('::')
                  mod_name = path_to_module(path_parts)
                  # Check if module exists, otherwise try common prefixes
                  if mod_name in module_map:
                      return f'crate::types::{mod_name}::'
                  # Try with cosmos prefix
                  cosmos_mod = f'cosmos_{mod_name}'
                  if cosmos_mod in module_map:
                      return f'crate::types::{cosmos_mod}::'
                  # Try with ibc prefix
                  ibc_mod = f'ibc_{mod_name}'
                  if ibc_mod in module_map:
                      return f'crate::types::{ibc_mod}::'
                  return match.group(0)  # Keep original if can't resolve
              
              # Match remaining super::... paths
              content = re.sub(
                  r'(super::)+([a-z_][a-z0-9_]*(?:::[a-z_][a-z0-9_]*)*)::',
                  replace_path,
                  content
              )
              
              # Fix super::types::, super::crypto::, and super::version:: in tendermint files
              if 'tendermint' in rs_file.stem:
                  content = re.sub(r'super::types::', 'crate::types::tendermint_types::', content)
                  content = re.sub(r'super::crypto::', 'crate::types::tendermint_crypto::', content)
                  content = re.sub(r'super::version::', 'crate::types::tendermint_version::', content)
              
              # Fix context-dependent paths like super::super::v1:: in IBC files
              # From ibc.applications.interchain_accounts.controller.v1.rs, super::super::v1:: -> interchain_accounts.v1
              if 'ibc.applications.interchain_accounts' in rs_file.stem:
                  # Extract parent module from filename
                  parts = rs_file.stem.split('.')
                  if 'controller' in parts or 'host' in parts:
                      # super::super::v1:: means go up to interchain_accounts.v1
                      parent_mod = '_'.join(parts[:-2])  # Remove controller.v1 or host.v1
                      content = re.sub(
                          r'super::super::v1::',
                          f'crate::types::{parent_mod}_v1::',
                          content
                      )
              
              # Fix already-converted paths that reference nested modules (e.g., crate::types::query::v1beta1::)
              def fix_nested_path(match):
                  path_parts = match.group(1).split('::')
                  mod_name = path_to_module(path_parts)
                  if mod_name in module_map:
                      return f'crate::types::{mod_name}::'
                  # Try with cosmos prefix
                  cosmos_mod = f'cosmos_{mod_name}'
                  if cosmos_mod in module_map:
                      return f'crate::types::{cosmos_mod}::'
                  # Try with ibc prefix  
                  ibc_mod = f'ibc_{mod_name}'
                  if ibc_mod in module_map:
                      return f'crate::types::{ibc_mod}::'
                  return match.group(0)
              
              # Fix paths like crate::types::query::v1beta1:: -> crate::types::cosmos_base_query_v1beta1::
              content = re.sub(
                  r'crate::types::([a-z_][a-z0-9_]*(?:::[a-z_][a-z0-9_]*)+)::',
                  fix_nested_path,
                  content
              )
              
              # Clean up invalid patterns
              content = re.sub(r'crate::types::super::+', 'crate::types::', content)
              
              # Fix Validators duplicate (enum conflicts with struct)
              if rs_file.name == 'cosmos.staking.v1beta1.rs':
                  # Rename the enum to ValidatorsEnum
                  content = re.sub(r'pub enum Validators \{', 'pub enum ValidatorsEnum {', content)
                  # Update oneof reference from Validators to ValidatorsEnum
                  content = re.sub(
                      r'oneof="stake_authorization::Validators"',
                      'oneof="stake_authorization::ValidatorsEnum"',
                      content
                  )
                  # Update Option<stake_authorization::Validators> to ValidatorsEnum (but keep struct Validators)
                  # This is tricky - we need to update the enum type, not the struct type
                  content = re.sub(
                      r'Option<stake_authorization::Validators>',
                      'Option<stake_authorization::ValidatorsEnum>',
                      content
                  )
                  # Update enum variant references that use the enum type
                  content = re.sub(
                      r'ValidatorsEnum::(AllowList|DenyList)\(Validators\)',
                      r'ValidatorsEnum::\1(Validators)',
                      content
                  )
              
              # Remove Copy from derive when struct contains non-Copy fields (Duration, Timestamp)
              # Check if struct contains Option<Duration> or Option<Timestamp>
              if 'Option<::prost_types::Duration>' in content or 'Option<::prost_types::Timestamp>' in content:
                  # Remove Copy from derive attributes that include prost::Message
                  content = re.sub(
                      r'#\[derive\(Clone,\s*Copy,\s*PartialEq,\s*::prost::Message\)\]',
                      '#[derive(Clone, PartialEq, ::prost::Message)]',
                      content
                  )
                  content = re.sub(
                      r'#\[derive\(Clone,\s*Copy,\s*::prost::Message\)\]',
                      '#[derive(Clone, ::prost::Message)]',
                      content
                  )
              
              # Fix doctest issues: prevent protobuf/YAML/EBNF code blocks from being compiled
              # Rust doctests extract indented code blocks (4+ spaces) and try to compile them
              # We add `# ` prefix to protobuf examples to make them comments (hidden from doctests)
              def fix_protobuf_code_blocks(text):
                  lines = text.split('\n')
                  result = []
                  i = 0
                  in_protobuf_block = False
                  
                  while i < len(lines):
                      line = lines[i]
                      protobuf_syntax = False
                      
                      # Check for ``` code blocks
                      if re.match(r'\s*///\s*```(?:rust)?\s*$', line):
                          # Look ahead to see if this code block contains protobuf syntax
                          j = i + 1
                          while j < len(lines) and j < i + 100:
                              if re.match(r'\s*///\s*```\s*$', lines[j]):
                                  break
                              if re.search(r'\bservice\s+\w+\s*\{', lines[j]) or \
                                 re.search(r'\brpc\s+\w+\(', lines[j]) or \
                                 re.search(r'\bmessage\s+\w+\s*\{', lines[j]) or \
                                 re.search(r'^\s*http:', lines[j]) or \
                                 re.search(r'\\\[.*\\\]', lines[j]):
                                  protobuf_syntax = True
                                  break
                              j += 1
                          
                          if protobuf_syntax:
                              result.append(re.sub(r'```(?:rust)?\s*$', '```text', line))
                              in_protobuf_block = True
                          else:
                              result.append(line)
                      # Check for indented code blocks (4+ spaces after ///) - these are treated as doctests
                      elif re.match(r'\s*///\s{4,}', line):
                          # If we're already in a protobuf block, continue adding # to this line
                          if in_protobuf_block:
                              result.append(re.sub(r'(///)(\s+)', r'\1 #\2', line))
                          else:
                              # Check current line first for quick detection
                              protobuf_syntax = (
                                  re.search(r'///.*\bservice\s+\w+\s*\{', line) or
                                  re.search(r'///.*\brpc\s+\w+\(', line) or
                                  re.search(r'///.*\bmessage\s+\w+\s*\{', line) or
                                  re.search(r'///.*http:', line) or
                                  re.search(r'///.*\\\[.*\\\]', line) or
                                  re.search(r'///.*Template\s*=\s*"/"', line) or
                                  re.search(r'///.*Variable\s*=\s*"\{', line) or
                                  re.search(r'///.*rules:', line) or
                                  re.search(r'///.*selector:', line)
                              )
                              
                              # If not found in current line, check nearby lines
                              if not protobuf_syntax:
                                  check_lines = [line]
                                  for j in range(i + 1, min(i + 20, len(lines))):
                                      if not re.match(r'\s*///', lines[j]):
                                          break
                                      check_lines.append(lines[j])
                                  
                                  block_text = '\n'.join(check_lines)
                                  protobuf_syntax = (
                                      re.search(r'///.*\bservice\s+\w+\s*\{', block_text) or
                                      re.search(r'///.*\brpc\s+\w+\(', block_text) or
                                      re.search(r'///.*\bmessage\s+\w+\s*\{', block_text) or
                                      re.search(r'///.*http:', block_text) or
                                      re.search(r'///.*\\\[.*\\\]', block_text) or
                                      re.search(r'///.*Template\s*=\s*"/"', block_text) or
                                      re.search(r'///.*Variable\s*=\s*"\{', block_text) or
                                      re.search(r'///.*rules:', block_text) or
                                      re.search(r'///.*selector:', block_text)
                                  )
                              
                              if protobuf_syntax:
                                  in_protobuf_block = True
                                  # Add `# ` prefix after /// to make it a comment (hidden from doctests)
                                  # Change `///      code` to `/// #      code` to prevent doctest extraction
                                  result.append(re.sub(r'(///)(\s+)', r'\1 #\2', line))
                              else:
                                  result.append(line)
                      else:
                          # Check if we're ending a protobuf block
                          if in_protobuf_block:
                              if re.match(r'\s*///\s*```\s*$', line):
                                  in_protobuf_block = False
                                  result.append(line)
                              elif not re.match(r'\s*///', line):
                                  in_protobuf_block = False
                                  result.append(line)
                              elif re.match(r'\s*///\s*$', line) or re.match(r'\s*///\s{1,3}\S', line):
                                  # Non-indented doc comment line - end the block
                                  in_protobuf_block = False
                                  result.append(line)
                              else:
                                  # Still in block but not indented - shouldn't happen, but handle it
                                  result.append(line)
                          else:
                              result.append(line)
                      
                      i += 1
                  
                  return '\n'.join(result)
              
              content = fix_protobuf_code_blocks(content)
              
              if content != original:
                  rs_file.write_text(content)
                  files_processed += 1
          
          print(f"✅ Setup complete: processed {files_processed} files")
          PYTHON

      - name: Cache Rust Dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: './rust'

      - name: Update Version
        working-directory: ./rust
        env:
          VERSION: ${{ needs.rust-build.outputs.version }}
        run: |
          sed -i "s/^version = .*/version = \"$VERSION\"/" Cargo.toml

      - name: Run Tests
        working-directory: ./rust
        run: |
          cargo test --verbose
          echo "✅ Tests passed for Rust ${{ matrix.rust-version }}"

      - name: Check Build
        working-directory: ./rust
        run: |
          cargo check --verbose
          echo "✅ Build check passed for Rust ${{ matrix.rust-version }}"

  rust-publish:
    name: Publish to crates.io
    needs: [rust-test, rust-build]
    runs-on: ubuntu-latest
    steps:
      - name: Download Rust Source Directory
        uses: actions/download-artifact@v4
        with:
          name: rust-source
          path: rust
  
      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable
          cache: false
  
      - name: Update Version
        working-directory: ./rust
        env:
          VERSION: ${{ needs.rust-build.outputs.version }}
        run: |
          if [ -z "$VERSION" ]; then
            echo "❌ Error: VERSION is empty. Cannot publish without a version."
            exit 1
          fi
          echo "Setting version to: $VERSION"
          sed -i "s/^version = .*/version = \"$VERSION\"/" Cargo.toml
          echo "✅ Updated Cargo.toml with version $VERSION"
  
    #   - name: Dry Run Publish
    #     working-directory: ./rust
    #     env:
    #       CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
    #     run: |
    #       cargo publish --dry-run --allow-dirty
    #       echo "✅ Dry run successful"
  
      - name: Publish Crate
        working-directory: ./rust
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CRATESIO_ACCESS_TOKEN }}
        run: |
          cargo publish --allow-dirty
          echo "✅ Crate published successfully [check: https://crates.io/dashboard/packages/xion-types]"

