name: Rust Protobuf Gen & Publish

on:
  push:
    branches: 
    #   - main 
      - feat/protobufs
            
  workflow_dispatch:
    inputs:
      next_version:
        description: 'Specific version to set (e.g., 1.2.3). Required for publishing.'
        required: true
        type: string

  repository_dispatch:
    types: [xion-types-release-trigger]
    
  schedule:
    - cron: '0 2 * * *' # Run nightly at 2 AM UTC

jobs:
  generate-protobuf:
    name: Generate Rust Types
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          submodules: false
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate Rust Definitions
        run: |
          make proto-gen-rust

      - name: Check if Types Were Generated
        run: |
          if [ -d "./rust/types" ] && [ "$(ls -A ./rust/types)" ]; then
            echo "‚úÖ Rust definitions generated successfully"
          else
            echo "‚ùå Failed to generate Rust definitions"
            exit 1
          fi

      - name: Upload Generated Types
        uses: actions/upload-artifact@v4
        with:
          name: generated-types-rust
          path: rust/types
          retention-days: 30

  determine-version:
    name: Determine Version
    needs: [generate-protobuf]
    runs-on: ubuntu-latest
    if: |
        github.ref == 'refs/heads/feat/protobufs' ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.next_version != '') || 
        (github.event_name == 'repository_dispatch' && github.event.client_payload.release_type == 'published')
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine Version
        # Version scenarios:
        # 1. Manual trigger (workflow_dispatch) ‚Üí Use input version (e.g., "1.2.3")
        # 2. Release event (repository_dispatch) ‚Üí Use release tag (e.g., "v1.2.3" ‚Üí "1.2.3")
        # 3. Push to branch ‚Üí Generate dev version (e.g., "0.0.0-dev.abc1234")
        id: version
        run: |
          if [ "${{ github.event.inputs.next_version }}" != "" ]; then
            VERSION="${{ github.event.inputs.next_version }}"
            echo "Using manual version: $VERSION"
          elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            RELEASE_TAG="${{ github.event.client_payload.tag_name }}"
            VERSION=${RELEASE_TAG#v}
            echo "Using release version: $VERSION (from tag: $RELEASE_TAG)"
          elif [ "${{ github.event_name }}" == "push" ]; then
            GIT_SHA=$(git rev-parse --short HEAD)
            VERSION="0.0.0-dev.${GIT_SHA}"
            echo "Using dev version for testing: $VERSION"
          else
            echo "‚ùå No version specified"
            exit 1
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT

  # ============================================
  # Rust Crate Publishing
  # ============================================

  rust-build:
    name: Build Rust Crate
    needs: [determine-version, generate-protobuf]
    runs-on: ubuntu-latest
    outputs:
      version: ${{ needs.determine-version.outputs.version }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Generated Rust Types
        uses: actions/download-artifact@v4
        with:
          name: generated-types-rust
          path: rust/types

      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable
          cache: false  # Disable auto-cache, we'll handle it manually

      - name: Create Rust Package Structure
        run: |
          mkdir -p rust/src
          # Create lib.rs that includes generated types
          # Using include!() because generated code uses super::super paths
          # that expect types/ to be at crate root level relative to CARGO_MANIFEST_DIR
          cat > rust/src/lib.rs << 'LIB'
          //! Generated Rust types for Xion blockchain protocol buffers
          
          // Include generated protobuf modules
          // Note: types/ is kept outside src/ because generated code uses
          // super::super::cosmos::... paths that expect this structure
          pub mod types {
              include!(concat!(env!("CARGO_MANIFEST_DIR"), "/types/mod.rs"));
          }
          
          // Re-export modules at crate root for super::super paths
          // Generated code uses paths like super::super::cosmos::base::v1beta1::Coin
          // which expect these modules at crate root level
          // Only re-export if they exist in types module
          #[allow(unused_imports)]
          pub use types::*;
          LIB
          
          # Generate re-exports dynamically based on what's in types/mod.rs
          python3 << 'PYTHON'
          import re
          from pathlib import Path
          
          types_mod = Path("rust/types/mod.rs")
          if types_mod.exists():
              content = types_mod.read_text()
              # Find all "pub mod X;" declarations
              mod_declarations = re.findall(r'pub mod (\w+);', content)
              
              # Common modules that generated code references via super::super
              needed_modules = ['cosmos', 'base', 'amino', 'gogoproto', 'cosmos_proto', 
                              'xion', 'abstractaccount', 'ibc', 'tendermint', 
                              'osmosis', 'packetforward', 'cosmwasm']
              
              # Find which modules actually exist
              existing_modules = [m for m in needed_modules if m in mod_declarations]
              
              if existing_modules:
                  lib_rs = Path("rust/src/lib.rs")
                  lib_content = lib_rs.read_text()
                  
                  # Replace the generic pub use with specific re-exports
                  re_exports = '\n'.join([f'pub use types::{m};' for m in existing_modules])
                  lib_content = lib_content.replace(
                      '#[allow(unused_imports)]\npub use types::*;',
                      f'// Re-export modules at crate root for super::super paths\n{re_exports}'
                  )
                  
                  lib_rs.write_text(lib_content)
                  print(f"‚úÖ Added re-exports for: {', '.join(existing_modules)}")
              else:
                  print("‚ö†Ô∏è No matching modules found to re-export")
          PYTHON
          
          # Create Cargo.toml
          if [ ! -f "rust/Cargo.toml" ]; then
            cat > rust/Cargo.toml << 'CARGO'
          [package]
          name = "xion-types"
          version = "0.1.0"
          edition = "2021"
          description = "Generated Rust types for Xion blockchain protocol buffers"
          license = "Apache-2.0"
          repository = "https://github.com/burnt-labs/xion-types"
          
          [lib]
          name = "xion_types"
          path = "src/lib.rs"
          
          [dependencies]
          prost = "0.12"
          prost-types = "0.12"
          CARGO
            echo "‚úÖ Created rust/Cargo.toml"
          else
            echo "‚úÖ rust/Cargo.toml already exists"
          fi
          
          # Generate mod.rs recursively for all directories
          python3 << 'PYTHON'
          import os
          import re
          from pathlib import Path
          
          def has_any_rs_files(dir_path):
              """Check if directory or any subdirectory has .rs files"""
              for rs_file in dir_path.rglob("*.rs"):
                  if rs_file.name != "mod.rs":
                      return True
              return False
          
          def create_mod_rs(dir_path):
              """Recursively create mod.rs files for directories with .rs files or subdirs"""
              mod_rs_path = dir_path / "mod.rs"
              
              # Check for direct .rs files (excluding mod.rs)
              rs_files = [f for f in dir_path.glob("*.rs") if f.name != "mod.rs"]
              has_rs_files = len(rs_files) > 0
              
              # Process subdirectories recursively first
              subdirs_with_mod_rs = []
              for subdir in sorted(dir_path.iterdir()):
                  if subdir.is_dir():
                      if create_mod_rs(subdir):
                          subdirs_with_mod_rs.append(subdir)
              
              # Only create mod.rs if we have direct .rs files OR subdirs with mod.rs
              # But skip if this directory has no .rs files anywhere (even nested)
              if not has_any_rs_files(dir_path):
                  return False
              
              if has_rs_files or subdirs_with_mod_rs:
                  with mod_rs_path.open("w") as f:
                      f.write("// Auto-generated module\n")
                      
                      # Add direct .rs files
                      for rs_file in sorted(rs_files):
                          modname = rs_file.stem
                          filename = rs_file.name
                          
                          # Rust module names cannot contain dots, so use #[path] attribute
                          if '.' in modname:
                              # Convert dots to underscores for module name, but keep original filename
                              safe_modname = modname.replace('.', '_')
                              f.write(f'#[path = "{filename}"]\n')
                              f.write(f"pub mod {safe_modname};\n")
                          else:
                              f.write(f"pub mod {modname};\n")
                      
                      # Add subdirectories that have mod.rs
                      for subdir in subdirs_with_mod_rs:
                          f.write(f"pub mod {subdir.name};\n")
                  
                  return True
              
              return False
          
          types_dir = Path("rust/types")
          if types_dir.exists():
              # Process all subdirectories recursively first
              subdirs_added = []
              for item in sorted(types_dir.iterdir()):
                  if item.is_dir():
                      # Only add if directory has any .rs files AND mod.rs was successfully created
                      if has_any_rs_files(item):
                          if create_mod_rs(item):
                              # Verify mod.rs was actually created
                              mod_rs_path = item / "mod.rs"
                              if mod_rs_path.exists():
                                  subdirs_added.append(item)
                                  print(f"   Added module: {item.name}")
                              else:
                                  print(f"   Skipped {item.name}: mod.rs not created")
                          else:
                              print(f"   Skipped {item.name}: create_mod_rs returned False")
                      else:
                          print(f"   Skipped {item.name}: no .rs files found")
              
              # Create mod.rs for root types directory (after processing subdirs)
              root_mod = types_dir / "mod.rs"
              with root_mod.open("w") as f:
                  f.write("// Auto-generated module - includes all generated protobuf types\n")
                  
                  # Add subdirectories that have mod.rs
                  for item in subdirs_added:
                      f.write(f"pub mod {item.name};\n")
                  
                  # Include direct .rs files
                  for rs_file in sorted(types_dir.glob("*.rs")):
                      if rs_file.name != "mod.rs":
                          modname = rs_file.stem
                          filename = rs_file.name
                          
                          # Rust module names cannot contain dots, so use #[path] attribute
                          if '.' in modname:
                              safe_modname = modname.replace('.', '_')
                              f.write(f'#[path = "{filename}"]\n')
                              f.write(f"pub mod {safe_modname};\n")
                          else:
                              f.write(f"pub mod {modname};\n")
              
              print("‚úÖ Generated rust/types/mod.rs recursively")
              print(f"   Added {len(subdirs_added)} subdirectories to root mod.rs")
              
              # Debug: Show what's in types/mod.rs
              types_mod = Path("rust/types/mod.rs")
              if types_mod.exists():
                  content = types_mod.read_text()
                  print(f"üìÑ types/mod.rs content (first 50 lines):")
                  print('\n'.join(content.split('\n')[:50]))
                  
                  # Find all "pub mod X;" declarations (handle #[path] attributes)
                  mod_declarations = set()
                  for line in content.split('\n'):
                      # Match "pub mod X;" ignoring #[path] lines
                      match = re.search(r'pub mod (\w+);', line)
                      if match:
                          mod_declarations.add(match.group(1))
                  
                  print(f"üì¶ Found {len(mod_declarations)} module declarations: {sorted(mod_declarations)[:20]}")
                  
                  # Check file structure - are files flat or in directories?
                  flat_files = list(Path("rust/types").glob("*.rs"))
                  dirs = [d for d in Path("rust/types").iterdir() if d.is_dir()]
                  print(f"üìÅ Structure: {len(flat_files)} flat .rs files, {len(dirs)} directories")
                  if dirs:
                      print(f"   Directories: {[d.name for d in dirs[:10]]}")
                  
                  # Common modules that generated code references via super::super
                  needed_modules = ['cosmos', 'base', 'amino', 'gogoproto', 'cosmos_proto', 
                                  'xion', 'abstractaccount', 'ibc', 'tendermint', 
                                  'osmosis', 'packetforward', 'cosmwasm']
                  
                  # Find which modules actually exist
                  existing_modules = [m for m in needed_modules if m in mod_declarations]
                  
                  if existing_modules:
                      lib_rs = Path("rust/src/lib.rs")
                      lib_content = lib_rs.read_text()
                      
                      # Add re-exports at the end
                      re_exports = '\n'.join([f'pub use types::{m};' for m in existing_modules])
                      lib_content = lib_content.rstrip() + '\n\n// Re-export modules at crate root for super::super paths\n' + re_exports + '\n'
                      
                      lib_rs.write_text(lib_content)
                      print(f"‚úÖ Added re-exports for: {', '.join(existing_modules)}")
                  else:
                      print("‚ö†Ô∏è No matching modules found to re-export")
                      print(f"   Needed: {needed_modules}")
                      print(f"   Available: {sorted(mod_declarations)[:30]}")
                      
                      # If modules don't exist, files might be flat - need to fix paths in generated code
                      print("üîß Files appear to be flat - will fix super::super paths in generated code")
              
              # Post-process generated files to fix super::super paths
              print("üîß Post-processing generated files to fix module paths...")
              
              # Build a map of actual module names from files
              # Files like "cosmos.base.v1beta1.rs" become module "cosmos_base_v1beta1"
              actual_modules = {}
              types_dir = Path("rust/types")
              for rs_file in types_dir.rglob("*.rs"):
                  if rs_file.name == "mod.rs":
                      continue
                  # Get module name - if file is cosmos.base.v1beta1.rs, module is cosmos_base_v1beta1
                  module_name = rs_file.stem.replace('.', '_')
                  actual_modules[module_name] = rs_file
              
              # Since files are flat, we need to map hierarchical paths to flat module names
              # Pattern: super::super::cosmos::base::v1beta1::Type
              # Should become: crate::types::cosmos_base_v1beta1::Type
              
              # Common hierarchical patterns to map to flat modules
              path_mappings = [
                  # cosmos::base::v1beta1 patterns
                  (r'super::super::cosmos::base::v1beta1::', 'crate::types::cosmos_base_v1beta1::'),
                  (r'super::super::cosmos::base::query::v1beta1::', 'crate::types::cosmos_base_query_v1beta1::'),
                  (r'super::super::cosmos::base::abci::v1beta1::', 'crate::types::cosmos_base_abci_v1beta1::'),
                  (r'super::super::cosmos::base::tendermint::v1beta1::', 'crate::types::cosmos_base_tendermint_v1beta1::'),
                  (r'super::super::cosmos::base::reflection::v1beta1::', 'crate::types::cosmos_base_reflection_v1beta1::'),
                  (r'super::super::cosmos::base::reflection::v2alpha1::', 'crate::types::cosmos_base_reflection_v2alpha1::'),
                  (r'super::super::cosmos::base::node::v1beta1::', 'crate::types::cosmos_base_node_v1beta1::'),
                  # cosmos::bank::v1beta1 patterns
                  (r'super::super::cosmos::bank::v1beta1::', 'crate::types::cosmos_bank_v1beta1::'),
                  # cosmos::auth::v1beta1 patterns
                  (r'super::super::cosmos::auth::v1beta1::', 'crate::types::cosmos_auth_v1beta1::'),
                  # cosmos::authz::v1beta1 patterns
                  (r'super::super::cosmos::authz::v1beta1::', 'crate::types::cosmos_authz_v1beta1::'),
                  # base::query::v1beta1 patterns (standalone base references)
                  (r'super::super::base::query::v1beta1::', 'crate::types::cosmos_base_query_v1beta1::'),
                  (r'super::super::base::v1beta1::', 'crate::types::cosmos_base_v1beta1::'),
                  # Generic fallback for any super::super::module:: pattern
                  (r'super::super::([a-z_]+)::', r'crate::types::\1::'),
              ]
              
              # Process all .rs files in types directory
              files_processed = 0
              total_replacements = 0
              for rs_file in types_dir.rglob("*.rs"):
                  if rs_file.name == "mod.rs":
                      continue
                  
                  try:
                      content = rs_file.read_text()
                      original = content
                      
                      # Apply all pattern replacements (order matters - specific first)
                      for pattern_str, replacement in path_mappings:
                          pattern = re.compile(pattern_str)
                          matches = pattern.findall(content)
                          if matches:
                              content = pattern.sub(replacement, content)
                              total_replacements += len(matches) if isinstance(matches, list) else 1
                      
                      if content != original:
                          rs_file.write_text(content)
                          files_processed += 1
                  except Exception as e:
                      print(f"‚ö†Ô∏è Error processing {rs_file}: {e}")
              
              print(f"‚úÖ Post-processed {files_processed} files, fixed {total_replacements} path references")
          PYTHON

      - name: Cache Rust Dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: './rust'

      - name: Update Version
        working-directory: ./rust
        env:
          VERSION: ${{ needs.determine-version.outputs.version }}
        run: |
          sed -i "s/^version = .*/version = \"$VERSION\"/" Cargo.toml
          echo "‚úÖ Updated Cargo.toml with version $VERSION"

      - name: Build Crate
        working-directory: ./rust
        run: |
          cargo build --release
          echo "‚úÖ Crate built successfully"

      - name: Package Crate
        working-directory: ./rust
        run: |
          cargo package --allow-dirty
          echo "‚úÖ Crate packaged successfully"

      - name: Upload Package
        uses: actions/upload-artifact@v4
        with:
          name: rust-crate
          path: rust/target/package/*.crate
          retention-days: 30

  rust-test:
    name: Test Rust ${{ matrix.rust-version }}
    needs: [rust-build]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        rust-version: ['1.70', '1.75', 'stable']
      fail-fast: false
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Generated Rust Types
        uses: actions/download-artifact@v4
        with:
          name: generated-types-rust
          path: rust/types

      - name: Move Types to src/ Directory
        run: |
          mkdir -p rust/src
          mv rust/types rust/src/types
          echo "‚úÖ Moved types to rust/src/types"

      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: ${{ matrix.rust-version }}
          cache: false  # Disable auto-cache, we'll handle it manually

      - name: Create Rust Package Structure
        run: |
          mkdir -p rust
          if [ ! -f "rust/Cargo.toml" ]; then
            cat > rust/Cargo.toml << 'CARGO'
          [package]
          name = "xion-types"
          version = "0.1.0"
          edition = "2021"
          description = "Generated Rust types for Xion blockchain protocol buffers"
          license = "Apache-2.0"
          repository = "https://github.com/burnt-labs/xion-types"
          
          [lib]
          name = "xion_types"
          path = "src/lib.rs"
          
          [dependencies]
          prost = "0.12"
          prost-types = "0.12"
          CARGO
            echo "‚úÖ Created rust/Cargo.toml"
          else
            echo "‚úÖ rust/Cargo.toml already exists"
          fi
          
          # Create src/lib.rs if it doesn't exist
          mkdir -p rust/src
          if [ ! -f "rust/src/lib.rs" ]; then
            cat > rust/src/lib.rs << 'LIB'
          //! Generated Rust types for Xion blockchain protocol buffers
          
          pub mod types {
              include!(concat!(env!("CARGO_MANIFEST_DIR"), "/types/mod.rs"));
          }
          
          // Re-export modules at crate root for super::super paths
          // Generated code uses paths like super::super::cosmos::base::v1beta1::Coin
          // which expect these modules at crate root level
          // Only re-export if they exist in types module
          #[allow(unused_imports)]
          pub use types::*;
          LIB
          
          # Generate re-exports dynamically based on what's in types/mod.rs
          python3 << 'PYTHON'
          import re
          from pathlib import Path
          
          types_mod = Path("rust/types/mod.rs")
          if types_mod.exists():
              content = types_mod.read_text()
              # Find all "pub mod X;" declarations
              mod_declarations = re.findall(r'pub mod (\w+);', content)
              
              # Common modules that generated code references via super::super
              needed_modules = ['cosmos', 'base', 'amino', 'gogoproto', 'cosmos_proto', 
                              'xion', 'abstractaccount', 'ibc', 'tendermint', 
                              'osmosis', 'packetforward', 'cosmwasm']
              
              # Find which modules actually exist
              existing_modules = [m for m in needed_modules if m in mod_declarations]
              
              if existing_modules:
                  lib_rs = Path("rust/src/lib.rs")
                  lib_content = lib_rs.read_text()
                  
                  # Replace the generic pub use with specific re-exports
                  re_exports = '\n'.join([f'pub use types::{m};' for m in existing_modules])
                  lib_content = lib_content.replace(
                      '#[allow(unused_imports)]\npub use types::*;',
                      f'// Re-export modules at crate root for super::super paths\n{re_exports}'
                  )
                  
                  lib_rs.write_text(lib_content)
                  print(f"‚úÖ Added re-exports for: {', '.join(existing_modules)}")
              else:
                  print("‚ö†Ô∏è No matching modules found to re-export")
          PYTHON
            echo "‚úÖ Created rust/src/lib.rs"
          fi
          
          # Generate mod.rs recursively for all directories
          python3 << 'PYTHON'
          import os
          import re
          from pathlib import Path
          
          def has_any_rs_files(dir_path):
              """Check if directory or any subdirectory has .rs files"""
              for rs_file in dir_path.rglob("*.rs"):
                  if rs_file.name != "mod.rs":
                      return True
              return False
          
          def create_mod_rs(dir_path):
              """Recursively create mod.rs files for directories with .rs files or subdirs"""
              mod_rs_path = dir_path / "mod.rs"
              
              # Check for direct .rs files (excluding mod.rs)
              rs_files = [f for f in dir_path.glob("*.rs") if f.name != "mod.rs"]
              has_rs_files = len(rs_files) > 0
              
              # Process subdirectories recursively first
              subdirs_with_mod_rs = []
              for subdir in sorted(dir_path.iterdir()):
                  if subdir.is_dir():
                      if create_mod_rs(subdir):
                          subdirs_with_mod_rs.append(subdir)
              
              # Only create mod.rs if we have direct .rs files OR subdirs with mod.rs
              # But skip if this directory has no .rs files anywhere (even nested)
              if not has_any_rs_files(dir_path):
                  return False
              
              if has_rs_files or subdirs_with_mod_rs:
                  with mod_rs_path.open("w") as f:
                      f.write("// Auto-generated module\n")
                      
                      # Add direct .rs files
                      for rs_file in sorted(rs_files):
                          modname = rs_file.stem
                          filename = rs_file.name
                          
                          # Rust module names cannot contain dots, so use #[path] attribute
                          if '.' in modname:
                              # Convert dots to underscores for module name, but keep original filename
                              safe_modname = modname.replace('.', '_')
                              f.write(f'#[path = "{filename}"]\n')
                              f.write(f"pub mod {safe_modname};\n")
                          else:
                              f.write(f"pub mod {modname};\n")
                      
                      # Add subdirectories that have mod.rs
                      for subdir in subdirs_with_mod_rs:
                          f.write(f"pub mod {subdir.name};\n")
                  
                  return True
              
              return False
          
          types_dir = Path("rust/types")
          if types_dir.exists():
              # Process all subdirectories recursively first
              subdirs_added = []
              for item in sorted(types_dir.iterdir()):
                  if item.is_dir():
                      # Only add if directory has any .rs files AND mod.rs was successfully created
                      if has_any_rs_files(item):
                          if create_mod_rs(item):
                              # Verify mod.rs was actually created
                              mod_rs_path = item / "mod.rs"
                              if mod_rs_path.exists():
                                  subdirs_added.append(item)
                                  print(f"   Added module: {item.name}")
                              else:
                                  print(f"   Skipped {item.name}: mod.rs not created")
                          else:
                              print(f"   Skipped {item.name}: create_mod_rs returned False")
                      else:
                          print(f"   Skipped {item.name}: no .rs files found")
              
              # Create mod.rs for root types directory (after processing subdirs)
              root_mod = types_dir / "mod.rs"
              with root_mod.open("w") as f:
                  f.write("// Auto-generated module - includes all generated protobuf types\n")
                  
                  # Add subdirectories that have mod.rs
                  for item in subdirs_added:
                      f.write(f"pub mod {item.name};\n")
                  
                  # Include direct .rs files
                  for rs_file in sorted(types_dir.glob("*.rs")):
                      if rs_file.name != "mod.rs":
                          modname = rs_file.stem
                          filename = rs_file.name
                          
                          # Rust module names cannot contain dots, so use #[path] attribute
                          if '.' in modname:
                              safe_modname = modname.replace('.', '_')
                              f.write(f'#[path = "{filename}"]\n')
                              f.write(f"pub mod {safe_modname};\n")
                          else:
                              f.write(f"pub mod {modname};\n")
              
              print("‚úÖ Generated rust/types/mod.rs recursively")
              print(f"   Added {len(subdirs_added)} subdirectories to root mod.rs")
              
              # Debug: Show what's in types/mod.rs
              types_mod = Path("rust/types/mod.rs")
              if types_mod.exists():
                  content = types_mod.read_text()
                  print(f"üìÑ types/mod.rs content (first 50 lines):")
                  print('\n'.join(content.split('\n')[:50]))
                  
                  # Find all "pub mod X;" declarations (handle #[path] attributes)
                  mod_declarations = set()
                  for line in content.split('\n'):
                      # Match "pub mod X;" ignoring #[path] lines
                      match = re.search(r'pub mod (\w+);', line)
                      if match:
                          mod_declarations.add(match.group(1))
                  
                  print(f"üì¶ Found {len(mod_declarations)} module declarations: {sorted(mod_declarations)[:20]}")
                  
                  # Check file structure - are files flat or in directories?
                  flat_files = list(Path("rust/types").glob("*.rs"))
                  dirs = [d for d in Path("rust/types").iterdir() if d.is_dir()]
                  print(f"üìÅ Structure: {len(flat_files)} flat .rs files, {len(dirs)} directories")
                  if dirs:
                      print(f"   Directories: {[d.name for d in dirs[:10]]}")
                  
                  # Common modules that generated code references via super::super
                  needed_modules = ['cosmos', 'base', 'amino', 'gogoproto', 'cosmos_proto', 
                                  'xion', 'abstractaccount', 'ibc', 'tendermint', 
                                  'osmosis', 'packetforward', 'cosmwasm']
                  
                  # Find which modules actually exist
                  existing_modules = [m for m in needed_modules if m in mod_declarations]
                  
                  if existing_modules:
                      lib_rs = Path("rust/src/lib.rs")
                      lib_content = lib_rs.read_text()
                      
                      # Add re-exports at the end
                      re_exports = '\n'.join([f'pub use types::{m};' for m in existing_modules])
                      lib_content = lib_content.rstrip() + '\n\n// Re-export modules at crate root for super::super paths\n' + re_exports + '\n'
                      
                      lib_rs.write_text(lib_content)
                      print(f"‚úÖ Added re-exports for: {', '.join(existing_modules)}")
                  else:
                      print("‚ö†Ô∏è No matching modules found to re-export")
                      print(f"   Needed: {needed_modules}")
                      print(f"   Available: {sorted(mod_declarations)[:30]}")
                      
                      # If modules don't exist, files might be flat - need to fix paths in generated code
                      print("üîß Files appear to be flat - will fix super::super paths in generated code")
              
              # Post-process generated files to fix super::super paths
              print("üîß Post-processing generated files to fix module paths...")
              
              # Build a map of actual module names from files
              # Files like "cosmos.base.v1beta1.rs" become module "cosmos_base_v1beta1"
              actual_modules = {}
              types_dir = Path("rust/types")
              for rs_file in types_dir.rglob("*.rs"):
                  if rs_file.name == "mod.rs":
                      continue
                  # Get module name - if file is cosmos.base.v1beta1.rs, module is cosmos_base_v1beta1
                  module_name = rs_file.stem.replace('.', '_')
                  actual_modules[module_name] = rs_file
              
              # Since files are flat, we need to map hierarchical paths to flat module names
              # Pattern: super::super::cosmos::base::v1beta1::Type
              # Should become: crate::types::cosmos_base_v1beta1::Type
              
              # Common hierarchical patterns to map to flat modules
              path_mappings = [
                  # cosmos::base::v1beta1 patterns
                  (r'super::super::cosmos::base::v1beta1::', 'crate::types::cosmos_base_v1beta1::'),
                  (r'super::super::cosmos::base::query::v1beta1::', 'crate::types::cosmos_base_query_v1beta1::'),
                  (r'super::super::cosmos::base::abci::v1beta1::', 'crate::types::cosmos_base_abci_v1beta1::'),
                  (r'super::super::cosmos::base::tendermint::v1beta1::', 'crate::types::cosmos_base_tendermint_v1beta1::'),
                  (r'super::super::cosmos::base::reflection::v1beta1::', 'crate::types::cosmos_base_reflection_v1beta1::'),
                  (r'super::super::cosmos::base::reflection::v2alpha1::', 'crate::types::cosmos_base_reflection_v2alpha1::'),
                  (r'super::super::cosmos::base::node::v1beta1::', 'crate::types::cosmos_base_node_v1beta1::'),
                  # cosmos::bank::v1beta1 patterns
                  (r'super::super::cosmos::bank::v1beta1::', 'crate::types::cosmos_bank_v1beta1::'),
                  # cosmos::auth::v1beta1 patterns
                  (r'super::super::cosmos::auth::v1beta1::', 'crate::types::cosmos_auth_v1beta1::'),
                  # cosmos::authz::v1beta1 patterns
                  (r'super::super::cosmos::authz::v1beta1::', 'crate::types::cosmos_authz_v1beta1::'),
                  # base::query::v1beta1 patterns (standalone base references)
                  (r'super::super::base::query::v1beta1::', 'crate::types::cosmos_base_query_v1beta1::'),
                  (r'super::super::base::v1beta1::', 'crate::types::cosmos_base_v1beta1::'),
                  # Generic fallback for any super::super::module:: pattern
                  (r'super::super::([a-z_]+)::', r'crate::types::\1::'),
              ]
              
              # Process all .rs files in types directory
              files_processed = 0
              total_replacements = 0
              for rs_file in types_dir.rglob("*.rs"):
                  if rs_file.name == "mod.rs":
                      continue
                  
                  try:
                      content = rs_file.read_text()
                      original = content
                      
                      # Apply all pattern replacements (order matters - specific first)
                      for pattern_str, replacement in path_mappings:
                          pattern = re.compile(pattern_str)
                          matches = pattern.findall(content)
                          if matches:
                              content = pattern.sub(replacement, content)
                              total_replacements += len(matches) if isinstance(matches, list) else 1
                      
                      if content != original:
                          rs_file.write_text(content)
                          files_processed += 1
                  except Exception as e:
                      print(f"‚ö†Ô∏è Error processing {rs_file}: {e}")
              
              print(f"‚úÖ Post-processed {files_processed} files, fixed {total_replacements} path references")
          PYTHON

      - name: Cache Rust Dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: './rust'

      - name: Update Version
        working-directory: ./rust
        env:
          VERSION: ${{ needs.rust-build.outputs.version }}
        run: |
          sed -i "s/^version = .*/version = \"$VERSION\"/" Cargo.toml

      - name: Run Tests
        working-directory: ./rust
        run: |
          cargo test --verbose
          echo "‚úÖ Tests passed for Rust ${{ matrix.rust-version }}"

      - name: Check Build
        working-directory: ./rust
        run: |
          cargo check --verbose
          echo "‚úÖ Build check passed for Rust ${{ matrix.rust-version }}"

  # Placeholder for publishing to crates.io
  # rust-publish:
  #   name: Publish to crates.io
  #   needs: [rust-test]
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Publish Crate
  #       working-directory: ./rust
  #       env:
  #         CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
  #       run: |
  #         cargo publish --allow-dirty

