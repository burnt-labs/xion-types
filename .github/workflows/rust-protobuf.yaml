name: Rust Protobuf Generation & Publishing

on:
  push:
    branches: 
    #   - main 
      - feat/protobufs
            
  workflow_dispatch:
    inputs:
      next_version:
        description: 'Specific version to set (e.g., 1.2.3). Required for publishing.'
        required: true
        type: string

  repository_dispatch:
    types: [xion-types-release-trigger]
    
  schedule:
    - cron: '0 2 * * *' # Run nightly at 2 AM UTC

jobs:
  generate-protobuf:
    name: Generate Rust Types
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          submodules: false
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate Rust Definitions
        run: |
          make proto-gen-rust

      - name: Check if Types Were Generated
        run: |
          if [ -d "./rust/types" ] && [ "$(ls -A ./rust/types)" ]; then
            echo "✅ Rust definitions generated successfully"
          else
            echo "❌ Failed to generate Rust definitions"
            exit 1
          fi

      - name: Upload Generated Types
        uses: actions/upload-artifact@v4
        with:
          name: generated-types-rust
          path: rust/types
          retention-days: 30

  determine-version:
    name: Determine Version
    needs: [generate-protobuf]
    runs-on: ubuntu-latest
    if: |
        github.ref == 'refs/heads/feat/protobufs' ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.next_version != '') || 
        (github.event_name == 'repository_dispatch' && github.event.client_payload.release_type == 'published')
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine Version
        # Version scenarios:
        # 1. Manual trigger (workflow_dispatch) → Use input version (e.g., "1.2.3")
        # 2. Release event (repository_dispatch) → Use release tag (e.g., "v1.2.3" → "1.2.3")
        # 3. Push to branch → Generate dev version (e.g., "0.0.0-dev.abc1234")
        id: version
        run: |
          if [ "${{ github.event.inputs.next_version }}" != "" ]; then
            VERSION="${{ github.event.inputs.next_version }}"
            echo "Using manual version: $VERSION"
          elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            RELEASE_TAG="${{ github.event.client_payload.tag_name }}"
            VERSION=${RELEASE_TAG#v}
            echo "Using release version: $VERSION (from tag: $RELEASE_TAG)"
          elif [ "${{ github.event_name }}" == "push" ]; then
            GIT_SHA=$(git rev-parse --short HEAD)
            VERSION="0.0.0-dev.${GIT_SHA}"
            echo "Using dev version for testing: $VERSION"
          else
            echo "❌ No version specified"
            exit 1
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT

  # ============================================
  # Rust Crate Publishing
  # ============================================

  rust-build:
    name: Build Rust Crate
    needs: [determine-version, generate-protobuf]
    runs-on: ubuntu-latest
    outputs:
      version: ${{ needs.determine-version.outputs.version }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Generated Rust Types
        uses: actions/download-artifact@v4
        with:
          name: generated-types-rust
          path: rust/types

      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable
          cache: false  # Disable auto-cache, we'll handle it manually

      - name: Create Rust Package Structure
        run: |
          mkdir -p rust/src
          # Create lib.rs that includes generated types
          # Using include!() because generated code uses super::super paths
          # that expect types/ to be at crate root level relative to CARGO_MANIFEST_DIR
          cat > rust/src/lib.rs << 'LIB'
          //! Generated Rust types for Xion blockchain protocol buffers
          
          // Include generated protobuf modules
          // Note: types/ is kept outside src/ because generated code uses
          // super::super::cosmos::... paths that expect this structure
          pub mod types {
              include!(concat!(env!("CARGO_MANIFEST_DIR"), "/types/mod.rs"));
          }
          LIB
          
          # Create Cargo.toml
          if [ ! -f "rust/Cargo.toml" ]; then
            cat > rust/Cargo.toml << 'CARGO'
          [package]
          name = "xion-types"
          version = "0.1.0"
          edition = "2021"
          description = "Generated Rust types for Xion blockchain protocol buffers"
          license = "Apache-2.0"
          repository = "https://github.com/burnt-labs/xion-types"
          
          [lib]
          name = "xion_types"
          path = "src/lib.rs"
          
          [dependencies]
          prost = "0.12"
          prost-types = "0.12"
          CARGO
            echo "✅ Created rust/Cargo.toml"
          else
            echo "✅ rust/Cargo.toml already exists"
          fi
          
          # Generate mod.rs recursively for all directories
          python3 << 'PYTHON'
          import os
          from pathlib import Path
          
          def has_any_rs_files(dir_path):
              """Check if directory or any subdirectory has .rs files"""
              for rs_file in dir_path.rglob("*.rs"):
                  if rs_file.name != "mod.rs":
                      return True
              return False
          
          def create_mod_rs(dir_path):
              """Recursively create mod.rs files for directories with .rs files or subdirs"""
              mod_rs_path = dir_path / "mod.rs"
              
              # Check for direct .rs files (excluding mod.rs)
              rs_files = [f for f in dir_path.glob("*.rs") if f.name != "mod.rs"]
              has_rs_files = len(rs_files) > 0
              
              # Process subdirectories recursively first
              subdirs_with_mod_rs = []
              for subdir in sorted(dir_path.iterdir()):
                  if subdir.is_dir():
                      if create_mod_rs(subdir):
                          subdirs_with_mod_rs.append(subdir)
              
              # Only create mod.rs if we have direct .rs files OR subdirs with mod.rs
              # But skip if this directory has no .rs files anywhere (even nested)
              if not has_any_rs_files(dir_path):
                  return False
              
              if has_rs_files or subdirs_with_mod_rs:
                  with mod_rs_path.open("w") as f:
                      f.write("// Auto-generated module\n")
                      
                      # Add direct .rs files
                      for rs_file in sorted(rs_files):
                          modname = rs_file.stem
                          filename = rs_file.name
                          
                          # Rust module names cannot contain dots, so use #[path] attribute
                          if '.' in modname:
                              # Convert dots to underscores for module name, but keep original filename
                              safe_modname = modname.replace('.', '_')
                              f.write(f'#[path = "{filename}"]\n')
                              f.write(f"pub mod {safe_modname};\n")
                          else:
                              f.write(f"pub mod {modname};\n")
                      
                      # Add subdirectories that have mod.rs
                      for subdir in subdirs_with_mod_rs:
                          f.write(f"pub mod {subdir.name};\n")
                  
                  return True
              
              return False
          
          types_dir = Path("rust/types")
          if types_dir.exists():
              # Process all subdirectories recursively first
              subdirs_added = []
              for item in sorted(types_dir.iterdir()):
                  if item.is_dir():
                      # Only add if directory has any .rs files AND mod.rs was successfully created
                      if has_any_rs_files(item):
                          if create_mod_rs(item):
                              # Verify mod.rs was actually created
                              mod_rs_path = item / "mod.rs"
                              if mod_rs_path.exists():
                                  subdirs_added.append(item)
                                  print(f"   Added module: {item.name}")
                              else:
                                  print(f"   Skipped {item.name}: mod.rs not created")
                          else:
                              print(f"   Skipped {item.name}: create_mod_rs returned False")
                      else:
                          print(f"   Skipped {item.name}: no .rs files found")
              
              # Create mod.rs for root types directory (after processing subdirs)
              root_mod = types_dir / "mod.rs"
              with root_mod.open("w") as f:
                  f.write("// Auto-generated module - includes all generated protobuf types\n")
                  
                  # Add subdirectories that have mod.rs
                  for item in subdirs_added:
                      f.write(f"pub mod {item.name};\n")
                  
                  # Include direct .rs files
                  for rs_file in sorted(types_dir.glob("*.rs")):
                      if rs_file.name != "mod.rs":
                          modname = rs_file.stem
                          filename = rs_file.name
                          
                          # Rust module names cannot contain dots, so use #[path] attribute
                          if '.' in modname:
                              safe_modname = modname.replace('.', '_')
                              f.write(f'#[path = "{filename}"]\n')
                              f.write(f"pub mod {safe_modname};\n")
                          else:
                              f.write(f"pub mod {modname};\n")
              
              print("✅ Generated rust/types/mod.rs recursively")
              print(f"   Added {len(subdirs_added)} subdirectories to root mod.rs")
          PYTHON

      - name: Cache Rust Dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: './rust'

      - name: Update Version
        working-directory: ./rust
        env:
          VERSION: ${{ needs.determine-version.outputs.version }}
        run: |
          sed -i "s/^version = .*/version = \"$VERSION\"/" Cargo.toml
          echo "✅ Updated Cargo.toml with version $VERSION"

      - name: Build Crate
        working-directory: ./rust
        run: |
          cargo build --release
          echo "✅ Crate built successfully"

      - name: Package Crate
        working-directory: ./rust
        run: |
          cargo package --allow-dirty
          echo "✅ Crate packaged successfully"

      - name: Upload Package
        uses: actions/upload-artifact@v4
        with:
          name: rust-crate
          path: rust/target/package/*.crate
          retention-days: 30

  rust-test:
    name: Test Rust ${{ matrix.rust-version }}
    needs: [rust-build]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        rust-version: ['1.70', '1.75', 'stable']
      fail-fast: false
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Generated Rust Types
        uses: actions/download-artifact@v4
        with:
          name: generated-types-rust
          path: rust/types

      - name: Move Types to src/ Directory
        run: |
          mkdir -p rust/src
          mv rust/types rust/src/types
          echo "✅ Moved types to rust/src/types"

      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: ${{ matrix.rust-version }}
          cache: false  # Disable auto-cache, we'll handle it manually

      - name: Create Rust Package Structure
        run: |
          mkdir -p rust
          if [ ! -f "rust/Cargo.toml" ]; then
            cat > rust/Cargo.toml << 'CARGO'
          [package]
          name = "xion-types"
          version = "0.1.0"
          edition = "2021"
          description = "Generated Rust types for Xion blockchain protocol buffers"
          license = "Apache-2.0"
          repository = "https://github.com/burnt-labs/xion-types"
          
          [lib]
          name = "xion_types"
          path = "src/lib.rs"
          
          [dependencies]
          prost = "0.12"
          prost-types = "0.12"
          CARGO
            echo "✅ Created rust/Cargo.toml"
          else
            echo "✅ rust/Cargo.toml already exists"
          fi
          
          # Create src/lib.rs if it doesn't exist
          mkdir -p rust/src
          if [ ! -f "rust/src/lib.rs" ]; then
            cat > rust/src/lib.rs << 'LIB'
          //! Generated Rust types for Xion blockchain protocol buffers
          
          pub mod types {
              include!(concat!(env!("CARGO_MANIFEST_DIR"), "/types/mod.rs"));
          }
          LIB
            echo "✅ Created rust/src/lib.rs"
          fi
          
          # Generate mod.rs recursively for all directories
          python3 << 'PYTHON'
          import os
          from pathlib import Path
          
          def has_any_rs_files(dir_path):
              """Check if directory or any subdirectory has .rs files"""
              for rs_file in dir_path.rglob("*.rs"):
                  if rs_file.name != "mod.rs":
                      return True
              return False
          
          def create_mod_rs(dir_path):
              """Recursively create mod.rs files for directories with .rs files or subdirs"""
              mod_rs_path = dir_path / "mod.rs"
              
              # Check for direct .rs files (excluding mod.rs)
              rs_files = [f for f in dir_path.glob("*.rs") if f.name != "mod.rs"]
              has_rs_files = len(rs_files) > 0
              
              # Process subdirectories recursively first
              subdirs_with_mod_rs = []
              for subdir in sorted(dir_path.iterdir()):
                  if subdir.is_dir():
                      if create_mod_rs(subdir):
                          subdirs_with_mod_rs.append(subdir)
              
              # Only create mod.rs if we have direct .rs files OR subdirs with mod.rs
              # But skip if this directory has no .rs files anywhere (even nested)
              if not has_any_rs_files(dir_path):
                  return False
              
              if has_rs_files or subdirs_with_mod_rs:
                  with mod_rs_path.open("w") as f:
                      f.write("// Auto-generated module\n")
                      
                      # Add direct .rs files
                      for rs_file in sorted(rs_files):
                          modname = rs_file.stem
                          filename = rs_file.name
                          
                          # Rust module names cannot contain dots, so use #[path] attribute
                          if '.' in modname:
                              # Convert dots to underscores for module name, but keep original filename
                              safe_modname = modname.replace('.', '_')
                              f.write(f'#[path = "{filename}"]\n')
                              f.write(f"pub mod {safe_modname};\n")
                          else:
                              f.write(f"pub mod {modname};\n")
                      
                      # Add subdirectories that have mod.rs
                      for subdir in subdirs_with_mod_rs:
                          f.write(f"pub mod {subdir.name};\n")
                  
                  return True
              
              return False
          
          types_dir = Path("rust/types")
          if types_dir.exists():
              # Process all subdirectories recursively first
              subdirs_added = []
              for item in sorted(types_dir.iterdir()):
                  if item.is_dir():
                      # Only add if directory has any .rs files AND mod.rs was successfully created
                      if has_any_rs_files(item):
                          if create_mod_rs(item):
                              # Verify mod.rs was actually created
                              mod_rs_path = item / "mod.rs"
                              if mod_rs_path.exists():
                                  subdirs_added.append(item)
                                  print(f"   Added module: {item.name}")
                              else:
                                  print(f"   Skipped {item.name}: mod.rs not created")
                          else:
                              print(f"   Skipped {item.name}: create_mod_rs returned False")
                      else:
                          print(f"   Skipped {item.name}: no .rs files found")
              
              # Create mod.rs for root types directory (after processing subdirs)
              root_mod = types_dir / "mod.rs"
              with root_mod.open("w") as f:
                  f.write("// Auto-generated module - includes all generated protobuf types\n")
                  
                  # Add subdirectories that have mod.rs
                  for item in subdirs_added:
                      f.write(f"pub mod {item.name};\n")
                  
                  # Include direct .rs files
                  for rs_file in sorted(types_dir.glob("*.rs")):
                      if rs_file.name != "mod.rs":
                          modname = rs_file.stem
                          filename = rs_file.name
                          
                          # Rust module names cannot contain dots, so use #[path] attribute
                          if '.' in modname:
                              safe_modname = modname.replace('.', '_')
                              f.write(f'#[path = "{filename}"]\n')
                              f.write(f"pub mod {safe_modname};\n")
                          else:
                              f.write(f"pub mod {modname};\n")
              
              print("✅ Generated rust/types/mod.rs recursively")
              print(f"   Added {len(subdirs_added)} subdirectories to root mod.rs")
          PYTHON

      - name: Cache Rust Dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: './rust'

      - name: Update Version
        working-directory: ./rust
        env:
          VERSION: ${{ needs.rust-build.outputs.version }}
        run: |
          sed -i "s/^version = .*/version = \"$VERSION\"/" Cargo.toml

      - name: Run Tests
        working-directory: ./rust
        run: |
          cargo test --verbose
          echo "✅ Tests passed for Rust ${{ matrix.rust-version }}"

      - name: Check Build
        working-directory: ./rust
        run: |
          cargo check --verbose
          echo "✅ Build check passed for Rust ${{ matrix.rust-version }}"

  # Placeholder for publishing to crates.io
  # rust-publish:
  #   name: Publish to crates.io
  #   needs: [rust-test]
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Publish Crate
  #       working-directory: ./rust
  #       env:
  #         CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
  #       run: |
  #         cargo publish --allow-dirty

