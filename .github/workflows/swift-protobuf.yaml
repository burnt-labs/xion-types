name: Swift Protobuf Gen & Publish

on:
  # push:
  #   branches: 
  #     - main 
            
  workflow_dispatch:
    inputs:
      next_version:
        description: 'Specific version to set (e.g., 1.2.3). Required for publishing.'
        required: true
        type: string

  repository_dispatch:
    types: [xion-types-release-trigger]
    
  schedule:
    - cron: '0 9 * * 5' # Run Fridays at 9 AM UTC

jobs:
  generate-protobuf:
    name: Generate Swift Types
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          submodules: false
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate Swift Definitions
        run: |
          make proto-gen-swift
      - name: Check if Types Were Generated
        run: |
          if [ -d "./swift/types" ] && [ "$(ls -A ./swift/types)" ]; then
            echo "‚úÖ Swift definitions generated successfully"
          else
            echo "‚ùå Failed to generate Swift definitions"
            exit 1
          fi
      - name: Upload Generated Types
        uses: actions/upload-artifact@v4
        with:
          name: generated-types-swift
          path: swift/types
          retention-days: 30

  determine-version:
    name: Determine Version
    needs: [generate-protobuf]
    runs-on: ubuntu-latest
    if: |
        github.event_name == 'schedule' ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.next_version != '') || 
        (github.event_name == 'repository_dispatch' && (github.event.client_payload.release_type == 'published' || github.event.client_payload.release_type == 'prerelease'))
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine Version
        # Version scenarios:
        # 1. Manual trigger (workflow_dispatch) ‚Üí Use input version (e.g., "1.2.3")
        # 2. Release event (repository_dispatch) ‚Üí Use release tag (e.g., "v1.2.3" ‚Üí "1.2.3")
        # 3. Push to branch ‚Üí Generate dev version (e.g., "0.0.0.dev1234567890")
        id: version
        run: |
          if [ "${{ github.event.inputs.next_version }}" != "" ]; then
            VERSION="${{ github.event.inputs.next_version }}"
            echo "Using manual version: $VERSION"
          elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            RELEASE_TAG="${{ github.event.client_payload.tag_name }}"
            VERSION=${RELEASE_TAG#v}
            # Safety check: If it's a prerelease but the version string doesn't have a hyphen (no suffix), append -rc.0
            if [ "${{ github.event.client_payload.release_type }}" == "prerelease" ] && [[ "$VERSION" != *-* ]]; then
              echo "‚ö†Ô∏è Prerelease detected without suffix in version $VERSION. Appending -rc.0 for safety."
              VERSION="${VERSION}-rc.0"
            fi
            echo "Using release version: $VERSION (from tag: $RELEASE_TAG)"
          elif [ "${{ github.event_name }}" == "schedule" ]; then
            TIMESTAMP=$(date -u +%Y%m%d%H%M)
            VERSION="0.0.0-nightly.${TIMESTAMP}"
            echo "Using nightly version: $VERSION"
          elif [ "${{ github.event_name }}" == "push" ]; then
            TIMESTAMP=$(date +%s)
            VERSION="0.0.0.dev${TIMESTAMP}"
            echo "Using dev version for testing: $VERSION"
          else
            echo "‚ùå No version specified"
            exit 1
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
  # ============================================
  # Swift Package Building/Testing
  # ============================================

  swift-build:
    name: Build Swift Package
    needs: [determine-version, generate-protobuf]
    runs-on: macos-latest
    outputs:
      version: ${{ needs.determine-version.outputs.version }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Generated Swift Types
        uses: actions/download-artifact@v4
        with:
          name: generated-types-swift
          path: swift/types

      - name: Create Swift Package Structure
        run: |
          mkdir -p swift/Sources/XionTypes
          mkdir -p swift/Tests/XionTypesTests
          
          # Always recreate Package.swift from scratch to avoid stale state
            cat > swift/Package.swift << 'PACKAGE'
          // swift-tools-version:5.9
          import PackageDescription
          let package = Package(
              name: "XionTypes",
              platforms: [
                  .iOS(.v13),
                  .macOS(.v10_15),
                  .watchOS(.v6),
                  .tvOS(.v13)
              ],
              products: [
                  .library(
                      name: "XionTypes",
                      targets: ["XionTypes"]
                  ),
              ],
              dependencies: [
                  .package(url: "https://github.com/apple/swift-protobuf.git", from: "1.28.0"),
              ],
              targets: [
                  .target(
                      name: "XionTypes",
                      dependencies: [
                          .product(name: "SwiftProtobuf", package: "swift-protobuf")
                      ],
                      path: "Sources/XionTypes"
                  ),
                  .testTarget(
                      name: "XionTypesTests",
                      dependencies: ["XionTypes"],
                      path: "Tests/XionTypesTests"
                  ),
              ]
          )
          PACKAGE
            echo "‚úÖ Created swift/Package.swift"
          
          # Create minimal test file if it doesn't exist
          if [ ! -f "swift/Tests/XionTypesTests/XionTypesTests.swift" ]; then
            cat > swift/Tests/XionTypesTests/XionTypesTests.swift << 'TEST'
          import XCTest
          @testable import XionTypes
          final class XionTypesTests: XCTestCase {
              func testExample() {
                  // This is a placeholder test to ensure the package builds correctly
                  XCTAssertTrue(true)
              }
          }
          TEST
            echo "‚úÖ Created swift/Tests/XionTypesTests/XionTypesTests.swift"
          fi
          
          # Split large source set into multiple targets to avoid "multiple producers" error
          # This is a workaround for Swift Package Manager bug with 200+ source files
          echo "Organizing Swift files into multiple targets..."
          
          # Create a Python script file to generate Package.swift with multiple targets
          # Split into smaller targets (max 30 files each) to avoid SPM race condition
          cat > /tmp/generate_package.py << 'PYEOF'
          import os
          import shutil
          import re
          from pathlib import Path
          from collections import defaultdict
          
          types_dir = Path("swift/types")
          sources_base = Path("swift/Sources")
          # Use very small targets (10 files max) to avoid SPM race condition
          # Exception: cosmos files (includes tendermint, abstractaccount, xion, osmosis, cosmwasm, ibc) must stay together
          MAX_FILES_PER_TARGET = 10
          MAX_FILES_PER_TARGET_COSMOS = 1000  # Keep all cosmos-related files together (very large target)
          
          if not types_dir.exists():
              print("‚ùå swift/types directory not found")
              exit(1)
          
          # Group files by top-level directory first, then split large directories
          # This keeps related files together to preserve import relationships
          
          # Group files by top-level directory
          # Special case: merge all blockchain-related modules into cosmos
          # They heavily depend on each other and protobuf types are internal by default
          files_by_topdir = defaultdict(list)
          for swift_file in types_dir.rglob("*.swift"):
              # Get top-level directory (first component of relative path)
              rel_path = swift_file.relative_to(types_dir)
              top_dir = rel_path.parts[0] if rel_path.parts else "root"
              # Merge into cosmos since they're tightly coupled and share types
              if top_dir in ["tendermint", "abstractaccount", "xion", "osmosis", "cosmwasm", "ibc"]:
                  top_dir = "cosmos"
              files_by_topdir[top_dir].append(swift_file)
          
          print(f"Found {sum(len(files) for files in files_by_topdir.values())} total Swift files in {len(files_by_topdir)} top-level directories")
          if "cosmos" in files_by_topdir:
              cosmos_count = len(files_by_topdir["cosmos"])
              print(f"Cosmos target will contain {cosmos_count} files (includes cosmos, tendermint, abstractaccount, xion, osmosis, cosmwasm, ibc)")
          
          # Create targets: one per top-level directory, split if too large
          targets = []
          target_index = 0
          
          for top_dir, files in sorted(files_by_topdir.items()):
              files.sort()
              
              # Use larger limit for cosmos to keep all files together (includes tendermint files)
              if top_dir == "cosmos":
                  max_files = MAX_FILES_PER_TARGET_COSMOS
              else:
                  max_files = MAX_FILES_PER_TARGET
              
              # If directory has many files, split it into multiple targets
              if len(files) <= max_files:
                  # Single target for this directory
                  target_name = f"XionTypes{top_dir.capitalize().replace('_', '')}"
                  target_path = sources_base / target_name
                  target_path.mkdir(parents=True, exist_ok=True)
                  
                  # Copy files with unique names to avoid Swift filename conflicts
                  # Swift requires unique filenames even across subdirectories
                  seen_filenames = {}
                  for src_file in files:
                      rel_path = src_file.relative_to(types_dir)
                      # Create unique filename by replacing path separators with underscores
                      unique_name = str(rel_path).replace('/', '_').replace('\\', '_')
                      # If filename already seen in this target, add a counter
                      if unique_name in seen_filenames:
                          seen_filenames[unique_name] += 1
                          base_name = unique_name.rsplit('.', 1)
                          if len(base_name) == 2:
                              unique_name = f"{base_name[0]}_{seen_filenames[unique_name]}.{base_name[1]}"
                          else:
                              unique_name = f"{unique_name}_{seen_filenames[unique_name]}"
                      else:
                          seen_filenames[unique_name] = 0
                      
                      dest_file = target_path / unique_name
                      shutil.copy2(src_file, dest_file)
                  
                  targets.append({
                      "name": target_name,
                      "path": f"Sources/{target_name}",
                      "file_count": len(files),
                      "top_dir": top_dir
                  })
                  print(f"Created target {target_name} with {len(files)} Swift files from {top_dir}/")
              else:
                  # Split large directory into multiple targets
                  num_splits = (len(files) + max_files - 1) // max_files
                  for split_idx in range(num_splits):
                      start_idx = split_idx * max_files
                      end_idx = min(start_idx + max_files, len(files))
                      split_files = files[start_idx:end_idx]
                      
                      target_name = f"XionTypes{top_dir.capitalize().replace('_', '')}Part{split_idx:02d}"
                      target_path = sources_base / target_name
                      target_path.mkdir(parents=True, exist_ok=True)
                      
                      # Copy files with unique names to avoid Swift filename conflicts
                      # Swift requires unique filenames even across subdirectories
                      seen_filenames = {}
                      for src_file in split_files:
                          rel_path = src_file.relative_to(types_dir)
                          # Create unique filename by replacing path separators with underscores
                          unique_name = str(rel_path).replace('/', '_').replace('\\', '_')
                          # If filename already seen in this target, add a counter
                          if unique_name in seen_filenames:
                              seen_filenames[unique_name] += 1
                              base_name = unique_name.rsplit('.', 1)
                              if len(base_name) == 2:
                                  unique_name = f"{base_name[0]}_{seen_filenames[unique_name]}.{base_name[1]}"
                              else:
                                  unique_name = f"{unique_name}_{seen_filenames[unique_name]}"
                          else:
                              seen_filenames[unique_name] = 0
                          
                          dest_file = target_path / unique_name
                          shutil.copy2(src_file, dest_file)
                      
                      targets.append({
                          "name": target_name,
                          "path": f"Sources/{target_name}",
                          "file_count": len(split_files),
                          "top_dir": top_dir
                      })
                      print(f"Created target {target_name} with {len(split_files)} Swift files from {top_dir}/ (split {split_idx + 1}/{num_splits})")
          
          # Group targets by top_dir for dependency management
          targets_by_topdir = defaultdict(list)
          for target in targets:
              top_dir = target.get("top_dir", "unknown")
              targets_by_topdir[top_dir].append(target["name"])
          
          # Generate Package.swift content
          lines = []
          lines.append("// swift-tools-version:5.9")
          lines.append("import PackageDescription")
          lines.append("")
          lines.append("let package = Package(")
          lines.append('    name: "XionTypes",')
          lines.append("    platforms: [")
          lines.append("        .iOS(.v13),")
          lines.append("        .macOS(.v10_15),")
          lines.append("        .watchOS(.v6),")
          lines.append("        .tvOS(.v13)")
          lines.append("    ],")
          lines.append("    products: [")
          lines.append('        .library(')
          lines.append('            name: "XionTypes",')
          lines.append('            targets: ["XionTypes"])')
          lines.append("    ],")
          lines.append("    dependencies: [")
          lines.append('        .package(url: "https://github.com/apple/swift-protobuf.git", from: "1.28.0")')
          lines.append("    ],")
          lines.append("    targets: [")
          
          # Add all sub-targets with proper dependency ordering (avoiding cycles)
          all_target_names = [t["name"] for t in targets]
          
          # Identify base targets that others commonly need
          # Order matters: google and gogoproto are most basic, then cosmos_proto, then cosmos
          # Note: cosmos includes tendermint, abstractaccount, xion, osmosis, cosmwasm, and ibc (merged for type accessibility)
          google_targets = [t["name"] for t in targets if t.get("top_dir", "").lower() == "google"]
          gogoproto_targets = [t["name"] for t in targets if t.get("top_dir", "").lower() == "gogoproto"]
          cosmos_proto_targets = [t["name"] for t in targets if t.get("top_dir", "").lower() == "cosmos_proto"]
          cosmos_targets = [t["name"] for t in targets if t.get("top_dir", "").lower() == "cosmos"]
          
          # Debug: print target counts
          print(f"Found {len(google_targets)} google targets, {len(gogoproto_targets)} gogoproto targets, {len(cosmos_proto_targets)} cosmos_proto targets, {len(cosmos_targets)} cosmos targets")
          
          for target in targets:
              lines.append(f'        .target(')
              lines.append(f'            name: "{target["name"]}",')
              lines.append("            dependencies: [")
              
              target_top_dir = target.get("top_dir", "unknown")
              target_top_dir_lower = target_top_dir.lower()
              target_name = target["name"]
              
              # Collect all additional dependencies first to determine if we need a comma
              additional_deps = []
              
              # Add dependencies on previous parts from same directory (to avoid circular deps)
              if "Part" in target_name:
                  match = re.search(r'Part(\d+)', target_name)
                  if match:
                      part_num = int(match.group(1))
                      for other_target in targets:
                          if other_target.get("top_dir", "").lower() == target_top_dir_lower and other_target["name"] != target_name:
                              other_match = re.search(r'Part(\d+)', other_target["name"])
                              if other_match and int(other_match.group(1)) < part_num:
                                  additional_deps.append(f'                "{other_target["name"]}",')
              
              # Add base dependencies in order (avoid cycles):
              # 1. google and gogoproto are base (no dependencies on each other)
              # 2. cosmos_proto depends on google/gogoproto
              # 3. cosmos (includes tendermint, abstractaccount, xion, osmosis, cosmwasm, ibc) depends on cosmos_proto, google, gogoproto
              # 4. Everything else depends on cosmos, google, cosmos_proto, gogoproto
              
              if target_top_dir_lower == "cosmos_proto":
                  # cosmos_proto depends on google and gogoproto
                  for google_target in google_targets:
                      additional_deps.append(f'                "{google_target}",')
                  for gogoproto_target in gogoproto_targets:
                      additional_deps.append(f'                "{gogoproto_target}",')
              elif target_top_dir_lower == "cosmos":
                  # cosmos (includes tendermint) depends on cosmos_proto, google, gogoproto
                  for cosmos_proto_target in cosmos_proto_targets:
                      additional_deps.append(f'                "{cosmos_proto_target}",')
                  for google_target in google_targets:
                      additional_deps.append(f'                "{google_target}",')
                  for gogoproto_target in gogoproto_targets:
                      additional_deps.append(f'                "{gogoproto_target}",')
              elif target_top_dir_lower not in ["google", "gogoproto", "cosmos_proto", "cosmos"]:
                  # Everything else depends on cosmos, google, cosmos_proto, gogoproto
                  for cosmos_target in cosmos_targets:
                      additional_deps.append(f'                "{cosmos_target}",')
                  for cosmos_proto_target in cosmos_proto_targets:
                      additional_deps.append(f'                "{cosmos_proto_target}",')
                  for google_target in google_targets:
                      additional_deps.append(f'                "{google_target}",')
                  for gogoproto_target in gogoproto_targets:
                      additional_deps.append(f'                "{gogoproto_target}",')
              # google and gogoproto have no dependencies on other targets
              
              # Add SwiftProtobuf dependency with comma if there are additional deps
              if additional_deps:
                  lines.append('                .product(name: "SwiftProtobuf", package: "swift-protobuf"),')
              else:
                  lines.append('                .product(name: "SwiftProtobuf", package: "swift-protobuf")')
              
              # Add all additional dependencies
              lines.extend(additional_deps)
              
              lines.append("            ],")
              lines.append(f'            path: "{target["path"]}"),')
          
          # Add main XionTypes target that depends on all sub-targets
          # (all_target_names already defined above)
          lines.append('        .target(')
          lines.append('            name: "XionTypes",')
          lines.append("            dependencies: [")
          lines.append('                .product(name: "SwiftProtobuf", package: "swift-protobuf"),')
          for name in all_target_names:
              lines.append(f'                "{name}",')
          lines.append("            ],")
          lines.append('            path: "Sources/XionTypes"),')
          lines.append('        .testTarget(')
          lines.append('            name: "XionTypesTests",')
          lines.append('            dependencies: ["XionTypes"],')
          lines.append('            path: "Tests/XionTypesTests")')
          lines.append("    ]")
          lines.append(")")
          
          # Write Package.swift
          with open("swift/Package.swift", "w") as f:
              f.write("\n".join(lines))
          
          print(f"‚úÖ Generated Package.swift with {len(targets)} sub-targets")
          print(f"Total targets: {len(targets) + 1} (including main XionTypes target)")
          PYEOF
          
          # Execute the Python script
          python3 /tmp/generate_package.py
          
          # Create main XionTypes target directory (empty, just for re-exports if needed)
          mkdir -p swift/Sources/XionTypes
          # Create a simple re-export file if needed
          cat > swift/Sources/XionTypes/XionTypes.swift << 'REEXPORT'
          // Main XionTypes module - re-exports all sub-modules
          // This file can be used for any module-level declarations
          REEXPORT
          
          # Move types directory outside swift package to prevent SPM from scanning it
          if [ -d "swift/types" ]; then
            echo "Moving types directory outside package structure..."
            mv swift/types swift-types-temp || true
          fi
          
          # Verify the structure
          echo "Verifying package structure..."
          total_files=$(find swift/Sources -name "*.swift" -type f | wc -l | tr -d ' ')
          echo "Total Swift files organized: $total_files"
          
          # Create version file
          cat > swift/Sources/XionTypes/Version.swift << 'VERSION'
          // Generated version file
          public enum XionTypesVersion {
              public static let version = "0.1.0"
          }
          VERSION
      - name: Update Version
        working-directory: ./swift
        env:
          VERSION: ${{ needs.determine-version.outputs.version }}
        run: |
          sed -i '' "s/version = .*/version = \"$VERSION\"/" Package.swift 2>/dev/null || sed -i "s/version = .*/version = \"$VERSION\"/" Package.swift
          sed -i '' "s/static let version = .*/static let version = \"$VERSION\"/" Sources/XionTypes/Version.swift 2>/dev/null || sed -i "s/static let version = .*/static let version = \"$VERSION\"/" Sources/XionTypes/Version.swift
          echo "‚úÖ Updated version to $VERSION"
      - name: Finalize Package.swift
        working-directory: ./swift
        run: |
          # Verify Package.swift is correct and won't be modified
          if ! grep -q "name: \"XionTypes\"" Package.swift; then
            echo "‚ùå Package.swift validation failed"
            exit 1
          fi
          echo "‚úÖ Package.swift finalized"
      - name: Clean Build Directory
        working-directory: ./swift
        run: |
          swift package clean
          swift package reset 2>/dev/null || true
          rm -rf .build
          rm -rf .swiftpm
          rm -rf .swiftpm-build
          # Also clean derived data if it exists
          rm -rf ~/Library/Developer/Xcode/DerivedData/* 2>/dev/null || true
          echo "‚úÖ Cleaned build directory"
      - name: Verify Package Structure
        working-directory: ./swift
        run: |
          echo "Verifying package structure..."
          if [ ! -f "Package.swift" ]; then
            echo "‚ùå Package.swift not found"
            exit 1
          fi
          if [ ! -d "Sources/XionTypes" ]; then
            echo "‚ùå Sources/XionTypes directory not found"
            exit 1
          fi
          source_count=$(find Sources/XionTypes -name "*.swift" -type f | wc -l | tr -d ' ')
          echo "Found $source_count Swift source files"
          if [ "$source_count" -eq "0" ]; then
            echo "‚ùå No source files found"
            exit 1
          fi
          # Ensure types directory is not in swift package
          if [ -d "types" ]; then
            echo "‚ö†Ô∏è Warning: types directory still exists in package directory"
            exit 1
          fi
          echo "‚úÖ Package structure verified"
      - name: Describe Package
        working-directory: ./swift
        run: |
          swift package describe --type json > /dev/null 2>&1 || swift package dump-package > package-info.json
          echo "‚úÖ Package structure validated"
      - name: Resolve Dependencies
        working-directory: ./swift
        run: |
          swift package resolve
          echo "‚úÖ Resolved dependencies"
      - name: Verify Package Dependencies
        working-directory: ./swift
        run: |
          echo "Verifying cosmos targets depend on tendermint..."
          if grep -A 20 'name: "XionTypesCosmos' Package.swift | grep -q "XionTypesTendermint"; then
            echo "‚úÖ Cosmos targets have tendermint dependency"
          else
            echo "‚ö†Ô∏è Warning: Cosmos targets may not have tendermint dependency"
            echo "Package.swift cosmos section:"
            grep -A 20 'name: "XionTypesCosmos' Package.swift | head -25
          fi
      - name: Build Swift Package
        working-directory: ./swift
        env:
          SWIFTPM_MAXIMUM_PARALLELISM: "1"
        run: |
          # Known Swift Package Manager bug: "multiple producers" error
          # Workaround: Build each target individually and sequentially
          # This avoids the race condition in SPM's parallel compilation
          
          echo "Building targets sequentially to avoid race conditions..."
          
          # Get list of all targets from Package.swift
          ALL_TARGETS=$(grep -E 'name: "XionTypes' Package.swift | sed 's/.*name: "\([^"]*\)".*/\1/' | grep -v "^XionTypes$" | grep -v "XionTypesTests")
          
          # Build in dependency order: base targets first, then dependent targets
          # Order: google/gogoproto -> cosmos_proto -> cosmos (includes tendermint) -> everything else
          BASE_TARGETS=$(echo "$ALL_TARGETS" | grep -E "XionTypes(Google|Gogoproto)" || true)
          MID_TARGETS=$(echo "$ALL_TARGETS" | grep -E "XionTypesCosmosproto" || true)
          COSMOS_TARGETS=$(echo "$ALL_TARGETS" | grep -E "XionTypesCosmos" || true)
          OTHER_TARGETS=$(echo "$ALL_TARGETS" | grep -v -E "XionTypes(Google|Gogoproto|Cosmosproto|Cosmos)" || true)
          
          # Combine in order
          TARGETS="$BASE_TARGETS $MID_TARGETS $COSMOS_TARGETS $OTHER_TARGETS"
          
          echo "Build order: base -> mid -> cosmos -> other"
          echo "Base targets: $BASE_TARGETS"
          echo "Mid targets: $MID_TARGETS"
          echo "Cosmos targets: $COSMOS_TARGETS"
          echo "Other targets: $OTHER_TARGETS"
          
          # Build all targets individually in strict dependency order
          # This ensures types are available when dependent targets compile
          echo "Building all targets in dependency order..."
          
          echo "1/4: Building base targets (google, gogoproto)..."
          for base_target in $BASE_TARGETS; do
            if [ -n "$base_target" ]; then
              echo "  Building: $base_target"
              swift build -c release --target "$base_target" --build-path .build -Xswiftc -j1 || {
                echo "Failed to build $base_target"
                exit 1
              }
            fi
          done
          
          echo "2/4: Building mid targets (cosmos_proto)..."
          for mid_target in $MID_TARGETS; do
            if [ -n "$mid_target" ]; then
              echo "  Building: $mid_target"
              swift build -c release --target "$mid_target" --build-path .build -Xswiftc -j1 || {
                echo "Failed to build $mid_target"
                exit 1
              }
            fi
          done
          
          echo "3/4: Building cosmos targets (includes tendermint)..."
          for cosmos_target in $COSMOS_TARGETS; do
            if [ -n "$cosmos_target" ]; then
              echo "  Building: $cosmos_target"
              swift build -c release --target "$cosmos_target" --build-path .build -Xswiftc -j1 || {
                echo "Failed to build $cosmos_target"
                exit 1
              }
            fi
          done
          
          echo "4/4: Building remaining targets (depend on cosmos)..."
          for other_target in $OTHER_TARGETS; do
            if [ -n "$other_target" ]; then
              echo "  Building: $other_target"
              swift build -c release --target "$other_target" --build-path .build -Xswiftc -j1 || {
                echo "Failed to build $other_target"
                exit 1
              }
            fi
          done
          
          # Finally build the main XionTypes target
          echo "Building main XionTypes target..."
          swift build -c release --target XionTypes --build-path .build -Xswiftc -j1 || {
            echo "Failed to build main target"
            exit 1
          }
          
          echo "‚úÖ All targets built successfully"
          
          # Try debug build
          echo "Attempting debug build..."
          swift build -c debug --build-path .build 2>&1 | tee /tmp/debug-build.log || {
            if grep -q "multiple producers" /tmp/debug-build.log; then
              echo "‚ö†Ô∏è Debug build failed due to 'multiple producers' error (known SPM bug)"
              echo "Release build succeeded, so the code is valid"
            else
              echo "Debug build failed for a different reason:"
              cat /tmp/debug-build.log | tail -30
              # Don't fail if release build succeeded
            fi
          }
          
          echo "‚úÖ Swift package built successfully"
      - name: Upload Package
        uses: actions/upload-artifact@v4
        with:
          name: swift-package
          path: swift/
          retention-days: 30

  swift-test:
    name: Test Swift Package
    needs: [swift-build]
    runs-on: macos-latest
    steps:
      - name: Download Package
        uses: actions/download-artifact@v4
        with:
          name: swift-package
          path: swift/

      - name: Verify Swift Version
        run: swift --version

      - name: Verify Package Structure
        working-directory: ./swift
        run: |
          echo "=== Package structure ==="
          ls -la
          echo "=== Sources ==="
          ls -la Sources/ 2>/dev/null || echo "No Sources directory"
          echo "=== Sources/XionTypes (first 20 files) ==="
          ls Sources/XionTypes/ 2>/dev/null | head -20 || echo "No XionTypes"
          echo "=== Tests ==="
          ls -la Tests/ 2>/dev/null || echo "No Tests directory"
      - name: Test Swift Package
        working-directory: ./swift
        env:
          VERSION: ${{ needs.swift-build.outputs.version }}
        run: |
          swift test -c release -Xswiftc -j1
          echo "‚úÖ Swift package tests passed"
  # ============================================
  # Swift Package Publishing
  # ============================================
  # Note: Swift Package Manager packages are distributed via Git tags.
  # Publishing means creating a Git tag, which is typically done via releases.
  # For CocoaPods, see swift-cocoapods-publish job below.

  swift-cocoapods-publish:
    name: Publish to CocoaPods
    needs: [swift-test, swift-build]
    runs-on: macos-latest
    if: |
      github.event_name == 'workflow_dispatch' || 
      (github.event_name == 'repository_dispatch' && (github.event.client_payload.release_type == 'published' || github.event.client_payload.release_type == 'prerelease'))
    permissions:
      contents: read
    steps:
      - name: Download Package
        uses: actions/download-artifact@v4
        with:
          name: swift-package
          path: swift/

      - name: Setup CocoaPods
        run: |
          sudo gem install cocoapods
          pod --version

      - name: Create Podspec
        working-directory: ./swift
        env:
          VERSION: ${{ needs.swift-build.outputs.version }}
        run: |
          cat > XionTypes.podspec << 'PODSPEC'
          Pod::Spec.new do |spec|
            spec.name         = "XionTypes"
            spec.version      = "--ADD-HERE-YOUR-VALUE--"
            spec.summary      = "Generated Swift types for Xion blockchain protocol buffers"
            spec.description  = <<-DESC
              Complete Swift type definitions generated from Xion blockchain protocol buffers.
              Includes support for Cosmos SDK, Tendermint, and Xion-specific modules.
            DESC
            spec.homepage     = "https://github.com/burnt-labs/xion-types"
            spec.license      = { :type => "Apache-2.0" }
            spec.author       = { "Burnt Labs" => "devops@burnt.com" }
            
            spec.source       = { :git => "https://github.com/burnt-labs/xion-types.git", :tag => "#{spec.version}" }
            spec.source_files = "Sources/XionTypes/**/*.swift"
            
            spec.ios.deployment_target = "13.0"
            spec.osx.deployment_target = "10.15"
            spec.watchos.deployment_target = "6.0"
            spec.tvos.deployment_target = "13.0"
            
            spec.dependency "SwiftProtobuf", "~> 1.25"
            
            spec.swift_version = "5.9"
          end
          PODSPEC
          
          sed -i '' "s/--ADD-HERE-YOUR-VALUE--/$VERSION/" XionTypes.podspec 2>/dev/null || sed -i "s/--ADD-HERE-YOUR-VALUE--/$VERSION/" XionTypes.podspec
          echo "‚úÖ Created XionTypes.podspec"

          echo "Printing XionTypes.podspec..."
          cat XionTypes.podspec
          
      - name: Publish to CocoaPods Trunk
        working-directory: ./swift
        env:
          COCOAPODS_TRUNK_TOKEN: ${{ secrets.COCOAPODS_TRUNK_TOKEN }}
          VERSION: ${{ needs.swift-build.outputs.version }}
        run: |
          if [ -z "$COCOAPODS_TRUNK_TOKEN" ]; then
            echo "‚ö†Ô∏è COCOAPODS_TRUNK_TOKEN not set, skipping publish"
            exit 0
          fi

          echo "Printing session info..."
          pod trunk me
          
          # Check if this is a dev version (0.0.0.devXXXXXXXXXX)
          if [[ "$VERSION" == 0.0.0.dev* ]]; then
            echo "‚ö†Ô∏è Dev version detected: $VERSION"
            echo "Dev versions cannot be validated by CocoaPods (no git tag exists yet)"
            echo "Podspec structure has been verified during creation"
            echo "Full validation will occur on actual release with proper git tag"
            echo "‚ö†Ô∏è Skipping CocoaPods validation and publishing for dev version"
            exit 0
          fi
          
          # For release versions, do full validation and publish
          echo "Publishing release version: $VERSION"
          pod trunk push XionTypes.podspec
          echo "‚úÖ Published to CocoaPods Trunk"

  notify-slack:
    name: Notify Slack
    runs-on: ubuntu-latest
    needs: [determine-version, generate-protobuf, swift-build, swift-test, swift-cocoapods-publish]
    if: always()
    steps:
      - name: Check if any job failed
        id: check-failures
        continue-on-error: true
        run: |
          GENERATE_RESULT="${{ needs.generate-protobuf.result }}"
          BUILD_RESULT="${{ needs.swift-build.result }}"
          TEST_RESULT="${{ needs.swift-test.result }}"
          PUBLISH_RESULT="${{ needs.swift-cocoapods-publish.result }}"
          VERSION="${{ needs.determine-version.outputs.version }}"
          
          echo "Generate result: $GENERATE_RESULT"
          echo "Build result: $BUILD_RESULT"
          echo "Test result: $TEST_RESULT"
          echo "Publish result: $PUBLISH_RESULT"
          echo "Version: $VERSION"
          
          # Export version for other steps
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          
          # Check if this is a dev version
          if [[ "$VERSION" == 0.0.0.dev* ]]; then
            echo "is_dev_version=true" >> $GITHUB_OUTPUT
            echo "Dev version detected"
          else
            echo "is_dev_version=false" >> $GITHUB_OUTPUT
          fi
          
          if [ "$GENERATE_RESULT" != "success" ] || [ "$BUILD_RESULT" != "success" ] || [ "$TEST_RESULT" != "success" ]; then
            echo "has_failures=true" >> $GITHUB_OUTPUT
            echo "Found failures - will send notification"
          else
            echo "has_failures=false" >> $GITHUB_OUTPUT
            echo "All core jobs passed - will send success notification"
          fi

      - name: Send Slack notification on failure
        if: steps.check-failures.outputs.has_failures == 'true'
        continue-on-error: true
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.NOTIFY_DEVOPS_SLACK_APP_BOT_TOKEN }}
          payload: |
            channel: ${{ secrets.DEVOPS_NOTIFICATIONS_SLACK_CHANNEL_ID }}
            text: "üö® Swift Protobuf Generation/Build/Test Failed - XionTypes (${{ steps.check-failures.outputs.version }}):
            ‚Ä¢ Generate: ${{ needs.generate-protobuf.result }}
            ‚Ä¢ Build: ${{ needs.swift-build.result }}
            ‚Ä¢ Test: ${{ needs.swift-test.result }}
            ‚Ä¢ Publish: ${{ needs.swift-cocoapods-publish.result }}
            <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View workflow run>"
          errors: false
          retries: 0

      - name: Send Slack notification for dev version
        if: steps.check-failures.outputs.has_failures == 'false' && steps.check-failures.outputs.is_dev_version == 'true'
        continue-on-error: true
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.NOTIFY_DEVOPS_SLACK_APP_BOT_TOKEN }}
          payload: |
            channel: ${{ secrets.DEVOPS_NOTIFICATIONS_SLACK_CHANNEL_ID }}
            text: "üîß Swift Protobuf Dev Build - XionTypes (${{ steps.check-failures.outputs.version }}):
            ‚Ä¢ Generated Swift types from protobuf definitions
            ‚Ä¢ Built Swift Package successfully
            ‚Ä¢ All tests passed
            ‚Ä¢ ‚ö†Ô∏è Dev version - not published to CocoaPods (no git tag)
            <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View workflow run>"
          errors: false
          retries: 0

      - name: Send Slack notification on release success
        if: steps.check-failures.outputs.has_failures == 'false' && steps.check-failures.outputs.is_dev_version == 'false'
        continue-on-error: true
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.NOTIFY_DEVOPS_SLACK_APP_BOT_TOKEN }}
          payload: |
            channel: ${{ secrets.DEVOPS_NOTIFICATIONS_SLACK_CHANNEL_ID }}
            text: "‚úÖ Swift Protobuf Pipeline Succeeded - XionTypes (${{ steps.check-failures.outputs.version }}):
            ‚Ä¢ Generated Swift types from protobuf definitions
            ‚Ä¢ Built Swift Package successfully
            ‚Ä¢ All tests passed
            ‚Ä¢ Published to CocoaPods: ${{ needs.swift-cocoapods-publish.result }}
            <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View workflow run>"
          errors: false
          retries: 0