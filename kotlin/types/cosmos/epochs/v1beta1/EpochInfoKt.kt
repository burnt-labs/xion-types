// Generated by the protocol buffer compiler. DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: cosmos/epochs/v1beta1/genesis.proto

// Generated files should ignore deprecation warnings
@file:Suppress("DEPRECATION")
package cosmos.epochs.v1beta1;

@kotlin.jvm.JvmName("-initializeepochInfo")
public inline fun epochInfo(block: cosmos.epochs.v1beta1.EpochInfoKt.Dsl.() -> kotlin.Unit): cosmos.epochs.v1beta1.Genesis.EpochInfo =
  cosmos.epochs.v1beta1.EpochInfoKt.Dsl._create(cosmos.epochs.v1beta1.Genesis.EpochInfo.newBuilder()).apply { block() }._build()
/**
 * ```
 * EpochInfo is a struct that describes the data going into
 * a timer defined by the x/epochs module.
 * ```
 *
 * Protobuf type `cosmos.epochs.v1beta1.EpochInfo`
 */
public object EpochInfoKt {
  @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
  @com.google.protobuf.kotlin.ProtoDslMarker
  public class Dsl private constructor(
    private val _builder: cosmos.epochs.v1beta1.Genesis.EpochInfo.Builder
  ) {
    public companion object {
      @kotlin.jvm.JvmSynthetic
    @kotlin.PublishedApi
      internal fun _create(builder: cosmos.epochs.v1beta1.Genesis.EpochInfo.Builder): Dsl = Dsl(builder)
    }

    @kotlin.jvm.JvmSynthetic
  @kotlin.PublishedApi
    internal fun _build(): cosmos.epochs.v1beta1.Genesis.EpochInfo = _builder.build()

    /**
     * ```
     * identifier is a unique reference to this particular timer.
     * ```
     *
     * `string identifier = 1 [json_name = "identifier"];`
     */
    public var identifier: kotlin.String
      @JvmName("getIdentifier")
      get() = _builder.identifier
      @JvmName("setIdentifier")
      set(value) {
        _builder.identifier = value
      }
    /**
     * ```
     * identifier is a unique reference to this particular timer.
     * ```
     *
     * `string identifier = 1 [json_name = "identifier"];`
     */
    public fun clearIdentifier() {
      _builder.clearIdentifier()
    }

    /**
     * ```
     * start_time is the time at which the timer first ever ticks.
     * If start_time is in the future, the epoch will not begin until the start
     * time.
     * ```
     *
     * `.google.protobuf.Timestamp start_time = 2 [json_name = "startTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];`
     */
    public var startTime: com.google.protobuf.Timestamp
      @JvmName("getStartTime")
      get() = _builder.startTime
      @JvmName("setStartTime")
      set(value) {
        _builder.startTime = value
      }
    /**
     * ```
     * start_time is the time at which the timer first ever ticks.
     * If start_time is in the future, the epoch will not begin until the start
     * time.
     * ```
     *
     * `.google.protobuf.Timestamp start_time = 2 [json_name = "startTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];`
     */
    public fun clearStartTime() {
      _builder.clearStartTime()
    }
    /**
     * ```
     * start_time is the time at which the timer first ever ticks.
     * If start_time is in the future, the epoch will not begin until the start
     * time.
     * ```
     *
     * `.google.protobuf.Timestamp start_time = 2 [json_name = "startTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];`
     * @return Whether the startTime field is set.
     */
    public fun hasStartTime(): kotlin.Boolean {
      return _builder.hasStartTime()
    }

    public val EpochInfoKt.Dsl.startTimeOrNull: com.google.protobuf.Timestamp?
      get() = _builder.startTimeOrNull

    /**
     * ```
     * duration is the time in between epoch ticks.
     * In order for intended behavior to be met, duration should
     * be greater than the chains expected block time.
     * Duration must be non-zero.
     * ```
     *
     * `.google.protobuf.Duration duration = 3 [json_name = "duration", (.gogoproto.nullable) = false, (.gogoproto.jsontag) = "duration,omitempty", (.gogoproto.stdduration) = true];`
     */
    public var duration: com.google.protobuf.Duration
      @JvmName("getDuration")
      get() = _builder.duration
      @JvmName("setDuration")
      set(value) {
        _builder.duration = value
      }
    /**
     * ```
     * duration is the time in between epoch ticks.
     * In order for intended behavior to be met, duration should
     * be greater than the chains expected block time.
     * Duration must be non-zero.
     * ```
     *
     * `.google.protobuf.Duration duration = 3 [json_name = "duration", (.gogoproto.nullable) = false, (.gogoproto.jsontag) = "duration,omitempty", (.gogoproto.stdduration) = true];`
     */
    public fun clearDuration() {
      _builder.clearDuration()
    }
    /**
     * ```
     * duration is the time in between epoch ticks.
     * In order for intended behavior to be met, duration should
     * be greater than the chains expected block time.
     * Duration must be non-zero.
     * ```
     *
     * `.google.protobuf.Duration duration = 3 [json_name = "duration", (.gogoproto.nullable) = false, (.gogoproto.jsontag) = "duration,omitempty", (.gogoproto.stdduration) = true];`
     * @return Whether the duration field is set.
     */
    public fun hasDuration(): kotlin.Boolean {
      return _builder.hasDuration()
    }

    public val EpochInfoKt.Dsl.durationOrNull: com.google.protobuf.Duration?
      get() = _builder.durationOrNull

    /**
     * ```
     * current_epoch is the current epoch number, or in other words,
     * how many times has the timer 'ticked'.
     * The first tick (current_epoch=1) is defined as
     * the first block whose blocktime is greater than the EpochInfo start_time.
     * ```
     *
     * `int64 current_epoch = 4 [json_name = "currentEpoch"];`
     */
    public var currentEpoch: kotlin.Long
      @JvmName("getCurrentEpoch")
      get() = _builder.currentEpoch
      @JvmName("setCurrentEpoch")
      set(value) {
        _builder.currentEpoch = value
      }
    /**
     * ```
     * current_epoch is the current epoch number, or in other words,
     * how many times has the timer 'ticked'.
     * The first tick (current_epoch=1) is defined as
     * the first block whose blocktime is greater than the EpochInfo start_time.
     * ```
     *
     * `int64 current_epoch = 4 [json_name = "currentEpoch"];`
     */
    public fun clearCurrentEpoch() {
      _builder.clearCurrentEpoch()
    }

    /**
     * ```
     * current_epoch_start_time describes the start time of the current timer
     * interval. The interval is (current_epoch_start_time,
     * current_epoch_start_time + duration] When the timer ticks, this is set to
     * current_epoch_start_time = last_epoch_start_time + duration only one timer
     * tick for a given identifier can occur per block.
     *
     * NOTE! The current_epoch_start_time may diverge significantly from the
     * wall-clock time the epoch began at. Wall-clock time of epoch start may be
     * >> current_epoch_start_time. Suppose current_epoch_start_time = 10,
     * duration = 5. Suppose the chain goes offline at t=14, and comes back online
     * at t=30, and produces blocks at every successive time. (t=31, 32, etc.)
     * * The t=30 block will start the epoch for (10, 15]
     * * The t=31 block will start the epoch for (15, 20]
     * * The t=32 block will start the epoch for (20, 25]
     * * The t=33 block will start the epoch for (25, 30]
     * * The t=34 block will start the epoch for (30, 35]
     * * The **t=36** block will start the epoch for (35, 40]
     * ```
     *
     * `.google.protobuf.Timestamp current_epoch_start_time = 5 [json_name = "currentEpochStartTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];`
     */
    public var currentEpochStartTime: com.google.protobuf.Timestamp
      @JvmName("getCurrentEpochStartTime")
      get() = _builder.currentEpochStartTime
      @JvmName("setCurrentEpochStartTime")
      set(value) {
        _builder.currentEpochStartTime = value
      }
    /**
     * ```
     * current_epoch_start_time describes the start time of the current timer
     * interval. The interval is (current_epoch_start_time,
     * current_epoch_start_time + duration] When the timer ticks, this is set to
     * current_epoch_start_time = last_epoch_start_time + duration only one timer
     * tick for a given identifier can occur per block.
     *
     * NOTE! The current_epoch_start_time may diverge significantly from the
     * wall-clock time the epoch began at. Wall-clock time of epoch start may be
     * >> current_epoch_start_time. Suppose current_epoch_start_time = 10,
     * duration = 5. Suppose the chain goes offline at t=14, and comes back online
     * at t=30, and produces blocks at every successive time. (t=31, 32, etc.)
     * * The t=30 block will start the epoch for (10, 15]
     * * The t=31 block will start the epoch for (15, 20]
     * * The t=32 block will start the epoch for (20, 25]
     * * The t=33 block will start the epoch for (25, 30]
     * * The t=34 block will start the epoch for (30, 35]
     * * The **t=36** block will start the epoch for (35, 40]
     * ```
     *
     * `.google.protobuf.Timestamp current_epoch_start_time = 5 [json_name = "currentEpochStartTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];`
     */
    public fun clearCurrentEpochStartTime() {
      _builder.clearCurrentEpochStartTime()
    }
    /**
     * ```
     * current_epoch_start_time describes the start time of the current timer
     * interval. The interval is (current_epoch_start_time,
     * current_epoch_start_time + duration] When the timer ticks, this is set to
     * current_epoch_start_time = last_epoch_start_time + duration only one timer
     * tick for a given identifier can occur per block.
     *
     * NOTE! The current_epoch_start_time may diverge significantly from the
     * wall-clock time the epoch began at. Wall-clock time of epoch start may be
     * >> current_epoch_start_time. Suppose current_epoch_start_time = 10,
     * duration = 5. Suppose the chain goes offline at t=14, and comes back online
     * at t=30, and produces blocks at every successive time. (t=31, 32, etc.)
     * * The t=30 block will start the epoch for (10, 15]
     * * The t=31 block will start the epoch for (15, 20]
     * * The t=32 block will start the epoch for (20, 25]
     * * The t=33 block will start the epoch for (25, 30]
     * * The t=34 block will start the epoch for (30, 35]
     * * The **t=36** block will start the epoch for (35, 40]
     * ```
     *
     * `.google.protobuf.Timestamp current_epoch_start_time = 5 [json_name = "currentEpochStartTime", (.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];`
     * @return Whether the currentEpochStartTime field is set.
     */
    public fun hasCurrentEpochStartTime(): kotlin.Boolean {
      return _builder.hasCurrentEpochStartTime()
    }

    public val EpochInfoKt.Dsl.currentEpochStartTimeOrNull: com.google.protobuf.Timestamp?
      get() = _builder.currentEpochStartTimeOrNull

    /**
     * ```
     * epoch_counting_started is a boolean, that indicates whether this
     * epoch timer has began yet.
     * ```
     *
     * `bool epoch_counting_started = 6 [json_name = "epochCountingStarted"];`
     */
    public var epochCountingStarted: kotlin.Boolean
      @JvmName("getEpochCountingStarted")
      get() = _builder.epochCountingStarted
      @JvmName("setEpochCountingStarted")
      set(value) {
        _builder.epochCountingStarted = value
      }
    /**
     * ```
     * epoch_counting_started is a boolean, that indicates whether this
     * epoch timer has began yet.
     * ```
     *
     * `bool epoch_counting_started = 6 [json_name = "epochCountingStarted"];`
     */
    public fun clearEpochCountingStarted() {
      _builder.clearEpochCountingStarted()
    }

    /**
     * ```
     * current_epoch_start_height is the block height at which the current epoch
     * started. (The block height at which the timer last ticked)
     * ```
     *
     * `int64 current_epoch_start_height = 8 [json_name = "currentEpochStartHeight"];`
     */
    public var currentEpochStartHeight: kotlin.Long
      @JvmName("getCurrentEpochStartHeight")
      get() = _builder.currentEpochStartHeight
      @JvmName("setCurrentEpochStartHeight")
      set(value) {
        _builder.currentEpochStartHeight = value
      }
    /**
     * ```
     * current_epoch_start_height is the block height at which the current epoch
     * started. (The block height at which the timer last ticked)
     * ```
     *
     * `int64 current_epoch_start_height = 8 [json_name = "currentEpochStartHeight"];`
     */
    public fun clearCurrentEpochStartHeight() {
      _builder.clearCurrentEpochStartHeight()
    }
  }
}
@kotlin.jvm.JvmSynthetic
public inline fun cosmos.epochs.v1beta1.Genesis.EpochInfo.copy(block: `cosmos.epochs.v1beta1`.EpochInfoKt.Dsl.() -> kotlin.Unit): cosmos.epochs.v1beta1.Genesis.EpochInfo =
  `cosmos.epochs.v1beta1`.EpochInfoKt.Dsl._create(this.toBuilder()).apply { block() }._build()

public val cosmos.epochs.v1beta1.Genesis.EpochInfoOrBuilder.startTimeOrNull: com.google.protobuf.Timestamp?
  get() = if (hasStartTime()) getStartTime() else null

public val cosmos.epochs.v1beta1.Genesis.EpochInfoOrBuilder.durationOrNull: com.google.protobuf.Duration?
  get() = if (hasDuration()) getDuration() else null

public val cosmos.epochs.v1beta1.Genesis.EpochInfoOrBuilder.currentEpochStartTimeOrNull: com.google.protobuf.Timestamp?
  get() = if (hasCurrentEpochStartTime()) getCurrentEpochStartTime() else null

