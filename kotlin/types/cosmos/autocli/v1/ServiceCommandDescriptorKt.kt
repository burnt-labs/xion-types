// Generated by the protocol buffer compiler. DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: cosmos/autocli/v1/options.proto

// Generated files should ignore deprecation warnings
@file:Suppress("DEPRECATION")
package cosmos.autocli.v1;

@kotlin.jvm.JvmName("-initializeserviceCommandDescriptor")
public inline fun serviceCommandDescriptor(block: cosmos.autocli.v1.ServiceCommandDescriptorKt.Dsl.() -> kotlin.Unit): cosmos.autocli.v1.Options.ServiceCommandDescriptor =
  cosmos.autocli.v1.ServiceCommandDescriptorKt.Dsl._create(cosmos.autocli.v1.Options.ServiceCommandDescriptor.newBuilder()).apply { block() }._build()
/**
 * ```
 * ServiceCommandDescriptor describes a CLI command based on a protobuf service.
 * ```
 *
 * Protobuf type `cosmos.autocli.v1.ServiceCommandDescriptor`
 */
public object ServiceCommandDescriptorKt {
  @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
  @com.google.protobuf.kotlin.ProtoDslMarker
  public class Dsl private constructor(
    private val _builder: cosmos.autocli.v1.Options.ServiceCommandDescriptor.Builder
  ) {
    public companion object {
      @kotlin.jvm.JvmSynthetic
    @kotlin.PublishedApi
      internal fun _create(builder: cosmos.autocli.v1.Options.ServiceCommandDescriptor.Builder): Dsl = Dsl(builder)
    }

    @kotlin.jvm.JvmSynthetic
  @kotlin.PublishedApi
    internal fun _build(): cosmos.autocli.v1.Options.ServiceCommandDescriptor = _builder.build()

    /**
     * ```
     * service is the fully qualified name of the protobuf service to build
     * the command from. It can be left empty if sub_commands are used instead
     * which may be the case if a module provides multiple tx and/or query services.
     * ```
     *
     * `string service = 1 [json_name = "service"];`
     */
    public var service: kotlin.String
      @JvmName("getService")
      get() = _builder.service
      @JvmName("setService")
      set(value) {
        _builder.service = value
      }
    /**
     * ```
     * service is the fully qualified name of the protobuf service to build
     * the command from. It can be left empty if sub_commands are used instead
     * which may be the case if a module provides multiple tx and/or query services.
     * ```
     *
     * `string service = 1 [json_name = "service"];`
     */
    public fun clearService() {
      _builder.clearService()
    }

    /**
     * An uninstantiable, behaviorless type to represent the field in
     * generics.
     */
    @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
    public class RpcCommandOptionsProxy private constructor() : com.google.protobuf.kotlin.DslProxy()
    /**
     * ```
     * rpc_command_options are options for commands generated from rpc methods.
     * If no options are specified for a given rpc method on the service, a
     * command will be generated for that method with the default options.
     * ```
     *
     * `repeated .cosmos.autocli.v1.RpcCommandOptions rpc_command_options = 2 [json_name = "rpcCommandOptions"];`
     */
     public val rpcCommandOptions: com.google.protobuf.kotlin.DslList<cosmos.autocli.v1.Options.RpcCommandOptions, RpcCommandOptionsProxy>
      @kotlin.jvm.JvmSynthetic
      get() = com.google.protobuf.kotlin.DslList(
        _builder.rpcCommandOptionsList
      )
    /**
     * ```
     * rpc_command_options are options for commands generated from rpc methods.
     * If no options are specified for a given rpc method on the service, a
     * command will be generated for that method with the default options.
     * ```
     *
     * `repeated .cosmos.autocli.v1.RpcCommandOptions rpc_command_options = 2 [json_name = "rpcCommandOptions"];`
     * @param value The rpcCommandOptions to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("addRpcCommandOptions")
    public fun com.google.protobuf.kotlin.DslList<cosmos.autocli.v1.Options.RpcCommandOptions, RpcCommandOptionsProxy>.add(value: cosmos.autocli.v1.Options.RpcCommandOptions) {
      _builder.addRpcCommandOptions(value)
    }
    /**
     * ```
     * rpc_command_options are options for commands generated from rpc methods.
     * If no options are specified for a given rpc method on the service, a
     * command will be generated for that method with the default options.
     * ```
     *
     * `repeated .cosmos.autocli.v1.RpcCommandOptions rpc_command_options = 2 [json_name = "rpcCommandOptions"];`
     * @param value The rpcCommandOptions to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("plusAssignRpcCommandOptions")
    @Suppress("NOTHING_TO_INLINE")
    public inline operator fun com.google.protobuf.kotlin.DslList<cosmos.autocli.v1.Options.RpcCommandOptions, RpcCommandOptionsProxy>.plusAssign(value: cosmos.autocli.v1.Options.RpcCommandOptions) {
      add(value)
    }
    /**
     * ```
     * rpc_command_options are options for commands generated from rpc methods.
     * If no options are specified for a given rpc method on the service, a
     * command will be generated for that method with the default options.
     * ```
     *
     * `repeated .cosmos.autocli.v1.RpcCommandOptions rpc_command_options = 2 [json_name = "rpcCommandOptions"];`
     * @param values The rpcCommandOptions to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("addAllRpcCommandOptions")
    public fun com.google.protobuf.kotlin.DslList<cosmos.autocli.v1.Options.RpcCommandOptions, RpcCommandOptionsProxy>.addAll(values: kotlin.collections.Iterable<cosmos.autocli.v1.Options.RpcCommandOptions>) {
      _builder.addAllRpcCommandOptions(values)
    }
    /**
     * ```
     * rpc_command_options are options for commands generated from rpc methods.
     * If no options are specified for a given rpc method on the service, a
     * command will be generated for that method with the default options.
     * ```
     *
     * `repeated .cosmos.autocli.v1.RpcCommandOptions rpc_command_options = 2 [json_name = "rpcCommandOptions"];`
     * @param values The rpcCommandOptions to add.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("plusAssignAllRpcCommandOptions")
    @Suppress("NOTHING_TO_INLINE")
    public inline operator fun com.google.protobuf.kotlin.DslList<cosmos.autocli.v1.Options.RpcCommandOptions, RpcCommandOptionsProxy>.plusAssign(values: kotlin.collections.Iterable<cosmos.autocli.v1.Options.RpcCommandOptions>) {
      addAll(values)
    }
    /**
     * ```
     * rpc_command_options are options for commands generated from rpc methods.
     * If no options are specified for a given rpc method on the service, a
     * command will be generated for that method with the default options.
     * ```
     *
     * `repeated .cosmos.autocli.v1.RpcCommandOptions rpc_command_options = 2 [json_name = "rpcCommandOptions"];`
     * @param index The index to set the value at.
     * @param value The rpcCommandOptions to set.
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("setRpcCommandOptions")
    public operator fun com.google.protobuf.kotlin.DslList<cosmos.autocli.v1.Options.RpcCommandOptions, RpcCommandOptionsProxy>.set(index: kotlin.Int, value: cosmos.autocli.v1.Options.RpcCommandOptions) {
      _builder.setRpcCommandOptions(index, value)
    }
    /**
     * ```
     * rpc_command_options are options for commands generated from rpc methods.
     * If no options are specified for a given rpc method on the service, a
     * command will be generated for that method with the default options.
     * ```
     *
     * `repeated .cosmos.autocli.v1.RpcCommandOptions rpc_command_options = 2 [json_name = "rpcCommandOptions"];`
     */
    @kotlin.jvm.JvmSynthetic
    @kotlin.jvm.JvmName("clearRpcCommandOptions")
    public fun com.google.protobuf.kotlin.DslList<cosmos.autocli.v1.Options.RpcCommandOptions, RpcCommandOptionsProxy>.clear() {
      _builder.clearRpcCommandOptions()
    }


    /**
     * An uninstantiable, behaviorless type to represent the field in
     * generics.
     */
    @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
    public class SubCommandsProxy private constructor() : com.google.protobuf.kotlin.DslProxy()
    /**
     * ```
     * sub_commands is a map of optional sub-commands for this command based on
     * different protobuf services. The map key is used as the name of the
     * sub-command.
     * ```
     *
     * `map<string, .cosmos.autocli.v1.ServiceCommandDescriptor> sub_commands = 3 [json_name = "subCommands"];`
     */
     public val subCommands: com.google.protobuf.kotlin.DslMap<kotlin.String, cosmos.autocli.v1.Options.ServiceCommandDescriptor, SubCommandsProxy>
      @kotlin.jvm.JvmSynthetic
      @JvmName("getSubCommandsMap")
      get() = com.google.protobuf.kotlin.DslMap(
        _builder.subCommandsMap
      )
    /**
     * ```
     * sub_commands is a map of optional sub-commands for this command based on
     * different protobuf services. The map key is used as the name of the
     * sub-command.
     * ```
     *
     * `map<string, .cosmos.autocli.v1.ServiceCommandDescriptor> sub_commands = 3 [json_name = "subCommands"];`
     */
    @JvmName("putSubCommands")
    public fun com.google.protobuf.kotlin.DslMap<kotlin.String, cosmos.autocli.v1.Options.ServiceCommandDescriptor, SubCommandsProxy>
      .put(key: kotlin.String, value: cosmos.autocli.v1.Options.ServiceCommandDescriptor) {
         _builder.putSubCommands(key, value)
       }
    /**
     * ```
     * sub_commands is a map of optional sub-commands for this command based on
     * different protobuf services. The map key is used as the name of the
     * sub-command.
     * ```
     *
     * `map<string, .cosmos.autocli.v1.ServiceCommandDescriptor> sub_commands = 3 [json_name = "subCommands"];`
     */
    @kotlin.jvm.JvmSynthetic
    @JvmName("setSubCommands")
    @Suppress("NOTHING_TO_INLINE")
    public inline operator fun com.google.protobuf.kotlin.DslMap<kotlin.String, cosmos.autocli.v1.Options.ServiceCommandDescriptor, SubCommandsProxy>
      .set(key: kotlin.String, value: cosmos.autocli.v1.Options.ServiceCommandDescriptor) {
         put(key, value)
       }
    /**
     * ```
     * sub_commands is a map of optional sub-commands for this command based on
     * different protobuf services. The map key is used as the name of the
     * sub-command.
     * ```
     *
     * `map<string, .cosmos.autocli.v1.ServiceCommandDescriptor> sub_commands = 3 [json_name = "subCommands"];`
     */
    @kotlin.jvm.JvmSynthetic
    @JvmName("removeSubCommands")
    public fun com.google.protobuf.kotlin.DslMap<kotlin.String, cosmos.autocli.v1.Options.ServiceCommandDescriptor, SubCommandsProxy>
      .remove(key: kotlin.String) {
         _builder.removeSubCommands(key)
       }
    /**
     * ```
     * sub_commands is a map of optional sub-commands for this command based on
     * different protobuf services. The map key is used as the name of the
     * sub-command.
     * ```
     *
     * `map<string, .cosmos.autocli.v1.ServiceCommandDescriptor> sub_commands = 3 [json_name = "subCommands"];`
     */
    @kotlin.jvm.JvmSynthetic
    @JvmName("putAllSubCommands")
    public fun com.google.protobuf.kotlin.DslMap<kotlin.String, cosmos.autocli.v1.Options.ServiceCommandDescriptor, SubCommandsProxy>
      .putAll(map: kotlin.collections.Map<kotlin.String, cosmos.autocli.v1.Options.ServiceCommandDescriptor>) {
         _builder.putAllSubCommands(map)
       }
    /**
     * ```
     * sub_commands is a map of optional sub-commands for this command based on
     * different protobuf services. The map key is used as the name of the
     * sub-command.
     * ```
     *
     * `map<string, .cosmos.autocli.v1.ServiceCommandDescriptor> sub_commands = 3 [json_name = "subCommands"];`
     */
    @kotlin.jvm.JvmSynthetic
    @JvmName("clearSubCommands")
    public fun com.google.protobuf.kotlin.DslMap<kotlin.String, cosmos.autocli.v1.Options.ServiceCommandDescriptor, SubCommandsProxy>
      .clear() {
         _builder.clearSubCommands()
       }

    /**
     * ```
     * enhance_custom_commands specifies whether to skip the service when generating commands, if a custom command already
     * exists, or enhance the existing command. If set to true, the custom command will be enhanced with the services from
     * gRPC. otherwise when a custom command exists, no commands will be generated for the service.
     * ```
     *
     * `bool enhance_custom_command = 4 [json_name = "enhanceCustomCommand"];`
     */
    public var enhanceCustomCommand: kotlin.Boolean
      @JvmName("getEnhanceCustomCommand")
      get() = _builder.enhanceCustomCommand
      @JvmName("setEnhanceCustomCommand")
      set(value) {
        _builder.enhanceCustomCommand = value
      }
    /**
     * ```
     * enhance_custom_commands specifies whether to skip the service when generating commands, if a custom command already
     * exists, or enhance the existing command. If set to true, the custom command will be enhanced with the services from
     * gRPC. otherwise when a custom command exists, no commands will be generated for the service.
     * ```
     *
     * `bool enhance_custom_command = 4 [json_name = "enhanceCustomCommand"];`
     */
    public fun clearEnhanceCustomCommand() {
      _builder.clearEnhanceCustomCommand()
    }

    /**
     * ```
     * short is an optional parameter used to override the short description of the auto generated command.
     * ```
     *
     * `string short = 5 [json_name = "short"];`
     */
    public var short: kotlin.String
      @JvmName("getShort")
      get() = _builder.short
      @JvmName("setShort")
      set(value) {
        _builder.short = value
      }
    /**
     * ```
     * short is an optional parameter used to override the short description of the auto generated command.
     * ```
     *
     * `string short = 5 [json_name = "short"];`
     */
    public fun clearShort() {
      _builder.clearShort()
    }
  }
}
@kotlin.jvm.JvmSynthetic
public inline fun cosmos.autocli.v1.Options.ServiceCommandDescriptor.copy(block: `cosmos.autocli.v1`.ServiceCommandDescriptorKt.Dsl.() -> kotlin.Unit): cosmos.autocli.v1.Options.ServiceCommandDescriptor =
  `cosmos.autocli.v1`.ServiceCommandDescriptorKt.Dsl._create(this.toBuilder()).apply { block() }._build()

