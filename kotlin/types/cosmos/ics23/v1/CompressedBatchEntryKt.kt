// Generated by the protocol buffer compiler. DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: cosmos/ics23/v1/proofs.proto

// Generated files should ignore deprecation warnings
@file:Suppress("DEPRECATION")
package cosmos.ics23.v1;

@kotlin.jvm.JvmName("-initializecompressedBatchEntry")
public inline fun compressedBatchEntry(block: cosmos.ics23.v1.CompressedBatchEntryKt.Dsl.() -> kotlin.Unit): cosmos.ics23.v1.Proofs.CompressedBatchEntry =
  cosmos.ics23.v1.CompressedBatchEntryKt.Dsl._create(cosmos.ics23.v1.Proofs.CompressedBatchEntry.newBuilder()).apply { block() }._build()
/**
 * ```
 * Use BatchEntry not CommitmentProof, to avoid recursion
 * ```
 *
 * Protobuf type `cosmos.ics23.v1.CompressedBatchEntry`
 */
public object CompressedBatchEntryKt {
  @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
  @com.google.protobuf.kotlin.ProtoDslMarker
  public class Dsl private constructor(
    private val _builder: cosmos.ics23.v1.Proofs.CompressedBatchEntry.Builder
  ) {
    public companion object {
      @kotlin.jvm.JvmSynthetic
    @kotlin.PublishedApi
      internal fun _create(builder: cosmos.ics23.v1.Proofs.CompressedBatchEntry.Builder): Dsl = Dsl(builder)
    }

    @kotlin.jvm.JvmSynthetic
  @kotlin.PublishedApi
    internal fun _build(): cosmos.ics23.v1.Proofs.CompressedBatchEntry = _builder.build()

    /**
     * `.cosmos.ics23.v1.CompressedExistenceProof exist = 1 [json_name = "exist"];`
     */
    public var exist: cosmos.ics23.v1.Proofs.CompressedExistenceProof
      @JvmName("getExist")
      get() = _builder.exist
      @JvmName("setExist")
      set(value) {
        _builder.exist = value
      }
    /**
     * `.cosmos.ics23.v1.CompressedExistenceProof exist = 1 [json_name = "exist"];`
     */
    public fun clearExist() {
      _builder.clearExist()
    }
    /**
     * `.cosmos.ics23.v1.CompressedExistenceProof exist = 1 [json_name = "exist"];`
     * @return Whether the exist field is set.
     */
    public fun hasExist(): kotlin.Boolean {
      return _builder.hasExist()
    }

    /**
     * `.cosmos.ics23.v1.CompressedNonExistenceProof nonexist = 2 [json_name = "nonexist"];`
     */
    public var nonexist: cosmos.ics23.v1.Proofs.CompressedNonExistenceProof
      @JvmName("getNonexist")
      get() = _builder.nonexist
      @JvmName("setNonexist")
      set(value) {
        _builder.nonexist = value
      }
    /**
     * `.cosmos.ics23.v1.CompressedNonExistenceProof nonexist = 2 [json_name = "nonexist"];`
     */
    public fun clearNonexist() {
      _builder.clearNonexist()
    }
    /**
     * `.cosmos.ics23.v1.CompressedNonExistenceProof nonexist = 2 [json_name = "nonexist"];`
     * @return Whether the nonexist field is set.
     */
    public fun hasNonexist(): kotlin.Boolean {
      return _builder.hasNonexist()
    }
    public val proofCase: cosmos.ics23.v1.Proofs.CompressedBatchEntry.ProofCase
    @kotlin.jvm.JvmName("getProofCase")
      get() = _builder.getProofCase()

    public fun clearProof() {
      _builder.clearProof()
    }
  }
}
@kotlin.jvm.JvmSynthetic
public inline fun cosmos.ics23.v1.Proofs.CompressedBatchEntry.copy(block: `cosmos.ics23.v1`.CompressedBatchEntryKt.Dsl.() -> kotlin.Unit): cosmos.ics23.v1.Proofs.CompressedBatchEntry =
  `cosmos.ics23.v1`.CompressedBatchEntryKt.Dsl._create(this.toBuilder()).apply { block() }._build()

public val cosmos.ics23.v1.Proofs.CompressedBatchEntryOrBuilder.existOrNull: cosmos.ics23.v1.Proofs.CompressedExistenceProof?
  get() = if (hasExist()) getExist() else null

public val cosmos.ics23.v1.Proofs.CompressedBatchEntryOrBuilder.nonexistOrNull: cosmos.ics23.v1.Proofs.CompressedNonExistenceProof?
  get() = if (hasNonexist()) getNonexist() else null

