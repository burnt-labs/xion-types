// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               unknown
// source: feeabstraction/feeabs/v1beta1/tx.proto

/* eslint-disable */
import { grpc } from "@improbable-eng/grpc-web";
import { BrowserHeaders } from "browser-headers";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { Params } from "./params";
import { HostChainFeeAbsConfig } from "./proposal";

export const protobufPackage = "feeabstraction.feeabs.v1beta1";

/** MsgFundFeeAbsModuleAccount */
export interface MsgFundFeeAbsModuleAccount {
  /** sender is the that actor that signed the messages */
  sender: string;
  amount: Coin[];
}

/** MsgFundFeeAbsModuleAccountResponse */
export interface MsgFundFeeAbsModuleAccountResponse {
}

/** MsgSendQueryIbcDenomTWAP */
export interface MsgSendQueryIbcDenomTWAP {
  /** Sender is the that actor that signed the messages */
  sender: string;
}

/** MsgSendQueryIbcDenomTWAPResponse */
export interface MsgSendQueryIbcDenomTWAPResponse {
}

/** MsgSwapCrossChain */
export interface MsgSwapCrossChain {
  /** Sender is the that actor that signed the messages */
  sender: string;
  ibcDenom: string;
}

/** MsgSwapCrossChainResponse */
export interface MsgSwapCrossChainResponse {
}

/** MsgUpdateParams is the Msg/UpdateParams request type. */
export interface MsgUpdateParams {
  /** authority is the address of the governance account. */
  authority: string;
  /**
   * params defines the x/feeabs parameters to update.
   *
   * NOTE: All parameters must be supplied.
   */
  params?: Params | undefined;
}

/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 */
export interface MsgUpdateParamsResponse {
}

/** MsgAddHostZone is the Msg/AddHostZone request type. */
export interface MsgAddHostZone {
  /** authority is the address of the governance account. */
  authority: string;
  /** the host chain config */
  hostChainConfig?: HostChainFeeAbsConfig | undefined;
}

/** MsgAddHostZoneResponse */
export interface MsgAddHostZoneResponse {
}

/** MsgUpdateHostZone is the Msg/UpdateHostZone request type. */
export interface MsgUpdateHostZone {
  /** authority is the address of the governance account. */
  authority: string;
  /** the host chain config */
  hostChainConfig?: HostChainFeeAbsConfig | undefined;
}

/** MsgUpdateHostZoneResponse */
export interface MsgUpdateHostZoneResponse {
}

/** MsgRemoveHostZone is the Msg/RemoveHostZone request type. */
export interface MsgRemoveHostZone {
  /** authority is the address of the governance account. */
  authority: string;
  ibcDenom: string;
}

/** MsgRemoveHostZoneResponse */
export interface MsgRemoveHostZoneResponse {
}

function createBaseMsgFundFeeAbsModuleAccount(): MsgFundFeeAbsModuleAccount {
  return { sender: "", amount: [] };
}

export const MsgFundFeeAbsModuleAccount = {
  encode(message: MsgFundFeeAbsModuleAccount, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    for (const v of message.amount) {
      Coin.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgFundFeeAbsModuleAccount {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFundFeeAbsModuleAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount.push(Coin.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgFundFeeAbsModuleAccount {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      amount: globalThis.Array.isArray(object?.amount) ? object.amount.map((e: any) => Coin.fromJSON(e)) : [],
    };
  },

  toJSON(message: MsgFundFeeAbsModuleAccount): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.amount?.length) {
      obj.amount = message.amount.map((e) => Coin.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFundFeeAbsModuleAccount>, I>>(base?: I): MsgFundFeeAbsModuleAccount {
    return MsgFundFeeAbsModuleAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFundFeeAbsModuleAccount>, I>>(object: I): MsgFundFeeAbsModuleAccount {
    const message = createBaseMsgFundFeeAbsModuleAccount();
    message.sender = object.sender ?? "";
    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgFundFeeAbsModuleAccountResponse(): MsgFundFeeAbsModuleAccountResponse {
  return {};
}

export const MsgFundFeeAbsModuleAccountResponse = {
  encode(_: MsgFundFeeAbsModuleAccountResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgFundFeeAbsModuleAccountResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFundFeeAbsModuleAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgFundFeeAbsModuleAccountResponse {
    return {};
  },

  toJSON(_: MsgFundFeeAbsModuleAccountResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFundFeeAbsModuleAccountResponse>, I>>(
    base?: I,
  ): MsgFundFeeAbsModuleAccountResponse {
    return MsgFundFeeAbsModuleAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFundFeeAbsModuleAccountResponse>, I>>(
    _: I,
  ): MsgFundFeeAbsModuleAccountResponse {
    const message = createBaseMsgFundFeeAbsModuleAccountResponse();
    return message;
  },
};

function createBaseMsgSendQueryIbcDenomTWAP(): MsgSendQueryIbcDenomTWAP {
  return { sender: "" };
}

export const MsgSendQueryIbcDenomTWAP = {
  encode(message: MsgSendQueryIbcDenomTWAP, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSendQueryIbcDenomTWAP {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSendQueryIbcDenomTWAP();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSendQueryIbcDenomTWAP {
    return { sender: isSet(object.sender) ? globalThis.String(object.sender) : "" };
  },

  toJSON(message: MsgSendQueryIbcDenomTWAP): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSendQueryIbcDenomTWAP>, I>>(base?: I): MsgSendQueryIbcDenomTWAP {
    return MsgSendQueryIbcDenomTWAP.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSendQueryIbcDenomTWAP>, I>>(object: I): MsgSendQueryIbcDenomTWAP {
    const message = createBaseMsgSendQueryIbcDenomTWAP();
    message.sender = object.sender ?? "";
    return message;
  },
};

function createBaseMsgSendQueryIbcDenomTWAPResponse(): MsgSendQueryIbcDenomTWAPResponse {
  return {};
}

export const MsgSendQueryIbcDenomTWAPResponse = {
  encode(_: MsgSendQueryIbcDenomTWAPResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSendQueryIbcDenomTWAPResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSendQueryIbcDenomTWAPResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSendQueryIbcDenomTWAPResponse {
    return {};
  },

  toJSON(_: MsgSendQueryIbcDenomTWAPResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSendQueryIbcDenomTWAPResponse>, I>>(
    base?: I,
  ): MsgSendQueryIbcDenomTWAPResponse {
    return MsgSendQueryIbcDenomTWAPResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSendQueryIbcDenomTWAPResponse>, I>>(
    _: I,
  ): MsgSendQueryIbcDenomTWAPResponse {
    const message = createBaseMsgSendQueryIbcDenomTWAPResponse();
    return message;
  },
};

function createBaseMsgSwapCrossChain(): MsgSwapCrossChain {
  return { sender: "", ibcDenom: "" };
}

export const MsgSwapCrossChain = {
  encode(message: MsgSwapCrossChain, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.ibcDenom !== "") {
      writer.uint32(18).string(message.ibcDenom);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSwapCrossChain {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSwapCrossChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ibcDenom = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSwapCrossChain {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      ibcDenom: isSet(object.ibcDenom) ? globalThis.String(object.ibcDenom) : "",
    };
  },

  toJSON(message: MsgSwapCrossChain): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.ibcDenom !== "") {
      obj.ibcDenom = message.ibcDenom;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSwapCrossChain>, I>>(base?: I): MsgSwapCrossChain {
    return MsgSwapCrossChain.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSwapCrossChain>, I>>(object: I): MsgSwapCrossChain {
    const message = createBaseMsgSwapCrossChain();
    message.sender = object.sender ?? "";
    message.ibcDenom = object.ibcDenom ?? "";
    return message;
  },
};

function createBaseMsgSwapCrossChainResponse(): MsgSwapCrossChainResponse {
  return {};
}

export const MsgSwapCrossChainResponse = {
  encode(_: MsgSwapCrossChainResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSwapCrossChainResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSwapCrossChainResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSwapCrossChainResponse {
    return {};
  },

  toJSON(_: MsgSwapCrossChainResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSwapCrossChainResponse>, I>>(base?: I): MsgSwapCrossChainResponse {
    return MsgSwapCrossChainResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSwapCrossChainResponse>, I>>(_: I): MsgSwapCrossChainResponse {
    const message = createBaseMsgSwapCrossChainResponse();
    return message;
  },
};

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams = {
  encode(message: MsgUpdateParams, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(base?: I): MsgUpdateParams {
    return MsgUpdateParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(object: I): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse = {
  encode(_: MsgUpdateParamsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(base?: I): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(_: I): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function createBaseMsgAddHostZone(): MsgAddHostZone {
  return { authority: "", hostChainConfig: undefined };
}

export const MsgAddHostZone = {
  encode(message: MsgAddHostZone, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.hostChainConfig !== undefined) {
      HostChainFeeAbsConfig.encode(message.hostChainConfig, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgAddHostZone {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddHostZone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hostChainConfig = HostChainFeeAbsConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAddHostZone {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      hostChainConfig: isSet(object.hostChainConfig)
        ? HostChainFeeAbsConfig.fromJSON(object.hostChainConfig)
        : undefined,
    };
  },

  toJSON(message: MsgAddHostZone): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.hostChainConfig !== undefined) {
      obj.hostChainConfig = HostChainFeeAbsConfig.toJSON(message.hostChainConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAddHostZone>, I>>(base?: I): MsgAddHostZone {
    return MsgAddHostZone.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAddHostZone>, I>>(object: I): MsgAddHostZone {
    const message = createBaseMsgAddHostZone();
    message.authority = object.authority ?? "";
    message.hostChainConfig = (object.hostChainConfig !== undefined && object.hostChainConfig !== null)
      ? HostChainFeeAbsConfig.fromPartial(object.hostChainConfig)
      : undefined;
    return message;
  },
};

function createBaseMsgAddHostZoneResponse(): MsgAddHostZoneResponse {
  return {};
}

export const MsgAddHostZoneResponse = {
  encode(_: MsgAddHostZoneResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgAddHostZoneResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddHostZoneResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgAddHostZoneResponse {
    return {};
  },

  toJSON(_: MsgAddHostZoneResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAddHostZoneResponse>, I>>(base?: I): MsgAddHostZoneResponse {
    return MsgAddHostZoneResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAddHostZoneResponse>, I>>(_: I): MsgAddHostZoneResponse {
    const message = createBaseMsgAddHostZoneResponse();
    return message;
  },
};

function createBaseMsgUpdateHostZone(): MsgUpdateHostZone {
  return { authority: "", hostChainConfig: undefined };
}

export const MsgUpdateHostZone = {
  encode(message: MsgUpdateHostZone, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.hostChainConfig !== undefined) {
      HostChainFeeAbsConfig.encode(message.hostChainConfig, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateHostZone {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateHostZone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hostChainConfig = HostChainFeeAbsConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateHostZone {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      hostChainConfig: isSet(object.hostChainConfig)
        ? HostChainFeeAbsConfig.fromJSON(object.hostChainConfig)
        : undefined,
    };
  },

  toJSON(message: MsgUpdateHostZone): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.hostChainConfig !== undefined) {
      obj.hostChainConfig = HostChainFeeAbsConfig.toJSON(message.hostChainConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateHostZone>, I>>(base?: I): MsgUpdateHostZone {
    return MsgUpdateHostZone.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateHostZone>, I>>(object: I): MsgUpdateHostZone {
    const message = createBaseMsgUpdateHostZone();
    message.authority = object.authority ?? "";
    message.hostChainConfig = (object.hostChainConfig !== undefined && object.hostChainConfig !== null)
      ? HostChainFeeAbsConfig.fromPartial(object.hostChainConfig)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateHostZoneResponse(): MsgUpdateHostZoneResponse {
  return {};
}

export const MsgUpdateHostZoneResponse = {
  encode(_: MsgUpdateHostZoneResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateHostZoneResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateHostZoneResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateHostZoneResponse {
    return {};
  },

  toJSON(_: MsgUpdateHostZoneResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateHostZoneResponse>, I>>(base?: I): MsgUpdateHostZoneResponse {
    return MsgUpdateHostZoneResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateHostZoneResponse>, I>>(_: I): MsgUpdateHostZoneResponse {
    const message = createBaseMsgUpdateHostZoneResponse();
    return message;
  },
};

function createBaseMsgRemoveHostZone(): MsgRemoveHostZone {
  return { authority: "", ibcDenom: "" };
}

export const MsgRemoveHostZone = {
  encode(message: MsgRemoveHostZone, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.ibcDenom !== "") {
      writer.uint32(18).string(message.ibcDenom);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgRemoveHostZone {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveHostZone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ibcDenom = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRemoveHostZone {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      ibcDenom: isSet(object.ibcDenom) ? globalThis.String(object.ibcDenom) : "",
    };
  },

  toJSON(message: MsgRemoveHostZone): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.ibcDenom !== "") {
      obj.ibcDenom = message.ibcDenom;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRemoveHostZone>, I>>(base?: I): MsgRemoveHostZone {
    return MsgRemoveHostZone.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRemoveHostZone>, I>>(object: I): MsgRemoveHostZone {
    const message = createBaseMsgRemoveHostZone();
    message.authority = object.authority ?? "";
    message.ibcDenom = object.ibcDenom ?? "";
    return message;
  },
};

function createBaseMsgRemoveHostZoneResponse(): MsgRemoveHostZoneResponse {
  return {};
}

export const MsgRemoveHostZoneResponse = {
  encode(_: MsgRemoveHostZoneResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgRemoveHostZoneResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveHostZoneResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRemoveHostZoneResponse {
    return {};
  },

  toJSON(_: MsgRemoveHostZoneResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRemoveHostZoneResponse>, I>>(base?: I): MsgRemoveHostZoneResponse {
    return MsgRemoveHostZoneResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRemoveHostZoneResponse>, I>>(_: I): MsgRemoveHostZoneResponse {
    const message = createBaseMsgRemoveHostZoneResponse();
    return message;
  },
};

/** Msg defines the wasm Msg service. */
export interface Msg {
  /** SendQueryIbcDenomTWAP sends a twap query to osmosis */
  SendQueryIbcDenomTWAP(
    request: DeepPartial<MsgSendQueryIbcDenomTWAP>,
    metadata?: grpc.Metadata,
  ): Promise<MsgSendQueryIbcDenomTWAPResponse>;
  /** SwapCrossChain submits a swap cross chain request. */
  SwapCrossChain(request: DeepPartial<MsgSwapCrossChain>, metadata?: grpc.Metadata): Promise<MsgSwapCrossChainResponse>;
  /** FundFeeAbsModuleAccount funds to feeabs module account. */
  FundFeeAbsModuleAccount(
    request: DeepPartial<MsgFundFeeAbsModuleAccount>,
    metadata?: grpc.Metadata,
  ): Promise<MsgFundFeeAbsModuleAccountResponse>;
  /**
   * UpdateParams defines a governance operation for updating the x/feeabs
   * module parameters. The authority is defined in the keeper.
   */
  UpdateParams(request: DeepPartial<MsgUpdateParams>, metadata?: grpc.Metadata): Promise<MsgUpdateParamsResponse>;
  AddHostZone(request: DeepPartial<MsgAddHostZone>, metadata?: grpc.Metadata): Promise<MsgAddHostZoneResponse>;
  UpdateHostZone(request: DeepPartial<MsgUpdateHostZone>, metadata?: grpc.Metadata): Promise<MsgUpdateHostZoneResponse>;
  RemoveHostZone(request: DeepPartial<MsgRemoveHostZone>, metadata?: grpc.Metadata): Promise<MsgRemoveHostZoneResponse>;
}

export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.SendQueryIbcDenomTWAP = this.SendQueryIbcDenomTWAP.bind(this);
    this.SwapCrossChain = this.SwapCrossChain.bind(this);
    this.FundFeeAbsModuleAccount = this.FundFeeAbsModuleAccount.bind(this);
    this.UpdateParams = this.UpdateParams.bind(this);
    this.AddHostZone = this.AddHostZone.bind(this);
    this.UpdateHostZone = this.UpdateHostZone.bind(this);
    this.RemoveHostZone = this.RemoveHostZone.bind(this);
  }

  SendQueryIbcDenomTWAP(
    request: DeepPartial<MsgSendQueryIbcDenomTWAP>,
    metadata?: grpc.Metadata,
  ): Promise<MsgSendQueryIbcDenomTWAPResponse> {
    return this.rpc.unary(MsgSendQueryIbcDenomTWAPDesc, MsgSendQueryIbcDenomTWAP.fromPartial(request), metadata);
  }

  SwapCrossChain(
    request: DeepPartial<MsgSwapCrossChain>,
    metadata?: grpc.Metadata,
  ): Promise<MsgSwapCrossChainResponse> {
    return this.rpc.unary(MsgSwapCrossChainDesc, MsgSwapCrossChain.fromPartial(request), metadata);
  }

  FundFeeAbsModuleAccount(
    request: DeepPartial<MsgFundFeeAbsModuleAccount>,
    metadata?: grpc.Metadata,
  ): Promise<MsgFundFeeAbsModuleAccountResponse> {
    return this.rpc.unary(MsgFundFeeAbsModuleAccountDesc, MsgFundFeeAbsModuleAccount.fromPartial(request), metadata);
  }

  UpdateParams(request: DeepPartial<MsgUpdateParams>, metadata?: grpc.Metadata): Promise<MsgUpdateParamsResponse> {
    return this.rpc.unary(MsgUpdateParamsDesc, MsgUpdateParams.fromPartial(request), metadata);
  }

  AddHostZone(request: DeepPartial<MsgAddHostZone>, metadata?: grpc.Metadata): Promise<MsgAddHostZoneResponse> {
    return this.rpc.unary(MsgAddHostZoneDesc, MsgAddHostZone.fromPartial(request), metadata);
  }

  UpdateHostZone(
    request: DeepPartial<MsgUpdateHostZone>,
    metadata?: grpc.Metadata,
  ): Promise<MsgUpdateHostZoneResponse> {
    return this.rpc.unary(MsgUpdateHostZoneDesc, MsgUpdateHostZone.fromPartial(request), metadata);
  }

  RemoveHostZone(
    request: DeepPartial<MsgRemoveHostZone>,
    metadata?: grpc.Metadata,
  ): Promise<MsgRemoveHostZoneResponse> {
    return this.rpc.unary(MsgRemoveHostZoneDesc, MsgRemoveHostZone.fromPartial(request), metadata);
  }
}

export const MsgDesc = { serviceName: "feeabstraction.feeabs.v1beta1.Msg" };

export const MsgSendQueryIbcDenomTWAPDesc: UnaryMethodDefinitionish = {
  methodName: "SendQueryIbcDenomTWAP",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgSendQueryIbcDenomTWAP.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgSendQueryIbcDenomTWAPResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgSwapCrossChainDesc: UnaryMethodDefinitionish = {
  methodName: "SwapCrossChain",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgSwapCrossChain.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgSwapCrossChainResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgFundFeeAbsModuleAccountDesc: UnaryMethodDefinitionish = {
  methodName: "FundFeeAbsModuleAccount",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgFundFeeAbsModuleAccount.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgFundFeeAbsModuleAccountResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgUpdateParamsDesc: UnaryMethodDefinitionish = {
  methodName: "UpdateParams",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgUpdateParams.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgUpdateParamsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgAddHostZoneDesc: UnaryMethodDefinitionish = {
  methodName: "AddHostZone",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgAddHostZone.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgAddHostZoneResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgUpdateHostZoneDesc: UnaryMethodDefinitionish = {
  methodName: "UpdateHostZone",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgUpdateHostZone.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgUpdateHostZoneResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const MsgRemoveHostZoneDesc: UnaryMethodDefinitionish = {
  methodName: "RemoveHostZone",
  service: MsgDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return MsgRemoveHostZone.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = MsgRemoveHostZoneResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata ?? this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata ?? {},
        ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
        debug: this.options.debug ?? false,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends globalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}
