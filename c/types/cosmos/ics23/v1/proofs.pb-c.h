/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: cosmos/ics23/v1/proofs.proto */

#ifndef PROTOBUF_C_cosmos_2fics23_2fv1_2fproofs_2eproto__INCLUDED
#define PROTOBUF_C_cosmos_2fics23_2fv1_2fproofs_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protobuf-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1005002 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protobuf-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protobuf-c.
#endif


typedef struct Cosmos__Ics23__V1__ExistenceProof Cosmos__Ics23__V1__ExistenceProof;
typedef struct Cosmos__Ics23__V1__NonExistenceProof Cosmos__Ics23__V1__NonExistenceProof;
typedef struct Cosmos__Ics23__V1__CommitmentProof Cosmos__Ics23__V1__CommitmentProof;
typedef struct Cosmos__Ics23__V1__LeafOp Cosmos__Ics23__V1__LeafOp;
typedef struct Cosmos__Ics23__V1__InnerOp Cosmos__Ics23__V1__InnerOp;
typedef struct Cosmos__Ics23__V1__ProofSpec Cosmos__Ics23__V1__ProofSpec;
typedef struct Cosmos__Ics23__V1__InnerSpec Cosmos__Ics23__V1__InnerSpec;
typedef struct Cosmos__Ics23__V1__BatchProof Cosmos__Ics23__V1__BatchProof;
typedef struct Cosmos__Ics23__V1__BatchEntry Cosmos__Ics23__V1__BatchEntry;
typedef struct Cosmos__Ics23__V1__CompressedBatchProof Cosmos__Ics23__V1__CompressedBatchProof;
typedef struct Cosmos__Ics23__V1__CompressedBatchEntry Cosmos__Ics23__V1__CompressedBatchEntry;
typedef struct Cosmos__Ics23__V1__CompressedExistenceProof Cosmos__Ics23__V1__CompressedExistenceProof;
typedef struct Cosmos__Ics23__V1__CompressedNonExistenceProof Cosmos__Ics23__V1__CompressedNonExistenceProof;


/* --- enums --- */

typedef enum _Cosmos__Ics23__V1__HashOp {
  /*
   * NO_HASH is the default if no data passed. Note this is an illegal argument some places.
   */
  COSMOS__ICS23__V1__HASH_OP__NO_HASH = 0,
  COSMOS__ICS23__V1__HASH_OP__SHA256 = 1,
  COSMOS__ICS23__V1__HASH_OP__SHA512 = 2,
  COSMOS__ICS23__V1__HASH_OP__KECCAK = 3,
  COSMOS__ICS23__V1__HASH_OP__RIPEMD160 = 4,
  /*
   * ripemd160(sha256(x))
   */
  COSMOS__ICS23__V1__HASH_OP__BITCOIN = 5,
  COSMOS__ICS23__V1__HASH_OP__SHA512_256 = 6
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COSMOS__ICS23__V1__HASH_OP)
} Cosmos__Ics23__V1__HashOp;
/*
 **
 *LengthOp defines how to process the key and value of the LeafOp
 *to include length information. After encoding the length with the given
 *algorithm, the length will be prepended to the key and value bytes.
 *(Each one with it's own encoded length)
 */
typedef enum _Cosmos__Ics23__V1__LengthOp {
  /*
   * NO_PREFIX don't include any length info
   */
  COSMOS__ICS23__V1__LENGTH_OP__NO_PREFIX = 0,
  /*
   * VAR_PROTO uses protobuf (and go-amino) varint encoding of the length
   */
  COSMOS__ICS23__V1__LENGTH_OP__VAR_PROTO = 1,
  /*
   * VAR_RLP uses rlp int encoding of the length
   */
  COSMOS__ICS23__V1__LENGTH_OP__VAR_RLP = 2,
  /*
   * FIXED32_BIG uses big-endian encoding of the length as a 32 bit integer
   */
  COSMOS__ICS23__V1__LENGTH_OP__FIXED32_BIG = 3,
  /*
   * FIXED32_LITTLE uses little-endian encoding of the length as a 32 bit integer
   */
  COSMOS__ICS23__V1__LENGTH_OP__FIXED32_LITTLE = 4,
  /*
   * FIXED64_BIG uses big-endian encoding of the length as a 64 bit integer
   */
  COSMOS__ICS23__V1__LENGTH_OP__FIXED64_BIG = 5,
  /*
   * FIXED64_LITTLE uses little-endian encoding of the length as a 64 bit integer
   */
  COSMOS__ICS23__V1__LENGTH_OP__FIXED64_LITTLE = 6,
  /*
   * REQUIRE_32_BYTES is like NONE, but will fail if the input is not exactly 32 bytes (sha256 output)
   */
  COSMOS__ICS23__V1__LENGTH_OP__REQUIRE_32_BYTES = 7,
  /*
   * REQUIRE_64_BYTES is like NONE, but will fail if the input is not exactly 64 bytes (sha512 output)
   */
  COSMOS__ICS23__V1__LENGTH_OP__REQUIRE_64_BYTES = 8
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COSMOS__ICS23__V1__LENGTH_OP)
} Cosmos__Ics23__V1__LengthOp;

/* --- messages --- */

/*
 **
 *ExistenceProof takes a key and a value and a set of steps to perform on it.
 *The result of peforming all these steps will provide a "root hash", which can
 *be compared to the value in a header.
 *Since it is computationally infeasible to produce a hash collission for any of the used
 *cryptographic hash functions, if someone can provide a series of operations to transform
 *a given key and value into a root hash that matches some trusted root, these key and values
 *must be in the referenced merkle tree.
 *The only possible issue is maliablity in LeafOp, such as providing extra prefix data,
 *which should be controlled by a spec. Eg. with lengthOp as NONE,
 *prefix = FOO, key = BAR, value = CHOICE
 *and
 *prefix = F, key = OOBAR, value = CHOICE
 *would produce the same value.
 *With LengthOp this is tricker but not impossible. Which is why the "leafPrefixEqual" field
 *in the ProofSpec is valuable to prevent this mutability. And why all trees should
 *length-prefix the data before hashing it.
 */
struct  Cosmos__Ics23__V1__ExistenceProof
{
  ProtobufCMessage base;
  ProtobufCBinaryData key;
  ProtobufCBinaryData value;
  Cosmos__Ics23__V1__LeafOp *leaf;
  size_t n_path;
  Cosmos__Ics23__V1__InnerOp **path;
};
#define COSMOS__ICS23__V1__EXISTENCE_PROOF__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__ics23__v1__existence_proof__descriptor) \
, {0,NULL}, {0,NULL}, NULL, 0,NULL }


/*
 *NonExistenceProof takes a proof of two neighbors, one left of the desired key,
 *one right of the desired key. If both proofs are valid AND they are neighbors,
 *then there is no valid proof for the given key.
 */
struct  Cosmos__Ics23__V1__NonExistenceProof
{
  ProtobufCMessage base;
  /*
   * TODO: remove this as unnecessary??? we prove a range
   */
  ProtobufCBinaryData key;
  Cosmos__Ics23__V1__ExistenceProof *left;
  Cosmos__Ics23__V1__ExistenceProof *right;
};
#define COSMOS__ICS23__V1__NON_EXISTENCE_PROOF__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__ics23__v1__non_existence_proof__descriptor) \
, {0,NULL}, NULL, NULL }


typedef enum {
  COSMOS__ICS23__V1__COMMITMENT_PROOF__PROOF__NOT_SET = 0,
  COSMOS__ICS23__V1__COMMITMENT_PROOF__PROOF_EXIST = 1,
  COSMOS__ICS23__V1__COMMITMENT_PROOF__PROOF_NONEXIST = 2,
  COSMOS__ICS23__V1__COMMITMENT_PROOF__PROOF_BATCH = 3,
  COSMOS__ICS23__V1__COMMITMENT_PROOF__PROOF_COMPRESSED = 4
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COSMOS__ICS23__V1__COMMITMENT_PROOF__PROOF__CASE)
} Cosmos__Ics23__V1__CommitmentProof__ProofCase;

/*
 *CommitmentProof is either an ExistenceProof or a NonExistenceProof, or a Batch of such messages
 */
struct  Cosmos__Ics23__V1__CommitmentProof
{
  ProtobufCMessage base;
  Cosmos__Ics23__V1__CommitmentProof__ProofCase proof_case;
  union {
    Cosmos__Ics23__V1__BatchProof *batch;
    Cosmos__Ics23__V1__CompressedBatchProof *compressed;
    Cosmos__Ics23__V1__ExistenceProof *exist;
    Cosmos__Ics23__V1__NonExistenceProof *nonexist;
  };
};
#define COSMOS__ICS23__V1__COMMITMENT_PROOF__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__ics23__v1__commitment_proof__descriptor) \
, COSMOS__ICS23__V1__COMMITMENT_PROOF__PROOF__NOT_SET, {0} }


/*
 **
 *LeafOp represents the raw key-value data we wish to prove, and
 *must be flexible to represent the internal transformation from
 *the original key-value pairs into the basis hash, for many existing
 *merkle trees.
 *key and value are passed in. So that the signature of this operation is:
 *leafOp(key, value) -> output
 *To process this, first prehash the keys and values if needed (ANY means no hash in this case):
 *hkey = prehashKey(key)
 *hvalue = prehashValue(value)
 *Then combine the bytes, and hash it
 *output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue)
 */
struct  Cosmos__Ics23__V1__LeafOp
{
  ProtobufCMessage base;
  Cosmos__Ics23__V1__HashOp hash;
  Cosmos__Ics23__V1__HashOp prehash_key;
  Cosmos__Ics23__V1__HashOp prehash_value;
  Cosmos__Ics23__V1__LengthOp length;
  /*
   * prefix is a fixed bytes that may optionally be included at the beginning to differentiate
   * a leaf node from an inner node.
   */
  ProtobufCBinaryData prefix;
};
#define COSMOS__ICS23__V1__LEAF_OP__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__ics23__v1__leaf_op__descriptor) \
, COSMOS__ICS23__V1__HASH_OP__NO_HASH, COSMOS__ICS23__V1__HASH_OP__NO_HASH, COSMOS__ICS23__V1__HASH_OP__NO_HASH, COSMOS__ICS23__V1__LENGTH_OP__NO_PREFIX, {0,NULL} }


/*
 **
 *InnerOp represents a merkle-proof step that is not a leaf.
 *It represents concatenating two children and hashing them to provide the next result.
 *The result of the previous step is passed in, so the signature of this op is:
 *innerOp(child) -> output
 *The result of applying InnerOp should be:
 *output = op.hash(op.prefix || child || op.suffix)
 *where the || operator is concatenation of binary data,
 *and child is the result of hashing all the tree below this step.
 *Any special data, like prepending child with the length, or prepending the entire operation with
 *some value to differentiate from leaf nodes, should be included in prefix and suffix.
 *If either of prefix or suffix is empty, we just treat it as an empty string
 */
struct  Cosmos__Ics23__V1__InnerOp
{
  ProtobufCMessage base;
  Cosmos__Ics23__V1__HashOp hash;
  ProtobufCBinaryData prefix;
  ProtobufCBinaryData suffix;
};
#define COSMOS__ICS23__V1__INNER_OP__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__ics23__v1__inner_op__descriptor) \
, COSMOS__ICS23__V1__HASH_OP__NO_HASH, {0,NULL}, {0,NULL} }


/*
 **
 *ProofSpec defines what the expected parameters are for a given proof type.
 *This can be stored in the client and used to validate any incoming proofs.
 *verify(ProofSpec, Proof) -> Proof | Error
 *As demonstrated in tests, if we don't fix the algorithm used to calculate the
 *LeafHash for a given tree, there are many possible key-value pairs that can
 *generate a given hash (by interpretting the preimage differently).
 *We need this for proper security, requires client knows a priori what
 *tree format server uses. But not in code, rather a configuration object.
 */
struct  Cosmos__Ics23__V1__ProofSpec
{
  ProtobufCMessage base;
  /*
   * any field in the ExistenceProof must be the same as in this spec.
   * except Prefix, which is just the first bytes of prefix (spec can be longer)
   */
  Cosmos__Ics23__V1__LeafOp *leaf_spec;
  Cosmos__Ics23__V1__InnerSpec *inner_spec;
  /*
   * max_depth (if > 0) is the maximum number of InnerOps allowed (mainly for fixed-depth tries)
   */
  int32_t max_depth;
  /*
   * min_depth (if > 0) is the minimum number of InnerOps allowed (mainly for fixed-depth tries)
   */
  int32_t min_depth;
};
#define COSMOS__ICS23__V1__PROOF_SPEC__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__ics23__v1__proof_spec__descriptor) \
, NULL, NULL, 0, 0 }


/*
 *InnerSpec contains all store-specific structure info to determine if two proofs from a
 *given store are neighbors.
 *This enables:
 *isLeftMost(spec: InnerSpec, op: InnerOp)
 *isRightMost(spec: InnerSpec, op: InnerOp)
 *isLeftNeighbor(spec: InnerSpec, left: InnerOp, right: InnerOp)
 */
struct  Cosmos__Ics23__V1__InnerSpec
{
  ProtobufCMessage base;
  /*
   * Child order is the ordering of the children node, must count from 0
   * iavl tree is [0, 1] (left then right)
   * merk is [0, 2, 1] (left, right, here)
   */
  size_t n_child_order;
  int32_t *child_order;
  int32_t child_size;
  int32_t min_prefix_length;
  int32_t max_prefix_length;
  /*
   * empty child is the prehash image that is used when one child is nil (eg. 20 bytes of 0)
   */
  ProtobufCBinaryData empty_child;
  /*
   * hash is the algorithm that must be used for each InnerOp
   */
  Cosmos__Ics23__V1__HashOp hash;
};
#define COSMOS__ICS23__V1__INNER_SPEC__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__ics23__v1__inner_spec__descriptor) \
, 0,NULL, 0, 0, 0, {0,NULL}, COSMOS__ICS23__V1__HASH_OP__NO_HASH }


/*
 *BatchProof is a group of multiple proof types than can be compressed
 */
struct  Cosmos__Ics23__V1__BatchProof
{
  ProtobufCMessage base;
  size_t n_entries;
  Cosmos__Ics23__V1__BatchEntry **entries;
};
#define COSMOS__ICS23__V1__BATCH_PROOF__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__ics23__v1__batch_proof__descriptor) \
, 0,NULL }


typedef enum {
  COSMOS__ICS23__V1__BATCH_ENTRY__PROOF__NOT_SET = 0,
  COSMOS__ICS23__V1__BATCH_ENTRY__PROOF_EXIST = 1,
  COSMOS__ICS23__V1__BATCH_ENTRY__PROOF_NONEXIST = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COSMOS__ICS23__V1__BATCH_ENTRY__PROOF__CASE)
} Cosmos__Ics23__V1__BatchEntry__ProofCase;

/*
 * Use BatchEntry not CommitmentProof, to avoid recursion
 */
struct  Cosmos__Ics23__V1__BatchEntry
{
  ProtobufCMessage base;
  Cosmos__Ics23__V1__BatchEntry__ProofCase proof_case;
  union {
    Cosmos__Ics23__V1__ExistenceProof *exist;
    Cosmos__Ics23__V1__NonExistenceProof *nonexist;
  };
};
#define COSMOS__ICS23__V1__BATCH_ENTRY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__ics23__v1__batch_entry__descriptor) \
, COSMOS__ICS23__V1__BATCH_ENTRY__PROOF__NOT_SET, {0} }


struct  Cosmos__Ics23__V1__CompressedBatchProof
{
  ProtobufCMessage base;
  size_t n_entries;
  Cosmos__Ics23__V1__CompressedBatchEntry **entries;
  size_t n_lookup_inners;
  Cosmos__Ics23__V1__InnerOp **lookup_inners;
};
#define COSMOS__ICS23__V1__COMPRESSED_BATCH_PROOF__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__ics23__v1__compressed_batch_proof__descriptor) \
, 0,NULL, 0,NULL }


typedef enum {
  COSMOS__ICS23__V1__COMPRESSED_BATCH_ENTRY__PROOF__NOT_SET = 0,
  COSMOS__ICS23__V1__COMPRESSED_BATCH_ENTRY__PROOF_EXIST = 1,
  COSMOS__ICS23__V1__COMPRESSED_BATCH_ENTRY__PROOF_NONEXIST = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COSMOS__ICS23__V1__COMPRESSED_BATCH_ENTRY__PROOF__CASE)
} Cosmos__Ics23__V1__CompressedBatchEntry__ProofCase;

/*
 * Use BatchEntry not CommitmentProof, to avoid recursion
 */
struct  Cosmos__Ics23__V1__CompressedBatchEntry
{
  ProtobufCMessage base;
  Cosmos__Ics23__V1__CompressedBatchEntry__ProofCase proof_case;
  union {
    Cosmos__Ics23__V1__CompressedExistenceProof *exist;
    Cosmos__Ics23__V1__CompressedNonExistenceProof *nonexist;
  };
};
#define COSMOS__ICS23__V1__COMPRESSED_BATCH_ENTRY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__ics23__v1__compressed_batch_entry__descriptor) \
, COSMOS__ICS23__V1__COMPRESSED_BATCH_ENTRY__PROOF__NOT_SET, {0} }


struct  Cosmos__Ics23__V1__CompressedExistenceProof
{
  ProtobufCMessage base;
  ProtobufCBinaryData key;
  ProtobufCBinaryData value;
  Cosmos__Ics23__V1__LeafOp *leaf;
  /*
   * these are indexes into the lookup_inners table in CompressedBatchProof
   */
  size_t n_path;
  int32_t *path;
};
#define COSMOS__ICS23__V1__COMPRESSED_EXISTENCE_PROOF__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__ics23__v1__compressed_existence_proof__descriptor) \
, {0,NULL}, {0,NULL}, NULL, 0,NULL }


struct  Cosmos__Ics23__V1__CompressedNonExistenceProof
{
  ProtobufCMessage base;
  /*
   * TODO: remove this as unnecessary??? we prove a range
   */
  ProtobufCBinaryData key;
  Cosmos__Ics23__V1__CompressedExistenceProof *left;
  Cosmos__Ics23__V1__CompressedExistenceProof *right;
};
#define COSMOS__ICS23__V1__COMPRESSED_NON_EXISTENCE_PROOF__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&cosmos__ics23__v1__compressed_non_existence_proof__descriptor) \
, {0,NULL}, NULL, NULL }


/* Cosmos__Ics23__V1__ExistenceProof methods */
void   cosmos__ics23__v1__existence_proof__init
                     (Cosmos__Ics23__V1__ExistenceProof         *message);
size_t cosmos__ics23__v1__existence_proof__get_packed_size
                     (const Cosmos__Ics23__V1__ExistenceProof   *message);
size_t cosmos__ics23__v1__existence_proof__pack
                     (const Cosmos__Ics23__V1__ExistenceProof   *message,
                      uint8_t             *out);
size_t cosmos__ics23__v1__existence_proof__pack_to_buffer
                     (const Cosmos__Ics23__V1__ExistenceProof   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Ics23__V1__ExistenceProof *
       cosmos__ics23__v1__existence_proof__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__ics23__v1__existence_proof__free_unpacked
                     (Cosmos__Ics23__V1__ExistenceProof *message,
                      ProtobufCAllocator *allocator);
/* Cosmos__Ics23__V1__NonExistenceProof methods */
void   cosmos__ics23__v1__non_existence_proof__init
                     (Cosmos__Ics23__V1__NonExistenceProof         *message);
size_t cosmos__ics23__v1__non_existence_proof__get_packed_size
                     (const Cosmos__Ics23__V1__NonExistenceProof   *message);
size_t cosmos__ics23__v1__non_existence_proof__pack
                     (const Cosmos__Ics23__V1__NonExistenceProof   *message,
                      uint8_t             *out);
size_t cosmos__ics23__v1__non_existence_proof__pack_to_buffer
                     (const Cosmos__Ics23__V1__NonExistenceProof   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Ics23__V1__NonExistenceProof *
       cosmos__ics23__v1__non_existence_proof__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__ics23__v1__non_existence_proof__free_unpacked
                     (Cosmos__Ics23__V1__NonExistenceProof *message,
                      ProtobufCAllocator *allocator);
/* Cosmos__Ics23__V1__CommitmentProof methods */
void   cosmos__ics23__v1__commitment_proof__init
                     (Cosmos__Ics23__V1__CommitmentProof         *message);
size_t cosmos__ics23__v1__commitment_proof__get_packed_size
                     (const Cosmos__Ics23__V1__CommitmentProof   *message);
size_t cosmos__ics23__v1__commitment_proof__pack
                     (const Cosmos__Ics23__V1__CommitmentProof   *message,
                      uint8_t             *out);
size_t cosmos__ics23__v1__commitment_proof__pack_to_buffer
                     (const Cosmos__Ics23__V1__CommitmentProof   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Ics23__V1__CommitmentProof *
       cosmos__ics23__v1__commitment_proof__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__ics23__v1__commitment_proof__free_unpacked
                     (Cosmos__Ics23__V1__CommitmentProof *message,
                      ProtobufCAllocator *allocator);
/* Cosmos__Ics23__V1__LeafOp methods */
void   cosmos__ics23__v1__leaf_op__init
                     (Cosmos__Ics23__V1__LeafOp         *message);
size_t cosmos__ics23__v1__leaf_op__get_packed_size
                     (const Cosmos__Ics23__V1__LeafOp   *message);
size_t cosmos__ics23__v1__leaf_op__pack
                     (const Cosmos__Ics23__V1__LeafOp   *message,
                      uint8_t             *out);
size_t cosmos__ics23__v1__leaf_op__pack_to_buffer
                     (const Cosmos__Ics23__V1__LeafOp   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Ics23__V1__LeafOp *
       cosmos__ics23__v1__leaf_op__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__ics23__v1__leaf_op__free_unpacked
                     (Cosmos__Ics23__V1__LeafOp *message,
                      ProtobufCAllocator *allocator);
/* Cosmos__Ics23__V1__InnerOp methods */
void   cosmos__ics23__v1__inner_op__init
                     (Cosmos__Ics23__V1__InnerOp         *message);
size_t cosmos__ics23__v1__inner_op__get_packed_size
                     (const Cosmos__Ics23__V1__InnerOp   *message);
size_t cosmos__ics23__v1__inner_op__pack
                     (const Cosmos__Ics23__V1__InnerOp   *message,
                      uint8_t             *out);
size_t cosmos__ics23__v1__inner_op__pack_to_buffer
                     (const Cosmos__Ics23__V1__InnerOp   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Ics23__V1__InnerOp *
       cosmos__ics23__v1__inner_op__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__ics23__v1__inner_op__free_unpacked
                     (Cosmos__Ics23__V1__InnerOp *message,
                      ProtobufCAllocator *allocator);
/* Cosmos__Ics23__V1__ProofSpec methods */
void   cosmos__ics23__v1__proof_spec__init
                     (Cosmos__Ics23__V1__ProofSpec         *message);
size_t cosmos__ics23__v1__proof_spec__get_packed_size
                     (const Cosmos__Ics23__V1__ProofSpec   *message);
size_t cosmos__ics23__v1__proof_spec__pack
                     (const Cosmos__Ics23__V1__ProofSpec   *message,
                      uint8_t             *out);
size_t cosmos__ics23__v1__proof_spec__pack_to_buffer
                     (const Cosmos__Ics23__V1__ProofSpec   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Ics23__V1__ProofSpec *
       cosmos__ics23__v1__proof_spec__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__ics23__v1__proof_spec__free_unpacked
                     (Cosmos__Ics23__V1__ProofSpec *message,
                      ProtobufCAllocator *allocator);
/* Cosmos__Ics23__V1__InnerSpec methods */
void   cosmos__ics23__v1__inner_spec__init
                     (Cosmos__Ics23__V1__InnerSpec         *message);
size_t cosmos__ics23__v1__inner_spec__get_packed_size
                     (const Cosmos__Ics23__V1__InnerSpec   *message);
size_t cosmos__ics23__v1__inner_spec__pack
                     (const Cosmos__Ics23__V1__InnerSpec   *message,
                      uint8_t             *out);
size_t cosmos__ics23__v1__inner_spec__pack_to_buffer
                     (const Cosmos__Ics23__V1__InnerSpec   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Ics23__V1__InnerSpec *
       cosmos__ics23__v1__inner_spec__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__ics23__v1__inner_spec__free_unpacked
                     (Cosmos__Ics23__V1__InnerSpec *message,
                      ProtobufCAllocator *allocator);
/* Cosmos__Ics23__V1__BatchProof methods */
void   cosmos__ics23__v1__batch_proof__init
                     (Cosmos__Ics23__V1__BatchProof         *message);
size_t cosmos__ics23__v1__batch_proof__get_packed_size
                     (const Cosmos__Ics23__V1__BatchProof   *message);
size_t cosmos__ics23__v1__batch_proof__pack
                     (const Cosmos__Ics23__V1__BatchProof   *message,
                      uint8_t             *out);
size_t cosmos__ics23__v1__batch_proof__pack_to_buffer
                     (const Cosmos__Ics23__V1__BatchProof   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Ics23__V1__BatchProof *
       cosmos__ics23__v1__batch_proof__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__ics23__v1__batch_proof__free_unpacked
                     (Cosmos__Ics23__V1__BatchProof *message,
                      ProtobufCAllocator *allocator);
/* Cosmos__Ics23__V1__BatchEntry methods */
void   cosmos__ics23__v1__batch_entry__init
                     (Cosmos__Ics23__V1__BatchEntry         *message);
size_t cosmos__ics23__v1__batch_entry__get_packed_size
                     (const Cosmos__Ics23__V1__BatchEntry   *message);
size_t cosmos__ics23__v1__batch_entry__pack
                     (const Cosmos__Ics23__V1__BatchEntry   *message,
                      uint8_t             *out);
size_t cosmos__ics23__v1__batch_entry__pack_to_buffer
                     (const Cosmos__Ics23__V1__BatchEntry   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Ics23__V1__BatchEntry *
       cosmos__ics23__v1__batch_entry__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__ics23__v1__batch_entry__free_unpacked
                     (Cosmos__Ics23__V1__BatchEntry *message,
                      ProtobufCAllocator *allocator);
/* Cosmos__Ics23__V1__CompressedBatchProof methods */
void   cosmos__ics23__v1__compressed_batch_proof__init
                     (Cosmos__Ics23__V1__CompressedBatchProof         *message);
size_t cosmos__ics23__v1__compressed_batch_proof__get_packed_size
                     (const Cosmos__Ics23__V1__CompressedBatchProof   *message);
size_t cosmos__ics23__v1__compressed_batch_proof__pack
                     (const Cosmos__Ics23__V1__CompressedBatchProof   *message,
                      uint8_t             *out);
size_t cosmos__ics23__v1__compressed_batch_proof__pack_to_buffer
                     (const Cosmos__Ics23__V1__CompressedBatchProof   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Ics23__V1__CompressedBatchProof *
       cosmos__ics23__v1__compressed_batch_proof__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__ics23__v1__compressed_batch_proof__free_unpacked
                     (Cosmos__Ics23__V1__CompressedBatchProof *message,
                      ProtobufCAllocator *allocator);
/* Cosmos__Ics23__V1__CompressedBatchEntry methods */
void   cosmos__ics23__v1__compressed_batch_entry__init
                     (Cosmos__Ics23__V1__CompressedBatchEntry         *message);
size_t cosmos__ics23__v1__compressed_batch_entry__get_packed_size
                     (const Cosmos__Ics23__V1__CompressedBatchEntry   *message);
size_t cosmos__ics23__v1__compressed_batch_entry__pack
                     (const Cosmos__Ics23__V1__CompressedBatchEntry   *message,
                      uint8_t             *out);
size_t cosmos__ics23__v1__compressed_batch_entry__pack_to_buffer
                     (const Cosmos__Ics23__V1__CompressedBatchEntry   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Ics23__V1__CompressedBatchEntry *
       cosmos__ics23__v1__compressed_batch_entry__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__ics23__v1__compressed_batch_entry__free_unpacked
                     (Cosmos__Ics23__V1__CompressedBatchEntry *message,
                      ProtobufCAllocator *allocator);
/* Cosmos__Ics23__V1__CompressedExistenceProof methods */
void   cosmos__ics23__v1__compressed_existence_proof__init
                     (Cosmos__Ics23__V1__CompressedExistenceProof         *message);
size_t cosmos__ics23__v1__compressed_existence_proof__get_packed_size
                     (const Cosmos__Ics23__V1__CompressedExistenceProof   *message);
size_t cosmos__ics23__v1__compressed_existence_proof__pack
                     (const Cosmos__Ics23__V1__CompressedExistenceProof   *message,
                      uint8_t             *out);
size_t cosmos__ics23__v1__compressed_existence_proof__pack_to_buffer
                     (const Cosmos__Ics23__V1__CompressedExistenceProof   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Ics23__V1__CompressedExistenceProof *
       cosmos__ics23__v1__compressed_existence_proof__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__ics23__v1__compressed_existence_proof__free_unpacked
                     (Cosmos__Ics23__V1__CompressedExistenceProof *message,
                      ProtobufCAllocator *allocator);
/* Cosmos__Ics23__V1__CompressedNonExistenceProof methods */
void   cosmos__ics23__v1__compressed_non_existence_proof__init
                     (Cosmos__Ics23__V1__CompressedNonExistenceProof         *message);
size_t cosmos__ics23__v1__compressed_non_existence_proof__get_packed_size
                     (const Cosmos__Ics23__V1__CompressedNonExistenceProof   *message);
size_t cosmos__ics23__v1__compressed_non_existence_proof__pack
                     (const Cosmos__Ics23__V1__CompressedNonExistenceProof   *message,
                      uint8_t             *out);
size_t cosmos__ics23__v1__compressed_non_existence_proof__pack_to_buffer
                     (const Cosmos__Ics23__V1__CompressedNonExistenceProof   *message,
                      ProtobufCBuffer     *buffer);
Cosmos__Ics23__V1__CompressedNonExistenceProof *
       cosmos__ics23__v1__compressed_non_existence_proof__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   cosmos__ics23__v1__compressed_non_existence_proof__free_unpacked
                     (Cosmos__Ics23__V1__CompressedNonExistenceProof *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Cosmos__Ics23__V1__ExistenceProof_Closure)
                 (const Cosmos__Ics23__V1__ExistenceProof *message,
                  void *closure_data);
typedef void (*Cosmos__Ics23__V1__NonExistenceProof_Closure)
                 (const Cosmos__Ics23__V1__NonExistenceProof *message,
                  void *closure_data);
typedef void (*Cosmos__Ics23__V1__CommitmentProof_Closure)
                 (const Cosmos__Ics23__V1__CommitmentProof *message,
                  void *closure_data);
typedef void (*Cosmos__Ics23__V1__LeafOp_Closure)
                 (const Cosmos__Ics23__V1__LeafOp *message,
                  void *closure_data);
typedef void (*Cosmos__Ics23__V1__InnerOp_Closure)
                 (const Cosmos__Ics23__V1__InnerOp *message,
                  void *closure_data);
typedef void (*Cosmos__Ics23__V1__ProofSpec_Closure)
                 (const Cosmos__Ics23__V1__ProofSpec *message,
                  void *closure_data);
typedef void (*Cosmos__Ics23__V1__InnerSpec_Closure)
                 (const Cosmos__Ics23__V1__InnerSpec *message,
                  void *closure_data);
typedef void (*Cosmos__Ics23__V1__BatchProof_Closure)
                 (const Cosmos__Ics23__V1__BatchProof *message,
                  void *closure_data);
typedef void (*Cosmos__Ics23__V1__BatchEntry_Closure)
                 (const Cosmos__Ics23__V1__BatchEntry *message,
                  void *closure_data);
typedef void (*Cosmos__Ics23__V1__CompressedBatchProof_Closure)
                 (const Cosmos__Ics23__V1__CompressedBatchProof *message,
                  void *closure_data);
typedef void (*Cosmos__Ics23__V1__CompressedBatchEntry_Closure)
                 (const Cosmos__Ics23__V1__CompressedBatchEntry *message,
                  void *closure_data);
typedef void (*Cosmos__Ics23__V1__CompressedExistenceProof_Closure)
                 (const Cosmos__Ics23__V1__CompressedExistenceProof *message,
                  void *closure_data);
typedef void (*Cosmos__Ics23__V1__CompressedNonExistenceProof_Closure)
                 (const Cosmos__Ics23__V1__CompressedNonExistenceProof *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCEnumDescriptor    cosmos__ics23__v1__hash_op__descriptor;
extern const ProtobufCEnumDescriptor    cosmos__ics23__v1__length_op__descriptor;
extern const ProtobufCMessageDescriptor cosmos__ics23__v1__existence_proof__descriptor;
extern const ProtobufCMessageDescriptor cosmos__ics23__v1__non_existence_proof__descriptor;
extern const ProtobufCMessageDescriptor cosmos__ics23__v1__commitment_proof__descriptor;
extern const ProtobufCMessageDescriptor cosmos__ics23__v1__leaf_op__descriptor;
extern const ProtobufCMessageDescriptor cosmos__ics23__v1__inner_op__descriptor;
extern const ProtobufCMessageDescriptor cosmos__ics23__v1__proof_spec__descriptor;
extern const ProtobufCMessageDescriptor cosmos__ics23__v1__inner_spec__descriptor;
extern const ProtobufCMessageDescriptor cosmos__ics23__v1__batch_proof__descriptor;
extern const ProtobufCMessageDescriptor cosmos__ics23__v1__batch_entry__descriptor;
extern const ProtobufCMessageDescriptor cosmos__ics23__v1__compressed_batch_proof__descriptor;
extern const ProtobufCMessageDescriptor cosmos__ics23__v1__compressed_batch_entry__descriptor;
extern const ProtobufCMessageDescriptor cosmos__ics23__v1__compressed_existence_proof__descriptor;
extern const ProtobufCMessageDescriptor cosmos__ics23__v1__compressed_non_existence_proof__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_cosmos_2fics23_2fv1_2fproofs_2eproto__INCLUDED */
